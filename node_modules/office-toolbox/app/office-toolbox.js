#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk = require("chalk");
const commander = require("commander");
const fs = require("fs-extra");
const inquirer = require("inquirer");
const path = require("path");
const util = require("./util");
function logRejection(err) {
    let error = undefined;
    if (err instanceof Array) {
        if (err.length) {
            error = (err[0] instanceof Error) ? err[0] : new Error(err[0]);
            for (const message of err) {
                console.log(chalk.default.red(message));
            }
        }
    }
    else {
        error = (err instanceof Error) ? err : new Error(err);
        console.log(chalk.default.red(err));
    }
    util.appInsightsClient.trackException({ exception: error });
}
// PROMPT FUNCTIONS //
function promptForCommand() {
    return __awaiter(this, void 0, void 0, function* () {
        const question = {
            name: 'command',
            type: 'list',
            message: 'What do you want to do?',
            choices: ['List registered developer manifests',
                'Sideload a manifest',
                'Remove a manifest',
                'Validate a manifest']
        };
        yield inquirer.prompt(question).then((answer) => {
            switch (question.choices.indexOf(answer.command)) {
                case 0:
                    list();
                    break;
                case 1:
                    sideload(null, null);
                    break;
                case 2:
                    remove(null, null);
                    break;
                case 3:
                    validate(null);
                    break;
                default:
                    commander.help();
            }
        });
    });
}
function promptForApplication() {
    return __awaiter(this, void 0, void 0, function* () {
        const question = {
            name: 'application',
            type: 'list',
            message: 'Which application are you targeting?',
            choices: ['Word', 'Excel', 'PowerPoint', 'Outlook', 'OneNote', 'Project']
        };
        return inquirer.prompt(question).then((answer) => {
            return Promise.resolve(answer['application'].toLowerCase());
        });
    });
}
function checkAndPromptForPath(application, manifestPath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (manifestPath) {
            return manifestPath;
        }
        else {
            console.log('The path must be specified for the manifest.');
            return promptForPathOrChoose().then((manifestSelectionMethod) => {
                if (manifestSelectionMethod === 'path') {
                    return promptForManifestPath();
                }
                else if (manifestSelectionMethod === 'browse') {
                    return promptForManifestFromCurrentDirectory();
                }
                else if (manifestSelectionMethod === 'registered') {
                    return promptForManifestFromListOfRegisteredManifests(application);
                }
                else {
                    throw ('An invalid method of specifying the manifest was selected.');
                }
            });
        }
    });
}
function promptForPathOrChoose() {
    return __awaiter(this, void 0, void 0, function* () {
        const question = {
            name: 'pathorchoose',
            type: 'list',
            message: 'Would you like to specify the path to a developer manifest or choose one that you have already registered?',
            choices: ['Browse for a developer manifest from the current directory',
                'Specify the path to a developer manifest',
                'Choose a registered developer manifest']
        };
        return inquirer.prompt(question).then((answer) => {
            switch (question.choices.indexOf(answer.pathorchoose)) {
                case 0: return Promise.resolve('browse');
                case 1: return Promise.resolve('path');
                case 2: return Promise.resolve('registered');
            }
        });
    });
}
function promptForManifestFromListOfRegisteredManifests(application) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!application && process.platform !== 'win32') {
            application = yield promptForApplication();
        }
        const manifestPaths = yield util.getManifests(application);
        return promptForManifestPathFromList(manifestPaths, 'Choose a manifest:');
    });
}
function promptForManifestFromCurrentDirectory() {
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        const cwd = process.cwd();
        let manifestPath = cwd;
        while (fs.lstatSync(manifestPath).isDirectory()) {
            manifestPath = fs.realpathSync(manifestPath);
            const paths = yield getItemsInDirectory(manifestPath);
            const choice = yield promptForManifestPathFromList(paths, manifestPath);
            manifestPath = path.join(manifestPath, choice);
        }
        resolve(manifestPath);
    }));
}
function promptForManifestPathFromList(manifestPaths, message) {
    return __awaiter(this, void 0, void 0, function* () {
        const question = {
            name: 'manifestPath',
            type: 'list',
            message: message,
            choices: []
        };
        question.choices = [...manifestPaths];
        if (!question.choices.length) {
            return Promise.reject('There are no registered manifests to choose from.');
        }
        else {
            return inquirer.prompt(question).then(answers => {
                return Promise.resolve(answers['manifestPath']);
            });
        }
    });
}
// Searches under the current directory for any files or extensions with extension .xml
function getItemsInDirectory(directory) {
    let manifestPaths = [];
    let dirPaths = [".."];
    try {
        const files = fs.readdirSync(directory);
        files.forEach((file) => __awaiter(this, void 0, void 0, function* () {
            const fullPath = path.join(directory, file);
            let stats;
            try {
                stats = fs.statSync(fullPath);
            }
            catch (e) {
                // Do nothing
            }
            if (stats && stats.isDirectory()) {
                dirPaths.push(file);
            }
            else if (path.extname(fullPath) === '.xml') {
                manifestPaths.push(file);
            }
        }));
    }
    catch (err) {
        return null;
    }
    return [...manifestPaths, ...dirPaths];
}
function promptForManifestPath() {
    const question = {
        name: 'manifestPath',
        type: 'input',
        message: 'Specify the path to the XML manifest file:',
    };
    return inquirer.prompt(question).then((answers) => {
        let manifestPath = answers['manifestPath'];
        if (manifestPath.charAt(0) === '"' && manifestPath.charAt(manifestPath.length - 1) === '"') {
            manifestPath = manifestPath.substr(1, manifestPath.length - 2);
        }
        return Promise.resolve(manifestPath);
    });
}
// TOP-LEVEL FUNCTIONS //
function list() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const manifestInformation = yield util.list();
            if (!manifestInformation || !manifestInformation.length) {
                console.log('No manifests were found.');
                return;
            }
            for (const [id, manifestPath, application] of (manifestInformation)) {
                let manifestString = (!application) ? '' : (application + ' ');
                manifestString += (!id) ? 'unknown                              ' : id + ' ';
                manifestString += manifestPath;
                console.log(manifestString);
            }
        }
        catch (err) {
            logRejection(err);
        }
    });
}
function sideload(application, manifestPath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (!application || Object.keys(util.applicationProperties).indexOf(application) < 0) {
                console.log('A valid application must be specified.');
                application = yield promptForApplication();
            }
            const appProperties = util.applicationProperties[application];
            if (appProperties.canSideload) {
                manifestPath = yield checkAndPromptForPath(application, manifestPath);
                yield util.sideload(application, manifestPath);
                console.log(`For more information about how to sideload Office Add-ins, visit the following link: ${appProperties.documentationLink}`);
            }
            else {
                console.log(`Automatic sideloading is not available for this app, please follow the instructions in the following link: ${appProperties.documentationLink}`);
            }
        }
        catch (err) {
            logRejection(err);
        }
    });
}
function remove(application, manifestPath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (process.platform === 'win32') {
                application = null;
            }
            else if ((!application || Object.keys(util.applicationProperties).indexOf(application) < 0)) {
                console.log('A valid application must be specified.');
                application = yield promptForApplication();
            }
            if (!manifestPath) {
                manifestPath = yield promptForManifestFromListOfRegisteredManifests(application);
            }
            util.remove(application, manifestPath);
        }
        catch (err) {
            logRejection(err);
        }
    });
}
function validate(manifestPath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            manifestPath = yield checkAndPromptForPath(null, manifestPath);
            yield util.validate(manifestPath);
        }
        catch (err) {
            logRejection(err);
        }
    });
}
// COMMANDER: Parse command-line input //
commander.on('--help', () => {
    console.log('  For help on a particular command, use:');
    console.log('');
    console.log('    office-toolbox [command] --help');
    console.log('');
});
commander
    .command('list')
    .action(() => {
    list();
});
commander
    .command('sideload')
    .option('-a, --application <application>', 'The Office application. Word, Excel, and PowerPoint are currently supported.')
    .option('-m, --manifest_path <manifest_path>', 'The path of the manifest file to sideload and launch.')
    .action((options) => __awaiter(this, void 0, void 0, function* () {
    let application = (!options.application ? null : options.application.toLowerCase());
    sideload(application, options.manifest_path);
}));
commander
    .command('remove')
    .option('-a, --application <application>', 'The Office application. Word, PowerPoint, and Excel are currently supported. This parameter is ignored on Windows.')
    .option('-m, --manifest_path <manifest_path>', 'The path of the manifest file to remove.')
    .action((options) => __awaiter(this, void 0, void 0, function* () {
    let application = (!options.application ? null : options.application.toLowerCase());
    remove(application, options.manifest_path);
}));
commander
    .command('validate')
    .option('-m, --manifest_path <manifest_path>', 'The path of the manifest file to validate.')
    .action((options) => __awaiter(this, void 0, void 0, function* () {
    validate(options.manifest_path);
}));
commander
    .command('*')
    .action(() => {
    commander.help();
});
commander
    .parse(process.argv);
if (commander.args.length < 1) {
    promptForCommand();
}
//# sourceMappingURL=office-toolbox.js.map