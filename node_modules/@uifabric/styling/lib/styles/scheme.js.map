{"version":3,"file":"scheme.js","sourceRoot":"../src/","sources":["styles/scheme.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,aAAa,EAAsB,MAAM,qBAAqB,CAAC;AAGxF;;;;;;;;;;;;;GAaG;AACH,MAAM,2BAA2B,OAA2B,EAAE,MAAqB,EAAE,KAAc;IACjG,IAAI,UAAU,GAAuB,OAAO,CAAC;IAC7C,IAAI,WAAW,CAAC;IAEhB,+EAA+E;IAC/E,IAAI,YAAY,GAAG,KAAK,IAAI,cAAc,CAAC,WAAW,CAAC,CAAC,OAAO,CAAC,EAAE,SAAS,EAAE,OAAO,CAAC,cAAc,CAAC,CAAC,KAAK,CAAC;IAE3G,IAAI,KAAK,EAAE;QACT,WAAW,GAAG,EAAE,KAAK,OAAA,EAAE,CAAC;KACzB;IAED,IAAM,WAAW,GAAuB,MAAM,IAAI,YAAY,IAAI,YAAY,CAAC,OAAO,IAAI,YAAY,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IAEvH,mIAAmI;IACnI,IAAI,YAAY,IAAI,WAAW,IAAI,YAAY,KAAK,WAAW,EAAE;QAC/D,WAAW,GAAG,EAAE,KAAK,EAAE,WAAW,EAAE,CAAC;QACrC,WAAW,CAAC,KAAK,CAAC,OAAO,GAAG,YAAY,CAAC,OAAO,CAAC;KAClD;IAED,IAAI,WAAW,EAAE;QACf,UAAU,GAAG;YACX,cAAc,EAAE;gBACd,QAAQ,EAAE,aAAa,CAAC,OAAO,CAAC,cAAc,CAAC,QAAQ,EAAE,WAAW,CAAC;gBACrE,cAAc,EAAE,OAAO,CAAC,cAAc,CAAC,cAAc;aACtD;SACF,CAAC;KACH;IAED,OAAO,UAAU,CAAC;AACpB,CAAC","sourcesContent":["import { Customizations, mergeSettings, ICustomizerContext } from '@uifabric/utilities';\r\nimport { ISchemeNames, ITheme } from '../interfaces/index';\r\n\r\n/**\r\n * @internal\r\n * This function is still in experimental phase in support of Foundation experimental development. Its API signature and existence\r\n * are subject to change.\r\n *\r\n * Modify context to activate the specified scheme or theme. For schemes, look in context (if available) and fall back to global\r\n * Customizations. If both scheme and theme are specified, scheme will be looked up in theme. In this case, scheme must be\r\n * present in theme arg, otherwise new context will default to theme arg (there is no fallback to settings to look up scheme.)\r\n *\r\n * @param context - Context in which to get schemed customizations.\r\n * @param scheme - Scheme to get customizations for from theme arg (if supplied) OR from context and global settings.\r\n * @param theme - Theme to merge into context.\r\n * @returns modified schemed context if scheme is valid and not already applied, unmodified context otherwise.\r\n */\r\nexport function getThemedContext(context: ICustomizerContext, scheme?: ISchemeNames, theme?: ITheme): ICustomizerContext {\r\n  let newContext: ICustomizerContext = context;\r\n  let newSettings;\r\n\r\n  // Only fall back to context and customizations when theme arg is not provided.\r\n  let schemeSource = theme || Customizations.getSettings(['theme'], undefined, context.customizations).theme;\r\n\r\n  if (theme) {\r\n    newSettings = { theme };\r\n  }\r\n\r\n  const schemeTheme: ITheme | undefined = scheme && schemeSource && schemeSource.schemes && schemeSource.schemes[scheme];\r\n\r\n  // These first two checks are logically redundant but TS doesn't infer schemeSource.schemes is defined when schemeTheme is defined.\r\n  if (schemeSource && schemeTheme && schemeSource !== schemeTheme) {\r\n    newSettings = { theme: schemeTheme };\r\n    newSettings.theme.schemes = schemeSource.schemes;\r\n  }\r\n\r\n  if (newSettings) {\r\n    newContext = {\r\n      customizations: {\r\n        settings: mergeSettings(context.customizations.settings, newSettings),\r\n        scopedSettings: context.customizations.scopedSettings\r\n      }\r\n    };\r\n  }\r\n\r\n  return newContext;\r\n}\r\n"]}