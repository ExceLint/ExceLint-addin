{"version":3,"file":"createComponent.js","sourceRoot":"../src/","sources":["createComponent.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAE,eAAe,EAAqB,MAAM,mBAAmB,CAAC;AACvE,OAAO,EAAE,cAAc,EAAE,iBAAiB,EAAsB,MAAM,qBAAqB,CAAC;AAC5F,OAAO,EAAE,aAAa,EAAE,MAAM,SAAS,CAAC;AACxC,OAAO,EAAE,MAAM,EAAE,MAAM,aAAa,CAAC;AAKrC;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH,MAAM,0BAMJ,SAAgF;IACxE,IAAA,6BAAmB,EAAnB,wCAAmB,CAAe;IAClC,IAAA,wCAAW,CAAoB;IAEvC,IAAM,MAAM,GAA8C,UAAC,cAA+B;QACxF,OAAO;QACL,4GAA4G;QAC5G,oBAAC,iBAAiB,CAAC,QAAQ,QACxB,UAAC,OAA2B;YAC3B,wGAAwG;YACxG,0HAA0H;YAC1H,wEAAwE;YACxE,8DAA8D;YAC9D,8FAA8F;YAC9F,+FAA+F;YAC/F,iHAAiH;YACjH,6DAA6D;YAC7D,IAAM,QAAQ,GAAwD,kBAAkB,CACtF,SAAS,CAAC,WAAW,EACrB,OAAO,EACP,SAAS,CAAC,MAAM,CACjB,CAAC;YAEF,IAAM,UAAU,GAA8B,UAAA,SAAS;gBACrD,0GAA0G;gBAC1G,sGAAsG;gBACtG,oCAAoC;gBACpC,4FAA4F;gBAC5F,yHAAyH;gBACzH,IAAM,WAAW,GAA0E,SAAS;oBAClG,CAAC,sBACO,cAAsB,EACtB,SAAiB,EAEzB,CAAC,CAAC,cAAc,CAAC;gBAEnB,IAAM,KAAK,GAAG,WAAW,CAAC,KAAK,IAAI,QAAQ,CAAC,KAAK,CAAC;gBAElD,IAAM,MAAM,GAAG,cAAc,CAAC,WAAW,EAAE,KAAK,EAAE,SAAS,CAAC,MAAM,EAAE,QAAQ,CAAC,MAAM,EAAE,WAAW,CAAC,MAAM,CAAC,CAAC;gBACzG,IAAM,MAAM,GAAG,cAAc,CAAC,WAAW,EAAE,KAAK,EAAE,MAAM,EAAE,SAAS,CAAC,MAAM,EAAE,QAAQ,CAAC,MAAM,EAAE,WAAW,CAAC,MAAM,CAAC,CAAC;gBAEjH,IAAM,kBAAkB,wBAClB,WAAmB,IACvB,cAAc,EAAE,MAAM,GACvB,CAAC;gBAEF,OAAO,SAAS,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;YAC5C,CAAC,CAAC;YACF,OAAO,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,oBAAC,SAAS,CAAC,KAAK,uBAAK,cAAc,IAAE,UAAU,EAAE,UAAU,IAAI,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;QAC1G,CAAC,CAC0B,CAC9B,CAAC;IACJ,CAAC,CAAC;IAEF,MAAM,CAAC,WAAW,GAAG,SAAS,CAAC,WAAW,CAAC;IAE3C,sEAAsE;IACtE,kGAAkG;IAClG,8GAA8G;IAC9G,IAAI,WAAW,EAAE;QACd,MAAwC,CAAC,MAAM,GAAG,aAAa,CAAC,MAAM,EAAE,EAAE,WAAW,aAAA,EAAE,CAAC,CAAC;KAC3F;IAED,MAAM,CAAC,MAAM,EAAE,SAAS,CAAC,OAAO,CAAC,CAAC;IAElC,uGAAuG;IACvG,OAAO,MAA8D,CAAC;AACxE,CAAC;AAED;;GAEG;AACH,wBACE,KAAa,EACb,KAAa,EACb,MAAe;IACf,mBAAiF;SAAjF,UAAiF,EAAjF,qBAAiF,EAAjF,IAAiF;QAAjF,kCAAiF;;IAEjF,OAAO,eAAe,eACjB,SAAS,CAAC,GAAG,CAAC,UAAC,MAAuE;QACvF,OAAA,OAAO,MAAM,KAAK,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM;IAApE,CAAoE,CACrE,EACD;AACJ,CAAC;AAED;;GAEG;AACH,wBACE,KAAiB,EACjB,KAAa;IACb,mBAAwE;SAAxE,UAAwE,EAAxE,qBAAwE,EAAxE,IAAwE;QAAxE,kCAAwE;;IAExE,IAAM,MAAM,GAAG,EAAE,CAAC;IAElB,KAA0B,UAAS,EAAT,uBAAS,EAAT,uBAAS,EAAT,IAAS;QAA9B,IAAI,aAAa,kBAAA;QACpB,IAAI,aAAa,EAAE;YACjB,aAAa,GAAG,OAAO,aAAa,KAAK,UAAU,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC;YAElG,IAAI,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE;gBAChC,aAAa,GAAG,cAAc,gBAAC,KAAK,EAAE,KAAK,SAAK,aAAa,EAAC,CAAC;aAChE;YAED,MAAM,gBAAC,MAAM,SAAM,aAAqB,GAAE;SAC3C;KACF;IAED,OAAO,MAAiB,CAAC;AAC3B,CAAC;AAED;;;;;;GAMG;AACH,4BACE,WAAmB,EACnB,OAA2B,EAC3B,MAAiB;IAEjB,mFAAmF;IACnF,8EAA8E;IAC9E,yGAAyG;IACzG,IAAM,aAAa,GAAG,CAAC,OAAO,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;IACpD,OAAO,cAAc,CAAC,WAAW,CAAC,MAAM,IAAI,aAAa,EAAE,WAAW,EAAE,OAAO,CAAC,cAAc,CAAC,CAAC;AAClG,CAAC","sourcesContent":["import * as React from 'react';\r\nimport { concatStyleSets, IStyleSet, ITheme } from '@uifabric/styling';\r\nimport { Customizations, CustomizerContext, ICustomizerContext } from '@uifabric/utilities';\r\nimport { createFactory } from './slots';\r\nimport { assign } from './utilities';\r\n\r\nimport { IComponent, ICustomizationProps, IStyleableComponentProps, IStylesFunctionOrObject, IToken, IViewRenderer } from './IComponent';\r\nimport { IDefaultSlotProps, ISlotCreator } from './ISlots';\r\n\r\n/**\r\n * Assembles a higher order component based on the following: styles, theme, view, and state.\r\n * Imposes a separation of concern and centralizes styling processing to increase ease of use and robustness\r\n * in how components use and apply styling and theming.\r\n *\r\n * Automatically merges and applies themes and styles with theme / styleprops having the highest priority.\r\n * State component, if provided, is passed in props for processing. Props from state / user are automatically processed\r\n * and styled before finally being passed to view.\r\n *\r\n * State components should contain all stateful behavior and should not generate any JSX, but rather simply call the view prop.\r\n * Views should simply be stateless pure functions that receive all props needed for rendering their output.\r\n * State component is optional. If state is not provided, created component is essentially a functional stateless component.\r\n *\r\n * * TComponentProps: A styleable props interface for the created component.\r\n * * TTokens: The type for tokens props.\r\n * * TStyleSet: The type for styles properties.\r\n * * TViewProps: The props specific to the view, including processed properties outputted by optional state component. If state\r\n * component is not provided, TComponentProps is the same as TViewProps.\r\n * * TStatics: Static type for statics applied to created component object.\r\n *\r\n * @param {IComponent} component Component options. See IComponent for more detail.\r\n */\r\nexport function createComponent<\r\n  TComponentProps,\r\n  TTokens,\r\n  TStyleSet extends IStyleSet<TStyleSet>,\r\n  TViewProps = TComponentProps,\r\n  TStatics = {}\r\n>(component: IComponent<TComponentProps, TTokens, TStyleSet, TViewProps, TStatics>): React.StatelessComponent<TComponentProps> & TStatics {\r\n  const { factoryOptions = {} } = component;\r\n  const { defaultProp } = factoryOptions;\r\n\r\n  const result: React.StatelessComponent<TComponentProps> = (componentProps: TComponentProps) => {\r\n    return (\r\n      // TODO: createComponent is also affected by https://github.com/OfficeDev/office-ui-fabric-react/issues/6603\r\n      <CustomizerContext.Consumer>\r\n        {(context: ICustomizerContext) => {\r\n          // TODO: this next line is basically saying 'theme' prop will ALWAYS be available from getCustomizations\r\n          //        via ICustomizationProps cast. Is there mechanism that guarantees theme and other request fields will be defined?\r\n          //        is there a static init that guarantees theme will be provided?\r\n          //        what happens if createTheme/loadTheme is not called?\r\n          //        if so, convey through getCustomizations typing keying off fields. can we convey this\r\n          //          all the way from Customizations with something like { { K in fields }: object}? hmm\r\n          //        if not, how does existing \"theme!\" styles code work without risk of failing (assuming it doesn't fail)?\r\n          // For now cast return value as if theme is always available.\r\n          const settings: ICustomizationProps<TViewProps, TTokens, TStyleSet> = _getCustomizations(\r\n            component.displayName,\r\n            context,\r\n            component.fields\r\n          );\r\n\r\n          const renderView: IViewRenderer<TViewProps> = viewProps => {\r\n            // The approach here is to allow state components to provide only the props they care about, automatically\r\n            //    merging user props and state props together. This ensures all props are passed properly to view,\r\n            //    including children and styles.\r\n            // TODO: for full 'fields' support, 'rest' props from customizations need to pass onto view.\r\n            //        however, customized props like theme will break snapshots. how is styled not showing theme output in snapshots?\r\n            const mergedProps: TViewProps & IStyleableComponentProps<TViewProps, TTokens, TStyleSet> = viewProps\r\n              ? {\r\n                  ...(componentProps as any),\r\n                  ...(viewProps as any)\r\n                }\r\n              : componentProps;\r\n\r\n            const theme = mergedProps.theme || settings.theme;\r\n\r\n            const tokens = _resolveTokens(mergedProps, theme, component.tokens, settings.tokens, mergedProps.tokens);\r\n            const styles = _resolveStyles(mergedProps, theme, tokens, component.styles, settings.styles, mergedProps.styles);\r\n\r\n            const viewComponentProps: typeof mergedProps & IDefaultSlotProps<any> = {\r\n              ...(mergedProps as any),\r\n              _defaultStyles: styles\r\n            };\r\n\r\n            return component.view(viewComponentProps);\r\n          };\r\n          return component.state ? <component.state {...componentProps} renderView={renderView} /> : renderView();\r\n        }}\r\n      </CustomizerContext.Consumer>\r\n    );\r\n  };\r\n\r\n  result.displayName = component.displayName;\r\n\r\n  // If a shorthand prop is defined, create a factory for the component.\r\n  // TODO: This shouldn't be a concern of createComponent.. factoryOptions should just be forwarded.\r\n  //       Need to weigh creating default factories on component creation vs. memozing them on use in slots.tsx.\r\n  if (defaultProp) {\r\n    (result as ISlotCreator<TComponentProps>).create = createFactory(result, { defaultProp });\r\n  }\r\n\r\n  assign(result, component.statics);\r\n\r\n  // Later versions of TypeSript should allow us to merge objects in a type safe way and avoid this cast.\r\n  return result as React.StatelessComponent<TComponentProps> & TStatics;\r\n}\r\n\r\n/**\r\n * Resolve all styles functions with both props and tokens and flatten results along with all styles objects.\r\n */\r\nfunction _resolveStyles<TProps, TTokens, TStyleSet extends IStyleSet<TStyleSet>>(\r\n  props: TProps,\r\n  theme: ITheme,\r\n  tokens: TTokens,\r\n  ...allStyles: (IStylesFunctionOrObject<TProps, TTokens, TStyleSet> | undefined)[]\r\n): ReturnType<typeof concatStyleSets> {\r\n  return concatStyleSets(\r\n    ...allStyles.map((styles: IStylesFunctionOrObject<TProps, TTokens, TStyleSet> | undefined) =>\r\n      typeof styles === 'function' ? styles(props, theme, tokens) : styles\r\n    )\r\n  );\r\n}\r\n\r\n/**\r\n * Resolve all tokens functions with props flatten results along with all tokens objects.\r\n */\r\nfunction _resolveTokens<TViewProps, TTokens>(\r\n  props: TViewProps,\r\n  theme: ITheme,\r\n  ...allTokens: (IToken<TViewProps, TTokens> | false | null | undefined)[]\r\n): TTokens {\r\n  const tokens = {};\r\n\r\n  for (let currentTokens of allTokens) {\r\n    if (currentTokens) {\r\n      currentTokens = typeof currentTokens === 'function' ? currentTokens(props, theme) : currentTokens;\r\n\r\n      if (Array.isArray(currentTokens)) {\r\n        currentTokens = _resolveTokens(props, theme, ...currentTokens);\r\n      }\r\n\r\n      assign(tokens, ...(currentTokens as any));\r\n    }\r\n  }\r\n\r\n  return tokens as TTokens;\r\n}\r\n\r\n/**\r\n * Helper function for calling Customizations.getSettings falling back to default fields.\r\n *\r\n * @param displayName Displayable name for component.\r\n * @param context React context passed to component containing contextual settings.\r\n * @param fields Optional list of properties to grab from global store and context.\r\n */\r\nfunction _getCustomizations<TViewProps, TTokens, TStyleSet extends IStyleSet<TStyleSet>>(\r\n  displayName: string,\r\n  context: ICustomizerContext,\r\n  fields?: string[]\r\n): ICustomizationProps<TViewProps, TTokens, TStyleSet> {\r\n  // TODO: do we want field props? should fields be part of IComponent and used here?\r\n  // TODO: should we centrally define DefaultFields? (not exported from styling)\r\n  // TOOD: tie this array to ICustomizationProps, such that each array element is keyof ICustomizationProps\r\n  const DefaultFields = ['theme', 'styles', 'tokens'];\r\n  return Customizations.getSettings(fields || DefaultFields, displayName, context.customizations);\r\n}\r\n"]}