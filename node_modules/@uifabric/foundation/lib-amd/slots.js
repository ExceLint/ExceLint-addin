define(["require", "exports", "tslib", "react", "@uifabric/styling", "@uifabric/utilities", "./utilities"], function (require, exports, tslib_1, React, styling_1, utilities_1, utilities_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // TODO: Is getting only div props for 'root' slots is pretty limiting? Or is it exactly as it needs to be?
    //        Another example is getting Toggle state for `label` slot render functions. Should it get Toggle props instead?
    //        Needs more usage to rationalize the best approach. If we want component props, component props are passed
    //        as each slot as rendered and aren't available when getSlots is called. This would substantially change this approach.
    /**
     * This function is required for any module that uses slots.
     *
     * This function is a slot resolver that automatically evaluates slot functions to generate React elements.
     * A byproduct of this resolver is that it removes slots from the React hierarchy by bypassing React.createElement.
     *
     * To use this function on a per-file basis, use the jsx directive targeting withSlots.
     * This directive must be the FIRST LINE in the file to work correctly.
     * Usage of this pragma also requires withSlots import statement.
     *
     * See React.createElement
     */
    // Can't use typeof on React.createElement since it's overloaded. Approximate createElement's signature for now and widen as needed.
    function withSlots(type, props) {
        // tslint:disable-next-line:missing-optional-annotation
        var children = [];
        for (
        // tslint:disable-next-line:missing-optional-annotation
        var _i = 2; 
        // tslint:disable-next-line:missing-optional-annotation
        _i < arguments.length; 
        // tslint:disable-next-line:missing-optional-annotation
        _i++) {
            // tslint:disable-next-line:missing-optional-annotation
            children[_i - 2] = arguments[_i];
        }
        var slotType = type;
        if (slotType.isSlot) {
            // TODO: There is something weird going on here with children embedded in props vs. rest args.
            // Comment out these lines to see. Make sure this function is doing the right things.
            var numChildren = React.Children.count(children);
            if (numChildren === 0) {
                return slotType(props);
            }
            // Since we are bypassing createElement, use React.Children.toArray to make sure children are properly assigned keys.
            // TODO: should this be mutating? does React mutate children subprop with createElement?
            // TODO: will toArray clobber existing keys?
            // TODO: React generates warnings because it doesn't detect hidden member _store that is set in createElement.
            //        Even children passed to createElement without keys don't generate this warning.
            //        Is there a better way to prevent slots from appearing in hierarchy? toArray doesn't address root issue.
            children = React.Children.toArray(children);
            return slotType(tslib_1.__assign({}, props, { children: children }));
        }
        else {
            // TODO: Are there some cases where children should NOT be spread? Also, spreading reraises perf question.
            //        Children had to be spread to avoid breaking KeytipData in Toggle.view:
            //        react-dom.development.js:18931 Uncaught TypeError: children is not a function
            //        Without spread, function child is a child array of one element
            // TODO: is there a reason this can't be:
            // return React.createElement.apply(this, arguments);
            return React.createElement.apply(React, [type, props].concat(children));
        }
    }
    exports.withSlots = withSlots;
    /**
     * This function creates factories that render ouput depending on the user ISlotProp props passed in.
     * @param ComponentType - Base component to render when not overridden by user props.
     * @param options - Factory options, including defaultProp value for shorthand prop mapping.
     * @returns ISlotFactory function used for rendering slots.
     */
    function createFactory(ComponentType, options) {
        if (options === void 0) { options = {}; }
        var _a = options.defaultProp, defaultProp = _a === void 0 ? 'children' : _a;
        var result = function (componentProps, userProps, defaultStyles) {
            // If they passed in raw JSX, just return that.
            if (React.isValidElement(userProps)) {
                return userProps;
            }
            // If we're rendering a function, let the user resolve how to render given the original component and final args.
            if (typeof userProps === 'function') {
                var render = function (slotRenderFunction, renderProps) {
                    // TODO: _translateShorthand is returning TProps, so why is the finalProps cast required?
                    // TS isn't respecting the difference between props arg type and return type and instead treating both as ISlotPropValue.
                    var finalRenderProps = _translateShorthand(defaultProp, renderProps);
                    finalRenderProps = _constructFinalProps(defaultStyles, componentProps, finalRenderProps);
                    return slotRenderFunction(ComponentType, finalRenderProps);
                };
                return userProps(render);
            }
            userProps = _translateShorthand(defaultProp, userProps);
            // TODO: _translateShorthand is returning TProps, so why is the finalProps cast required?
            // TS isn't respecting the difference between props arg type and return type and instead treating both as ISlotPropValue.
            var finalProps = _constructFinalProps(defaultStyles, componentProps, userProps);
            return React.createElement(ComponentType, tslib_1.__assign({}, finalProps));
        };
        return result;
    }
    exports.createFactory = createFactory;
    /**
     * Default factory for components without explicit factories.
     */
    var defaultFactory = utilities_1.memoizeFunction(function (type) { return createFactory(type); });
    /**
     * This function generates slots that can be used in JSX given a definition of slots and their corresponding types.
     * @param userProps - Props as pass to component.
     * @param slots - Slot definition object defining the default slot component for each slot.
     * @returns A set of created slots that components can render in JSX.
     */
    function getSlots(userProps, slots) {
        var result = {};
        // userProps already has default props mixed in by createComponent. Recast here to gain typing for this function.
        var mixedProps = userProps;
        var _loop_1 = function (name_1) {
            if (slots.hasOwnProperty(name_1)) {
                // This closure method requires the use of withSlots to prevent unnecessary rerenders. This is because React detects
                //  each closure as a different component (since it is a new instance) from the previous one and then forces a rerender of the entire
                //  slot subtree. For now, the only way to avoid this is to use withSlots, which bypasses the call to React.createElement.
                var slot = function (componentProps) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    if (args.length > 0) {
                        // If React.createElement is being incorrectly used with slots, there will be additional arguments.
                        // We can detect these additional arguments and error on their presence.
                        throw new Error('Any module using getSlots must use withSlots. Please see withSlots javadoc for more info.');
                    }
                    return _renderSlot(slots[name_1], 
                    // TODO: this cast to any is hiding a relationship issue between the first two args
                    componentProps, mixedProps[name_1], 
                    // _defaultStyles should always be present, but a check for existence is added to make view tests easier to use.
                    mixedProps._defaultStyles && mixedProps._defaultStyles[name_1]);
                };
                slot.isSlot = true;
                result[name_1] = slot;
            }
        };
        for (var name_1 in slots) {
            _loop_1(name_1);
        }
        return result;
    }
    exports.getSlots = getSlots;
    /**
     * Helper function that constructs a props object when given shorthand props.
     */
    function _translateShorthand(defaultProp, props) {
        if (typeof props === 'string' || typeof props === 'number' || typeof props === 'boolean') {
            props = (_a = {},
                _a[defaultProp] = props,
                _a);
        }
        return props;
        var _a;
    }
    /**
     * Helper function that constructs final styles and props given a series of props ordered by increasing priority.
     */
    function _constructFinalProps(defaultStyles) {
        var allProps = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            allProps[_i - 1] = arguments[_i];
        }
        var finalProps = {};
        var classNames = [];
        for (var _a = 0, allProps_1 = allProps; _a < allProps_1.length; _a++) {
            var props = allProps_1[_a];
            classNames.push(props && props.className);
            utilities_2.assign.apply(void 0, [finalProps].concat(props));
        }
        finalProps.className = styling_1.mergeStyles(defaultStyles, classNames);
        return finalProps;
    }
    /**
     * Render a slot given component and user props. Uses component factory if available, otherwise falls back
     * to default factory.
     * @param ComponentType Factory component type.
     * @param componentProps The properties passed into slot from within the component.
     * @param userProps The user properties passed in from outside of the component.
     */
    function _renderSlot(ComponentType, componentProps, userProps, defaultStyles) {
        if (ComponentType.create !== undefined) {
            return ComponentType.create(componentProps, userProps, defaultStyles);
        }
        else {
            return defaultFactory(ComponentType)(componentProps, userProps, defaultStyles);
        }
    }
});
//# sourceMappingURL=slots.js.map