{"version":3,"file":"slots.js","sourceRoot":"../src/","sources":["slots.tsx"],"names":[],"mappings":";;;AAAA,6BAA+B;AAC/B,6CAAwD;AACxD,iDAAsD;AACtD,yCAAqC;AAerC,2GAA2G;AAC3G,wHAAwH;AACxH,mHAAmH;AACnH,+HAA+H;AAE/H;;;;;;;;;;;GAWG;AACH,oIAAoI;AACpI,mBACE,IAAsC,EACtC,KAAmC;IACnC,uDAAuD;IACvD,kBAA8B;;IAD9B,uDAAuD;IACvD,UAA8B;IAD9B,uDAAuD;IACvD,qBAA8B;IAD9B,uDAAuD;IACvD,IAA8B;QAD9B,uDAAuD;QACvD,iCAA8B;;IAE9B,IAAM,QAAQ,GAAG,IAAgB,CAAC;IAClC,IAAI,QAAQ,CAAC,MAAM,EAAE;QACnB,8FAA8F;QAC9F,qFAAqF;QACrF,IAAM,WAAW,GAAG,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QACnD,IAAI,WAAW,KAAK,CAAC,EAAE;YACrB,OAAO,QAAQ,CAAC,KAAK,CAAC,CAAC;SACxB;QAED,qHAAqH;QACrH,wFAAwF;QACxF,4CAA4C;QAC5C,8GAA8G;QAC9G,yFAAyF;QACzF,iHAAiH;QACjH,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QAE5C,OAAO,QAAQ,sBAAO,KAAa,IAAE,QAAQ,UAAA,IAAG,CAAC;KAClD;SAAM;QACL,0GAA0G;QAC1G,gFAAgF;QAChF,uFAAuF;QACvF,wEAAwE;QACxE,yCAAyC;QACzC,qDAAqD;QACrD,OAAO,KAAK,CAAC,aAAa,OAAnB,KAAK,GAAe,IAAI,EAAE,KAAK,SAAK,QAAQ,GAAE;KACtD;AACH,CAAC;AAjCD,8BAiCC;AAED;;;;;GAKG;AACH,uBACE,aAA0C,EAC1C,OAAqC;IAArC,wBAAA,EAAA,YAAqC;IAE7B,IAAA,wBAAwB,EAAxB,6CAAwB,CAAa;IAE7C,IAAM,MAAM,GAAyB,UAAC,cAAc,EAAE,SAAS,EAAE,aAAa;QAC5E,+CAA+C;QAC/C,IAAI,KAAK,CAAC,cAAc,CAAC,SAAS,CAAC,EAAE;YACnC,OAAO,SAAS,CAAC;SAClB;QAED,iHAAiH;QACjH,IAAI,OAAO,SAAS,KAAK,UAAU,EAAE;YACnC,IAAM,MAAM,GAA0B,UAAC,kBAAkB,EAAE,WAAW;gBACpE,yFAAyF;gBACzF,yHAAyH;gBACzH,IAAI,gBAAgB,GAAG,mBAAmB,CAAC,WAAW,EAAE,WAAW,CAAW,CAAC;gBAC/E,gBAAgB,GAAG,oBAAoB,CAAC,aAAa,EAAE,cAAc,EAAE,gBAAgB,CAAC,CAAC;gBAEzF,OAAO,kBAAkB,CAAC,aAAa,EAAE,gBAAgB,CAAC,CAAC;YAC7D,CAAC,CAAC;YACF,OAAO,SAAS,CAAC,MAAM,CAAC,CAAC;SAC1B;QAED,SAAS,GAAG,mBAAmB,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;QACxD,yFAAyF;QACzF,yHAAyH;QACzH,IAAM,UAAU,GAAG,oBAAoB,CAAC,aAAa,EAAE,cAAc,EAAE,SAAS,CAAW,CAAC;QAE5F,OAAO,oBAAC,aAAa,uBAAK,UAAU,EAAI,CAAC;IAC3C,CAAC,CAAC;IAEF,OAAO,MAAM,CAAC;AAChB,CAAC;AAlCD,sCAkCC;AAED;;GAEG;AACH,IAAM,cAAc,GAAG,2BAAe,CAAC,UAAA,IAAI,IAAI,OAAA,aAAa,CAAC,IAAI,CAAC,EAAnB,CAAmB,CAAC,CAAC;AAEpE;;;;;GAKG;AACH,kBACE,SAAiB,EACjB,KAAwC;IAExC,IAAM,MAAM,GAA6B,EAA8B,CAAC;IAExE,iHAAiH;IACjH,IAAM,UAAU,GAAG,SAA+C,CAAC;4BAExD,MAAI;QACb,IAAI,KAAK,CAAC,cAAc,CAAC,MAAI,CAAC,EAAE;YAC9B,oHAAoH;YACpH,qIAAqI;YACrI,0HAA0H;YAC1H,IAAM,IAAI,GAAwB,UAAC,cAAc;gBAAE,cAAc;qBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;oBAAd,6BAAc;;gBAC/D,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;oBACnB,mGAAmG;oBACnG,wEAAwE;oBACxE,MAAM,IAAI,KAAK,CAAC,2FAA2F,CAAC,CAAC;iBAC9G;gBACD,OAAO,WAAW,CAChB,KAAK,CAAC,MAAI,CAAC;gBACX,mFAAmF;gBACnF,cAAqB,EACrB,UAAU,CAAC,MAAI,CAAC;gBAChB,gHAAgH;gBAChH,UAAU,CAAC,cAAc,IAAI,UAAU,CAAC,cAAc,CAAC,MAAI,CAAC,CAC7D,CAAC;YACJ,CAAC,CAAC;YACF,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;YACnB,MAAM,CAAC,MAAI,CAAC,GAAG,IAAI,CAAC;SACrB;IACH,CAAC;IAvBD,KAAK,IAAM,MAAI,IAAI,KAAK;gBAAb,MAAI;KAuBd;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAnCD,4BAmCC;AAED;;GAEG;AACH,6BAAqC,WAAmB,EAAE,KAA6B;IACrF,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,OAAO,KAAK,KAAK,SAAS,EAAE;QACxF,KAAK,IAAG;YACN,GAAC,WAAW,IAAG,KAAY;cAClB,CAAA,CAAC;KACb;IACD,OAAO,KAAK,CAAC;;AACf,CAAC;AAED;;GAEG;AACH,8BAAkE,aAAqB;IAAE,kBAAmC;SAAnC,UAAmC,EAAnC,qBAAmC,EAAnC,IAAmC;QAAnC,iCAAmC;;IAC1H,IAAM,UAAU,GAAW,EAAS,CAAC;IACrC,IAAM,UAAU,GAA2B,EAAE,CAAC;IAE9C,KAAoB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ;QAAvB,IAAM,KAAK,iBAAA;QACd,UAAU,CAAC,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,SAAS,CAAC,CAAC;QAC1C,kBAAM,gBAAC,UAAU,SAAM,KAAa,GAAE;KACvC;IAED,UAAU,CAAC,SAAS,GAAG,qBAAW,CAAC,aAAa,EAAE,UAAU,CAAC,CAAC;IAE9D,OAAO,UAAU,CAAC;AACpB,CAAC;AAED;;;;;;GAMG;AACH,qBACE,aAAyB,EACzB,cAAsB,EACtB,SAAiB,EACjB,aAAqB;IAErB,IAAI,aAAa,CAAC,MAAM,KAAK,SAAS,EAAE;QACtC,OAAO,aAAa,CAAC,MAAM,CAAC,cAAc,EAAE,SAAS,EAAE,aAAa,CAAC,CAAC;KACvE;SAAM;QACL,OAAO,cAAc,CAAC,aAAa,CAAC,CAAC,cAAc,EAAE,SAAS,EAAE,aAAa,CAAC,CAAC;KAChF;AACH,CAAC","sourcesContent":["import * as React from 'react';\r\nimport { IStyle, mergeStyles } from '@uifabric/styling';\r\nimport { memoizeFunction } from '@uifabric/utilities';\r\nimport { assign } from './utilities';\r\nimport { IFactoryOptions } from './IComponent';\r\nimport {\r\n  ISlottableReactType,\r\n  ISlot,\r\n  ISlots,\r\n  ISlotDefinition,\r\n  ISlotFactory,\r\n  ISlotProps,\r\n  ISlotPropValue,\r\n  ISlotRenderer,\r\n  IDefaultSlotProps,\r\n  IProcessedSlotProps\r\n} from './ISlots';\r\n\r\n// TODO: Is getting only div props for 'root' slots is pretty limiting? Or is it exactly as it needs to be?\r\n//        Another example is getting Toggle state for `label` slot render functions. Should it get Toggle props instead?\r\n//        Needs more usage to rationalize the best approach. If we want component props, component props are passed\r\n//        as each slot as rendered and aren't available when getSlots is called. This would substantially change this approach.\r\n\r\n/**\r\n * This function is required for any module that uses slots.\r\n *\r\n * This function is a slot resolver that automatically evaluates slot functions to generate React elements.\r\n * A byproduct of this resolver is that it removes slots from the React hierarchy by bypassing React.createElement.\r\n *\r\n * To use this function on a per-file basis, use the jsx directive targeting withSlots.\r\n * This directive must be the FIRST LINE in the file to work correctly.\r\n * Usage of this pragma also requires withSlots import statement.\r\n *\r\n * See React.createElement\r\n */\r\n// Can't use typeof on React.createElement since it's overloaded. Approximate createElement's signature for now and widen as needed.\r\nexport function withSlots<P>(\r\n  type: ISlot<P> | React.SFC<P> | string,\r\n  props?: React.Attributes & P | null,\r\n  // tslint:disable-next-line:missing-optional-annotation\r\n  ...children: React.ReactNode[]\r\n): React.ReactElement<P> | JSX.Element | null {\r\n  const slotType = type as ISlot<P>;\r\n  if (slotType.isSlot) {\r\n    // TODO: There is something weird going on here with children embedded in props vs. rest args.\r\n    // Comment out these lines to see. Make sure this function is doing the right things.\r\n    const numChildren = React.Children.count(children);\r\n    if (numChildren === 0) {\r\n      return slotType(props);\r\n    }\r\n\r\n    // Since we are bypassing createElement, use React.Children.toArray to make sure children are properly assigned keys.\r\n    // TODO: should this be mutating? does React mutate children subprop with createElement?\r\n    // TODO: will toArray clobber existing keys?\r\n    // TODO: React generates warnings because it doesn't detect hidden member _store that is set in createElement.\r\n    //        Even children passed to createElement without keys don't generate this warning.\r\n    //        Is there a better way to prevent slots from appearing in hierarchy? toArray doesn't address root issue.\r\n    children = React.Children.toArray(children);\r\n\r\n    return slotType({ ...(props as any), children });\r\n  } else {\r\n    // TODO: Are there some cases where children should NOT be spread? Also, spreading reraises perf question.\r\n    //        Children had to be spread to avoid breaking KeytipData in Toggle.view:\r\n    //        react-dom.development.js:18931 Uncaught TypeError: children is not a function\r\n    //        Without spread, function child is a child array of one element\r\n    // TODO: is there a reason this can't be:\r\n    // return React.createElement.apply(this, arguments);\r\n    return React.createElement(type, props, ...children);\r\n  }\r\n}\r\n\r\n/**\r\n * This function creates factories that render ouput depending on the user ISlotProp props passed in.\r\n * @param ComponentType - Base component to render when not overridden by user props.\r\n * @param options - Factory options, including defaultProp value for shorthand prop mapping.\r\n * @returns ISlotFactory function used for rendering slots.\r\n */\r\nexport function createFactory<TProps>(\r\n  ComponentType: React.ComponentType<TProps>,\r\n  options: IFactoryOptions<TProps> = {}\r\n): ISlotFactory<TProps> {\r\n  const { defaultProp = 'children' } = options;\r\n\r\n  const result: ISlotFactory<TProps> = (componentProps, userProps, defaultStyles) => {\r\n    // If they passed in raw JSX, just return that.\r\n    if (React.isValidElement(userProps)) {\r\n      return userProps;\r\n    }\r\n\r\n    // If we're rendering a function, let the user resolve how to render given the original component and final args.\r\n    if (typeof userProps === 'function') {\r\n      const render: ISlotRenderer<TProps> = (slotRenderFunction, renderProps) => {\r\n        // TODO: _translateShorthand is returning TProps, so why is the finalProps cast required?\r\n        // TS isn't respecting the difference between props arg type and return type and instead treating both as ISlotPropValue.\r\n        let finalRenderProps = _translateShorthand(defaultProp, renderProps) as TProps;\r\n        finalRenderProps = _constructFinalProps(defaultStyles, componentProps, finalRenderProps);\r\n\r\n        return slotRenderFunction(ComponentType, finalRenderProps);\r\n      };\r\n      return userProps(render);\r\n    }\r\n\r\n    userProps = _translateShorthand(defaultProp, userProps);\r\n    // TODO: _translateShorthand is returning TProps, so why is the finalProps cast required?\r\n    // TS isn't respecting the difference between props arg type and return type and instead treating both as ISlotPropValue.\r\n    const finalProps = _constructFinalProps(defaultStyles, componentProps, userProps) as TProps;\r\n\r\n    return <ComponentType {...finalProps} />;\r\n  };\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Default factory for components without explicit factories.\r\n */\r\nconst defaultFactory = memoizeFunction(type => createFactory(type));\r\n\r\n/**\r\n * This function generates slots that can be used in JSX given a definition of slots and their corresponding types.\r\n * @param userProps - Props as pass to component.\r\n * @param slots - Slot definition object defining the default slot component for each slot.\r\n * @returns A set of created slots that components can render in JSX.\r\n */\r\nexport function getSlots<TProps extends TSlots, TSlots extends ISlotProps<TProps, TSlots>>(\r\n  userProps: TProps,\r\n  slots: ISlotDefinition<Required<TSlots>>\r\n): ISlots<Required<TSlots>> {\r\n  const result: ISlots<Required<TSlots>> = {} as ISlots<Required<TSlots>>;\r\n\r\n  // userProps already has default props mixed in by createComponent. Recast here to gain typing for this function.\r\n  const mixedProps = userProps as TProps & IDefaultSlotProps<TSlots>;\r\n\r\n  for (const name in slots) {\r\n    if (slots.hasOwnProperty(name)) {\r\n      // This closure method requires the use of withSlots to prevent unnecessary rerenders. This is because React detects\r\n      //  each closure as a different component (since it is a new instance) from the previous one and then forces a rerender of the entire\r\n      //  slot subtree. For now, the only way to avoid this is to use withSlots, which bypasses the call to React.createElement.\r\n      const slot: ISlot<keyof TSlots> = (componentProps, ...args: any[]) => {\r\n        if (args.length > 0) {\r\n          // If React.createElement is being incorrectly used with slots, there will be additional arguments.\r\n          // We can detect these additional arguments and error on their presence.\r\n          throw new Error('Any module using getSlots must use withSlots. Please see withSlots javadoc for more info.');\r\n        }\r\n        return _renderSlot(\r\n          slots[name],\r\n          // TODO: this cast to any is hiding a relationship issue between the first two args\r\n          componentProps as any,\r\n          mixedProps[name],\r\n          // _defaultStyles should always be present, but a check for existence is added to make view tests easier to use.\r\n          mixedProps._defaultStyles && mixedProps._defaultStyles[name]\r\n        );\r\n      };\r\n      slot.isSlot = true;\r\n      result[name] = slot;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Helper function that constructs a props object when given shorthand props.\r\n */\r\nfunction _translateShorthand<TProps>(defaultProp: string, props: ISlotPropValue<TProps>): TProps {\r\n  if (typeof props === 'string' || typeof props === 'number' || typeof props === 'boolean') {\r\n    props = {\r\n      [defaultProp]: props as any\r\n    } as TProps;\r\n  }\r\n  return props;\r\n}\r\n\r\n/**\r\n * Helper function that constructs final styles and props given a series of props ordered by increasing priority.\r\n */\r\nfunction _constructFinalProps<TProps extends IProcessedSlotProps>(defaultStyles: IStyle, ...allProps: (TProps | undefined)[]): TProps {\r\n  const finalProps: TProps = {} as any;\r\n  const classNames: (string | undefined)[] = [];\r\n\r\n  for (const props of allProps) {\r\n    classNames.push(props && props.className);\r\n    assign(finalProps, ...(props as any));\r\n  }\r\n\r\n  finalProps.className = mergeStyles(defaultStyles, classNames);\r\n\r\n  return finalProps;\r\n}\r\n\r\n/**\r\n * Render a slot given component and user props. Uses component factory if available, otherwise falls back\r\n * to default factory.\r\n * @param ComponentType Factory component type.\r\n * @param componentProps The properties passed into slot from within the component.\r\n * @param userProps The user properties passed in from outside of the component.\r\n */\r\nfunction _renderSlot<TComponent extends ISlottableReactType<TProps>, TProps, TSlots>(\r\n  ComponentType: TComponent,\r\n  componentProps: TProps,\r\n  userProps: TProps,\r\n  defaultStyles: IStyle\r\n): JSX.Element {\r\n  if (ComponentType.create !== undefined) {\r\n    return ComponentType.create(componentProps, userProps, defaultStyles);\r\n  } else {\r\n    return defaultFactory(ComponentType)(componentProps, userProps, defaultStyles);\r\n  }\r\n}\r\n"]}