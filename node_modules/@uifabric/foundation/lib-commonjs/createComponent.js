"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var styling_1 = require("@uifabric/styling");
var utilities_1 = require("@uifabric/utilities");
var slots_1 = require("./slots");
var utilities_2 = require("./utilities");
/**
 * Assembles a higher order component based on the following: styles, theme, view, and state.
 * Imposes a separation of concern and centralizes styling processing to increase ease of use and robustness
 * in how components use and apply styling and theming.
 *
 * Automatically merges and applies themes and styles with theme / styleprops having the highest priority.
 * State component, if provided, is passed in props for processing. Props from state / user are automatically processed
 * and styled before finally being passed to view.
 *
 * State components should contain all stateful behavior and should not generate any JSX, but rather simply call the view prop.
 * Views should simply be stateless pure functions that receive all props needed for rendering their output.
 * State component is optional. If state is not provided, created component is essentially a functional stateless component.
 *
 * @param component - component Component options. See IComponent for more detail.
 */
function createComponent(component) {
    var _a = component.factoryOptions, factoryOptions = _a === void 0 ? {} : _a;
    var defaultProp = factoryOptions.defaultProp;
    var result = function (componentProps) {
        return (
        // TODO: createComponent is also affected by https://github.com/OfficeDev/office-ui-fabric-react/issues/6603
        React.createElement(utilities_1.CustomizerContext.Consumer, null, function (context) {
            // TODO: this next line is basically saying 'theme' prop will ALWAYS be available from getCustomizations
            //        via ICustomizationProps cast. Is there mechanism that guarantees theme and other request fields will be defined?
            //        is there a static init that guarantees theme will be provided?
            //        what happens if createTheme/loadTheme is not called?
            //        if so, convey through getCustomizations typing keying off fields. can we convey this
            //          all the way from Customizations with something like { { K in fields }: object}? hmm
            //        if not, how does existing "theme!" styles code work without risk of failing (assuming it doesn't fail)?
            // For now cast return value as if theme is always available.
            var settings = _getCustomizations(component.displayName, context, component.fields);
            var renderView = function (viewProps) {
                // The approach here is to allow state components to provide only the props they care about, automatically
                //    merging user props and state props together. This ensures all props are passed properly to view,
                //    including children and styles.
                // TODO: for full 'fields' support, 'rest' props from customizations need to pass onto view.
                //        however, customized props like theme will break snapshots. how is styled not showing theme output in snapshots?
                var mergedProps = viewProps
                    ? tslib_1.__assign({}, componentProps, viewProps) : componentProps;
                var theme = mergedProps.theme || settings.theme;
                var tokens = _resolveTokens(mergedProps, theme, component.tokens, settings.tokens, mergedProps.tokens);
                var styles = _resolveStyles(mergedProps, theme, tokens, component.styles, settings.styles, mergedProps.styles);
                var viewComponentProps = tslib_1.__assign({}, mergedProps, { styles: styles,
                    tokens: tokens, _defaultStyles: styles });
                return component.view(viewComponentProps);
            };
            return component.state ? React.createElement(component.state, tslib_1.__assign({}, componentProps, { renderView: renderView })) : renderView();
        }));
    };
    result.displayName = component.displayName;
    // If a shorthand prop is defined, create a factory for the component.
    // TODO: This shouldn't be a concern of createComponent.. factoryOptions should just be forwarded.
    //       Need to weigh creating default factories on component creation vs. memozing them on use in slots.tsx.
    if (defaultProp) {
        result.create = slots_1.createFactory(result, { defaultProp: defaultProp });
    }
    utilities_2.assign(result, component.statics);
    // Later versions of TypeSript should allow us to merge objects in a type safe way and avoid this cast.
    return result;
}
exports.createComponent = createComponent;
/**
 * Resolve all styles functions with both props and tokens and flatten results along with all styles objects.
 */
function _resolveStyles(props, theme, tokens) {
    var allStyles = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        allStyles[_i - 3] = arguments[_i];
    }
    return styling_1.concatStyleSets.apply(void 0, allStyles.map(function (styles) {
        return typeof styles === 'function' ? styles(props, theme, tokens) : styles;
    }));
}
/**
 * Resolve all tokens functions with props flatten results along with all tokens objects.
 */
function _resolveTokens(props, theme) {
    var allTokens = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        allTokens[_i - 2] = arguments[_i];
    }
    var tokens = {};
    for (var _a = 0, allTokens_1 = allTokens; _a < allTokens_1.length; _a++) {
        var currentTokens = allTokens_1[_a];
        if (currentTokens) {
            currentTokens = typeof currentTokens === 'function' ? currentTokens(props, theme) : currentTokens;
            if (Array.isArray(currentTokens)) {
                currentTokens = _resolveTokens.apply(void 0, [props, theme].concat(currentTokens));
            }
            utilities_2.assign.apply(void 0, [tokens].concat(currentTokens));
        }
    }
    return tokens;
}
/**
 * Helper function for calling Customizations.getSettings falling back to default fields.
 *
 * @param displayName Displayable name for component.
 * @param context React context passed to component containing contextual settings.
 * @param fields Optional list of properties to grab from global store and context.
 */
function _getCustomizations(displayName, context, fields) {
    // TODO: do we want field props? should fields be part of IComponent and used here?
    // TODO: should we centrally define DefaultFields? (not exported from styling)
    // TOOD: tie this array to ICustomizationProps, such that each array element is keyof ICustomizationProps
    var DefaultFields = ['theme', 'styles', 'tokens'];
    return utilities_1.Customizations.getSettings(fields || DefaultFields, displayName, context.customizations);
}
//# sourceMappingURL=createComponent.js.map