{
  "kind": "package",
  "name": "@uifabric/utilities",
  "summary": [],
  "remarks": [],
  "exports": {
    "addDirectionalKeyCode": {
      "kind": "function",
      "signature": "export function addDirectionalKeyCode(which: number): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "which": {
          "name": "which",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "number"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Adds a keycode to the list of keys that, when pressed, should cause the focus outlines to be visible. This can be used to add global shortcut keys that directionally move from section to section within an app or between focus trap zones."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "addElementAtIndex": {
      "kind": "function",
      "signature": "export function addElementAtIndex<T>(array: T[], index: number, itemToAdd: T): T[];",
      "returnValue": {
        "type": "T[]",
        "description": []
      },
      "parameters": {
        "array": {
          "name": "array",
          "description": [
            {
              "kind": "text",
              "text": "The array to operate on"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "T[]"
        },
        "index": {
          "name": "index",
          "description": [
            {
              "kind": "text",
              "text": "The index where an element should be inserted"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "number"
        },
        "itemToAdd": {
          "name": "itemToAdd",
          "description": [
            {
              "kind": "text",
              "text": "The element to insert"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "T"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Given an array, this function returns a new array where an element has been inserted at the given index."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "appendFunction": {
      "kind": "function",
      "signature": "export function appendFunction(parent: any, ...functions: (any)[]): () => void;",
      "returnValue": {
        "type": "() => void",
        "description": []
      },
      "parameters": {
        "parent": {
          "name": "parent",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "any"
        },
        "functions": {
          "name": "functions",
          "description": [],
          "isOptional": false,
          "isSpread": true,
          "type": "(any)[]"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Returns a single function which will call each of the given functions in the context of the parent."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "arraysEqual": {
      "kind": "function",
      "signature": "export function arraysEqual<T>(array1: T[], array2: T[]): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": [
          {
            "kind": "text",
            "text": "True if the arrays are the same length and have the same values in the same positions, false otherwise."
          }
        ]
      },
      "parameters": {
        "array1": {
          "name": "array1",
          "description": [
            {
              "kind": "text",
              "text": "First array to compare"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "T[]"
        },
        "array2": {
          "name": "array2",
          "description": [
            {
              "kind": "text",
              "text": "Second array to compare"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "T[]"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Returns a boolean indicating if the two given arrays are equal in length and values."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "asAsync": {
      "kind": "function",
      "signature": "export function asAsync<TProps>(options: IAsAsyncOptions<TProps>): React.ComponentType<TProps & {\n    asyncPlaceholder?: React.ReactType;\n}>;",
      "returnValue": {
        "type": "React.ComponentType<TProps & {\n    asyncPlaceholder?: React.ReactType;\n}>",
        "description": []
      },
      "parameters": {
        "options": {
          "name": "options",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "IAsAsyncOptions<TProps>"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Produces a component which internally loads the target component before first mount. The component passes all props through to the loaded component."
        },
        {
          "kind": "paragraph"
        },
        {
          "kind": "text",
          "text": "This overload accepts a module with a default export for the component."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "assertNever": {
      "kind": "function",
      "signature": "export function assertNever(x: never): never;",
      "returnValue": {
        "type": "never",
        "description": []
      },
      "parameters": {
        "x": {
          "name": "x",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "never"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "AssertNever is a utility function that can be used for exhaustiveness checks in switch statements."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "assign": {
      "kind": "function",
      "signature": "export function assign(target: any, ...args: any[]): any;",
      "returnValue": {
        "type": "any",
        "description": [
          {
            "kind": "text",
            "text": "Resulting merged target."
          }
        ]
      },
      "parameters": {
        "target": {
          "name": "target",
          "description": [
            {
              "kind": "text",
              "text": "Target object to merge following object arguments into."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "any"
        },
        "args": {
          "name": "args",
          "description": [
            {
              "kind": "text",
              "text": "One or more objects that will be mixed into the target in the order they are provided."
            }
          ],
          "isOptional": false,
          "isSpread": true,
          "type": "any[]"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Makes a resulting merge of a bunch of objects. Pass in the target object followed by 1 or more objects as arguments and they will be merged sequentially into the target. Note that this will shallow merge; it will not create new cloned values for target members."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "Async": {
      "kind": "class",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Bugs often appear in async code when stuff gets disposed, but async operations don't get canceled. This Async helper class solves these issues by tying async code to the lifetime of a disposable object."
        },
        {
          "kind": "paragraph"
        },
        {
          "kind": "text",
          "text": "Usage: Anything class extending from BaseModel can access this helper via this.async. Otherwise create a new instance of the class and remember to call dispose() during your code's dispose handler."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "__constructor": {
          "kind": "constructor",
          "signature": "constructor(parent?: object, onError?: (e: any) => void);",
          "parameters": {
            "parent": {
              "name": "parent",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "object"
            },
            "onError": {
              "name": "onError",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "(e: any) => void"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Constructs a new instance of the "
            },
            {
              "kind": "api-link",
              "elements": [
                {
                  "kind": "text",
                  "text": "Async"
                }
              ],
              "target": {
                "scopeName": "@uifabric",
                "packageName": "utilities",
                "exportName": "Async",
                "memberName": ""
              }
            },
            {
              "kind": "text",
              "text": " class"
            }
          ],
          "remarks": []
        },
        "_logError": {
          "kind": "method",
          "signature": "protected _logError(e: any): void;",
          "accessModifier": "protected",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "e": {
              "name": "e",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "any"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "cancelAnimationFrame": {
          "kind": "method",
          "signature": "cancelAnimationFrame(id: number): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "id": {
              "name": "id",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "number"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "clearImmediate": {
          "kind": "method",
          "signature": "clearImmediate(id: number): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "id": {
              "name": "id",
              "description": [
                {
                  "kind": "text",
                  "text": "Id to cancel."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "number"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Clears the immediate."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "clearInterval": {
          "kind": "method",
          "signature": "clearInterval(id: number): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "id": {
              "name": "id",
              "description": [
                {
                  "kind": "text",
                  "text": "Id to cancel."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "number"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Clears the interval."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "clearTimeout": {
          "kind": "method",
          "signature": "clearTimeout(id: number): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "id": {
              "name": "id",
              "description": [
                {
                  "kind": "text",
                  "text": "Id to cancel."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "number"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Clears the timeout."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "debounce": {
          "kind": "method",
          "signature": "debounce<T extends Function>(func: T, wait?: number, options?: {\n        leading?: boolean;\n        maxWait?: number;\n        trailing?: boolean;\n    }): ICancelable<T> & (() => void);",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "ICancelable<T> & (() => void)",
            "description": [
              {
                "kind": "text",
                "text": "The new debounced function."
              }
            ]
          },
          "parameters": {
            "func": {
              "name": "func",
              "description": [
                {
                  "kind": "text",
                  "text": "The function to debounce."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "T"
            },
            "wait": {
              "name": "wait",
              "description": [
                {
                  "kind": "text",
                  "text": "The number of milliseconds to delay."
                }
              ],
              "isOptional": true,
              "isSpread": false,
              "type": "number"
            },
            "options": {
              "name": "options",
              "description": [
                {
                  "kind": "text",
                  "text": "The options object."
                }
              ],
              "isOptional": true,
              "isSpread": false,
              "type": "{\n        leading?: boolean;\n        maxWait?: number;\n        trailing?: boolean;\n    }"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Creates a function that will delay the execution of func until after wait milliseconds have elapsed since the last time it was invoked. Provide an options object to indicate that func should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls to the debounced function will return the result of the last func call."
            },
            {
              "kind": "paragraph"
            },
            {
              "kind": "text",
              "text": "Note: If leading and trailing options are true func will be called on the trailing edge of the timeout only if the the debounced function is invoked more than once during the wait timeout."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "dispose": {
          "kind": "method",
          "signature": "dispose(): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {},
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Dispose function, clears all async operations."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "requestAnimationFrame": {
          "kind": "method",
          "signature": "requestAnimationFrame(callback: () => void): number;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "number",
            "description": []
          },
          "parameters": {
            "callback": {
              "name": "callback",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "() => void"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "setImmediate": {
          "kind": "method",
          "signature": "setImmediate(callback: () => void): number;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "number",
            "description": [
              {
                "kind": "text",
                "text": "The setTimeout id."
              }
            ]
          },
          "parameters": {
            "callback": {
              "name": "callback",
              "description": [
                {
                  "kind": "text",
                  "text": "Callback to execute."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "() => void"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "SetImmediate override, which will auto cancel the immediate during dispose."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "setInterval": {
          "kind": "method",
          "signature": "setInterval(callback: () => void, duration: number): number;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "number",
            "description": [
              {
                "kind": "text",
                "text": "The setTimeout id."
              }
            ]
          },
          "parameters": {
            "callback": {
              "name": "callback",
              "description": [
                {
                  "kind": "text",
                  "text": "Callback to execute."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "() => void"
            },
            "duration": {
              "name": "duration",
              "description": [
                {
                  "kind": "text",
                  "text": "Duration in milliseconds."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "number"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "SetInterval override, which will auto cancel the timeout during dispose."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "setTimeout": {
          "kind": "method",
          "signature": "setTimeout(callback: () => void, duration: number): number;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "number",
            "description": [
              {
                "kind": "text",
                "text": "The setTimeout id."
              }
            ]
          },
          "parameters": {
            "callback": {
              "name": "callback",
              "description": [
                {
                  "kind": "text",
                  "text": "Callback to execute."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "() => void"
            },
            "duration": {
              "name": "duration",
              "description": [
                {
                  "kind": "text",
                  "text": "Duration in milliseconds."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "number"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "SetTimeout override, which will auto cancel the timeout during dispose."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "throttle": {
          "kind": "method",
          "signature": "throttle<T extends Function>(func: T, wait?: number, options?: {\n        leading?: boolean;\n        trailing?: boolean;\n    }): T | (() => void);",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "T | (() => void)",
            "description": [
              {
                "kind": "text",
                "text": "The new throttled function."
              }
            ]
          },
          "parameters": {
            "func": {
              "name": "func",
              "description": [
                {
                  "kind": "text",
                  "text": "The function to throttle."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "T"
            },
            "wait": {
              "name": "wait",
              "description": [
                {
                  "kind": "text",
                  "text": "The number of milliseconds to throttle executions to. Defaults to 0."
                }
              ],
              "isOptional": true,
              "isSpread": false,
              "type": "number"
            },
            "options": {
              "name": "options",
              "description": [
                {
                  "kind": "text",
                  "text": "The options object."
                }
              ],
              "isOptional": true,
              "isSpread": false,
              "type": "{\n        leading?: boolean;\n        trailing?: boolean;\n    }"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Creates a function that, when executed, will only call the func function at most once per every wait milliseconds. Provide an options object to indicate that func should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls to the throttled function will return the result of the last func call."
            },
            {
              "kind": "paragraph"
            },
            {
              "kind": "text",
              "text": "Note: If leading and trailing options are true func will be called on the trailing edge of the timeout only if the the throttled function is invoked more than once during the wait timeout."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        }
      }
    },
    "autobind": {
      "kind": "function",
      "signature": "export function autobind<T extends Function>(target: any, key: string, descriptor: TypedPropertyDescriptor<T>): {\n    configurable: boolean;\n    get(): T;\n    set(newValue: any): void;\n} | void;",
      "returnValue": {
        "type": "{\n    configurable: boolean;\n    get(): T;\n    set(newValue: any): void;\n} | void",
        "description": []
      },
      "parameters": {
        "target": {
          "name": "target",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "any"
        },
        "key": {
          "name": "key",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "string"
        },
        "descriptor": {
          "name": "descriptor",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "TypedPropertyDescriptor<T>"
        }
      },
      "deprecatedMessage": [
        {
          "kind": "text",
          "text": "This has been deprecated in favor of using arrow function properties"
        }
      ],
      "summary": [
        {
          "kind": "text",
          "text": "Autobind is a utility for binding methods in a class. This simplifies tagging methods as being \"bound\" to the this pointer so that they can be used in scenarios that simply require a function callback."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "AutoScroll": {
      "kind": "class",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "AutoScroll simply hooks up mouse events given a parent element, and scrolls the container up/down depending on how close the mouse is to the top/bottom of the container."
        },
        {
          "kind": "paragraph"
        },
        {
          "kind": "text",
          "text": "Once you don't want autoscroll any more, just dispose the helper and it will unhook events."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "__constructor": {
          "kind": "constructor",
          "signature": "constructor(element: HTMLElement);",
          "parameters": {
            "element": {
              "name": "element",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "HTMLElement"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Constructs a new instance of the "
            },
            {
              "kind": "api-link",
              "elements": [
                {
                  "kind": "text",
                  "text": "AutoScroll"
                }
              ],
              "target": {
                "scopeName": "@uifabric",
                "packageName": "utilities",
                "exportName": "AutoScroll",
                "memberName": ""
              }
            },
            {
              "kind": "text",
              "text": " class"
            }
          ],
          "remarks": []
        },
        "dispose": {
          "kind": "method",
          "signature": "dispose(): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {},
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        }
      }
    },
    "BaseComponent": {
      "kind": "class",
      "extends": "React.Component",
      "implements": "",
      "typeParameters": [
        "TProps extends IBaseProps = {}",
        "TState = {}"
      ],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "BaseComponent class, which provides basic helpers for all components."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "__constructor": {
          "kind": "constructor",
          "signature": "constructor(props: TProps, context?: any);",
          "parameters": {
            "props": {
              "name": "props",
              "description": [
                {
                  "kind": "text",
                  "text": "The props for the component."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "TProps"
            },
            "context": {
              "name": "context",
              "description": [
                {
                  "kind": "text",
                  "text": "The context for the component."
                }
              ],
              "isOptional": true,
              "isSpread": false,
              "type": "any"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "BaseComponent constructor"
            }
          ],
          "remarks": []
        },
        "_async": {
          "kind": "property",
          "signature": "protected readonly _async: Async;",
          "isOptional": false,
          "isReadOnly": true,
          "isStatic": false,
          "type": "Async",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Gets the async instance associated with the component, created on demand. The async instance gives subclasses a way to execute setTimeout/setInterval async calls safely, where the callbacks will be cleared/ignored automatically after unmounting. The helpers within the async object also preserve the this pointer so that you don't need to \"bind\" the callbacks."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "_disposables": {
          "kind": "property",
          "signature": "protected readonly _disposables: IDisposable[];",
          "isOptional": false,
          "isReadOnly": true,
          "isStatic": false,
          "type": "IDisposable[]",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Allows subclasses to push things to this._disposables to be auto disposed."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "_events": {
          "kind": "property",
          "signature": "protected readonly _events: EventGroup;",
          "isOptional": false,
          "isReadOnly": true,
          "isStatic": false,
          "type": "EventGroup",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Gets the event group instance assocaited with the component, created on demand. The event instance provides on/off methods for listening to DOM (or regular javascript object) events. The event callbacks will be automatically disconnected after unmounting. The helpers within the events object also preserve the this reference so that you don't need to \"bind\" the callbacks."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "_resolveRef": {
          "kind": "method",
          "signature": "protected _resolveRef(refName: string): (ref: React.ReactNode) => React.ReactNode;",
          "accessModifier": "protected",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "(ref: React.ReactNode) => React.ReactNode",
            "description": [
              {
                "kind": "text",
                "text": "A function instance keyed from the given refname."
              }
            ]
          },
          "parameters": {
            "refName": {
              "name": "refName",
              "description": [
                {
                  "kind": "text",
                  "text": "Name of the member to assign the ref to."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            }
          },
          "deprecatedMessage": [
            {
              "kind": "text",
              "text": "Use "
            },
            {
              "kind": "code",
              "text": "createRef",
              "highlighter": "plain"
            },
            {
              "kind": "text",
              "text": " from React.createRef."
            }
          ],
          "summary": [
            {
              "kind": "text",
              "text": "Helper to return a memoized ref resolver function."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "_skipComponentRefResolution": {
          "kind": "property",
          "signature": "protected _skipComponentRefResolution: boolean;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "boolean",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Controls whether the componentRef prop will be resolved by this component instance. If you are implementing a passthrough (higher-order component), you would set this to false and pass through the props to the inner component, allowing it to resolve the componentRef."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "_updateComponentRef": {
          "kind": "method",
          "signature": "protected _updateComponentRef(currentProps: IBaseProps, newProps?: IBaseProps): void;",
          "accessModifier": "protected",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "currentProps": {
              "name": "currentProps",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "IBaseProps"
            },
            "newProps": {
              "name": "newProps",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "IBaseProps"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Updates the componentRef (by calling it with \"this\" when necessary.)"
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "_warnConditionallyRequiredProps": {
          "kind": "method",
          "signature": "protected _warnConditionallyRequiredProps(requiredProps: string[], conditionalPropName: string, condition: boolean): void;",
          "accessModifier": "protected",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "requiredProps": {
              "name": "requiredProps",
              "description": [
                {
                  "kind": "text",
                  "text": "The name of the props that are required when the condition is met."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string[]"
            },
            "conditionalPropName": {
              "name": "conditionalPropName",
              "description": [
                {
                  "kind": "text",
                  "text": "The name of the prop that the condition is based on."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "condition": {
              "name": "condition",
              "description": [
                {
                  "kind": "text",
                  "text": "Whether the condition is met."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "boolean"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Warns when props are required if a condition is met."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "_warnDeprecations": {
          "kind": "method",
          "signature": "protected _warnDeprecations(deprecationMap: ISettingsMap<TProps>): void;",
          "accessModifier": "protected",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "deprecationMap": {
              "name": "deprecationMap",
              "description": [
                {
                  "kind": "text",
                  "text": "The map of deprecations, where key is the prop name and the value is either null or a replacement prop name."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "ISettingsMap<TProps>"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Warns when a deprecated props are being used."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "_warnMutuallyExclusive": {
          "kind": "method",
          "signature": "protected _warnMutuallyExclusive(mutuallyExclusiveMap: ISettingsMap<TProps>): void;",
          "accessModifier": "protected",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "mutuallyExclusiveMap": {
              "name": "mutuallyExclusiveMap",
              "description": [
                {
                  "kind": "text",
                  "text": "The map of mutually exclusive props."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "ISettingsMap<TProps>"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Warns when props which are mutually exclusive with each other are both used."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "className": {
          "kind": "property",
          "signature": "readonly className: string;",
          "isOptional": false,
          "isReadOnly": true,
          "isStatic": false,
          "type": "string",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Gets the object's class name."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "componentDidMount": {
          "kind": "method",
          "signature": "componentDidMount(): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {},
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "When the component has mounted, update the componentRef."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "componentDidUpdate": {
          "kind": "method",
          "signature": "componentDidUpdate(prevProps: TProps, prevState: TState): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "prevProps": {
              "name": "prevProps",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "TProps"
            },
            "prevState": {
              "name": "prevState",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "TState"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "When the component receives props, make sure the componentRef is updated."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "componentWillUnmount": {
          "kind": "method",
          "signature": "componentWillUnmount(): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {},
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "If we have disposables, dispose them automatically on unmount."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "onError": {
          "kind": "property",
          "signature": "static onError: (errorMessage?: string, ex?: any) => void;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": true,
          "type": "(errorMessage?: string, ex?: any) => void",
          "deprecatedMessage": [
            {
              "kind": "text",
              "text": "Use React's error boundaries instead."
            }
          ],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "calculatePrecision": {
      "kind": "function",
      "signature": "export function calculatePrecision(value: number | string): number;",
      "returnValue": {
        "type": "number",
        "description": []
      },
      "parameters": {
        "value": {
          "name": "value",
          "description": [
            {
              "kind": "text",
              "text": "the value to determine the precision of"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "number | string"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Calculates a number's precision based on the number of trailing zeros if the number does not have a decimal indicated by a negative precision. Otherwise, it calculates the number of digits after the decimal point indicated by a positive precision."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "classNamesFunction": {
      "kind": "function",
      "signature": "export function classNamesFunction<TStyleProps extends {}, TStyleSet extends IStyleSet<TStyleSet>>(): (getStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined, styleProps?: TStyleProps) => IProcessedStyleSet<TStyleSet>;",
      "returnValue": {
        "type": "(getStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined, styleProps?: TStyleProps) => IProcessedStyleSet<TStyleSet>",
        "description": []
      },
      "parameters": {},
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Creates a getClassNames function which calls getStyles given the props, and injects them into mergeStyleSets."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "createArray": {
      "kind": "function",
      "signature": "export function createArray<T>(size: number, getItem: (index: number) => T): T[];",
      "returnValue": {
        "type": "T[]",
        "description": []
      },
      "parameters": {
        "size": {
          "name": "size",
          "description": [
            {
              "kind": "text",
              "text": "Size of array."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "number"
        },
        "getItem": {
          "name": "getItem",
          "description": [
            {
              "kind": "text",
              "text": "Callback to populate given cell index."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "(index: number) => T"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Creates an array of a given size and helper method to populate."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "createRef": {
      "kind": "function",
      "signature": "export function createRef<T>(): RefObject<T>;",
      "returnValue": {
        "type": "RefObject<T>",
        "description": []
      },
      "parameters": {},
      "deprecatedMessage": [
        {
          "kind": "text",
          "text": "Use React.createRef. May be removed in 6 months (Jan '19)."
        }
      ],
      "summary": [],
      "remarks": [],
      "isBeta": false
    },
    "css": {
      "kind": "function",
      "signature": "export function css(...args: ICssInput[]): string;",
      "returnValue": {
        "type": "string",
        "description": []
      },
      "parameters": {
        "args": {
          "name": "args",
          "description": [],
          "isOptional": false,
          "isSpread": true,
          "type": "ICssInput[]"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Concatination helper, which can merge class names together. Skips over falsey values."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "customizable": {
      "kind": "function",
      "signature": "export function customizable(scope: string, fields: string[], concatStyles?: boolean): <P>(ComposedComponent: React.ComponentType<P>) => any;",
      "returnValue": {
        "type": "<P>(ComposedComponent: React.ComponentType<P>) => any",
        "description": []
      },
      "parameters": {
        "scope": {
          "name": "scope",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "string"
        },
        "fields": {
          "name": "fields",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "string[]"
        },
        "concatStyles": {
          "name": "concatStyles",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [],
      "remarks": [],
      "isBeta": false
    },
    "Customizations": {
      "kind": "class",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "applyScopedSettings": {
          "kind": "method",
          "signature": "static applyScopedSettings(scopeName: string, settings: ISettings): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "scopeName": {
              "name": "scopeName",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "settings": {
              "name": "settings",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "ISettings"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "applySettings": {
          "kind": "method",
          "signature": "static applySettings(settings: ISettings): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "settings": {
              "name": "settings",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "ISettings"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "getSettings": {
          "kind": "method",
          "signature": "static getSettings(properties: string[], scopeName?: string, localSettings?: ICustomizations): any;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "any",
            "description": []
          },
          "parameters": {
            "properties": {
              "name": "properties",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "string[]"
            },
            "scopeName": {
              "name": "scopeName",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "string"
            },
            "localSettings": {
              "name": "localSettings",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "ICustomizations"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "observe": {
          "kind": "method",
          "signature": "static observe(onChange: () => void): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "onChange": {
              "name": "onChange",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "() => void"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "reset": {
          "kind": "method",
          "signature": "static reset(): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {},
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "unobserve": {
          "kind": "method",
          "signature": "static unobserve(onChange: () => void): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "onChange": {
              "name": "onChange",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "() => void"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        }
      }
    },
    "Customizer": {
      "kind": "class",
      "extends": "BaseComponent",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "The Customizer component allows for default props to be mixed into components which are decorated with the customizable() decorator, or use the styled HOC. This enables injection scenarios like:"
        },
        {
          "kind": "paragraph"
        },
        {
          "kind": "text",
          "text": "1. render svg icons instead of the icon font within all buttons 2. inject a custom theme object into a component"
        },
        {
          "kind": "paragraph"
        },
        {
          "kind": "text",
          "text": "Props are provided via the settings prop which should be one of the following: - A json map which contains 1 or more name/value pairs representing injectable props. - A function that receives the current settings and returns the new ones that apply to the scope"
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "componentDidMount": {
          "kind": "method",
          "signature": "componentDidMount(): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {},
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "componentWillUnmount": {
          "kind": "method",
          "signature": "componentWillUnmount(): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {},
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "render": {
          "kind": "method",
          "signature": "render(): React.ReactElement<{}>;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "React.ReactElement<{}>",
            "description": []
          },
          "parameters": {},
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        }
      }
    },
    "DelayedRender": {
      "kind": "class",
      "extends": "React.Component",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Utility component for delaying the render of a child component after a given delay. This component requires a single child component; don't pass in many components. Wrap multiple components in a DIV if necessary."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "__constructor": {
          "kind": "constructor",
          "signature": "constructor(props: IDelayedRenderProps);",
          "parameters": {
            "props": {
              "name": "props",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "IDelayedRenderProps"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Constructs a new instance of the "
            },
            {
              "kind": "api-link",
              "elements": [
                {
                  "kind": "text",
                  "text": "DelayedRender"
                }
              ],
              "target": {
                "scopeName": "@uifabric",
                "packageName": "utilities",
                "exportName": "DelayedRender",
                "memberName": ""
              }
            },
            {
              "kind": "text",
              "text": " class"
            }
          ],
          "remarks": []
        },
        "componentDidMount": {
          "kind": "method",
          "signature": "componentDidMount(): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {},
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "componentWillUnmount": {
          "kind": "method",
          "signature": "componentWillUnmount(): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {},
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "defaultProps": {
          "kind": "property",
          "signature": "static defaultProps:",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": true,
          "type": "{\n        delay: number;\n    }",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "render": {
          "kind": "method",
          "signature": "render(): React.ReactElement<{}> | null;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "React.ReactElement<{}> | null",
            "description": []
          },
          "parameters": {},
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        }
      }
    },
    "disableBodyScroll": {
      "kind": "function",
      "signature": "export function disableBodyScroll(): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {},
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Disables the body scrolling."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "doesElementContainFocus": {
      "kind": "function",
      "signature": "export function doesElementContainFocus(element: HTMLElement): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": []
      },
      "parameters": {
        "element": {
          "name": "element",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Determines if an element, or any of its children, contain focus."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "elementContains": {
      "kind": "function",
      "signature": "export function elementContains(parent: HTMLElement | null, child: HTMLElement | null, allowVirtualParents?: boolean): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": []
      },
      "parameters": {
        "parent": {
          "name": "parent",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement | null"
        },
        "child": {
          "name": "child",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement | null"
        },
        "allowVirtualParents": {
          "name": "allowVirtualParents",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Determines whether or not a parent element contains a given child element. If "
        },
        {
          "kind": "code",
          "text": "allowVirtualParents",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " is true, this method may return "
        },
        {
          "kind": "code",
          "text": "true",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " if the child has the parent in its virtual element hierarchy."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "elementContainsAttribute": {
      "kind": "function",
      "signature": "export function elementContainsAttribute(element: HTMLElement, attribute: string): string | null;",
      "returnValue": {
        "type": "string | null",
        "description": [
          {
            "kind": "text",
            "text": "the value of the first instance found"
          }
        ]
      },
      "parameters": {
        "element": {
          "name": "element",
          "description": [
            {
              "kind": "text",
              "text": "element to start searching at"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "attribute": {
          "name": "attribute",
          "description": [
            {
              "kind": "text",
              "text": "the attribute to search for"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "string"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Determines if an element, or any of its ancestors, contain the given attribute"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "enableBodyScroll": {
      "kind": "function",
      "signature": "export function enableBodyScroll(): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {},
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Enables the body scrolling."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "EventGroup": {
      "kind": "class",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "An instance of EventGroup allows anything with a handle to it to trigger events on it. If the target is an HTMLElement, the event will be attached to the element and can be triggered as usual (like clicking for onclick). The event can be triggered by calling EventGroup.raise() here. If the target is an HTMLElement, the event gets raised and is handled by the browser. Otherwise, it gets handled here in EventGroup, and the handler is called in the context of the parent (which is passed in in the constructor)."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "__constructor": {
          "kind": "constructor",
          "signature": "constructor(parent: any);",
          "parameters": {
            "parent": {
              "name": "parent",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "any"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "parent: the context in which events attached to non-HTMLElements are called"
            }
          ],
          "remarks": []
        },
        "declare": {
          "kind": "method",
          "signature": "declare(event: string | string[]): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "event": {
              "name": "event",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "string | string[]"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Declare an event as being supported by this instance of EventGroup."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "dispose": {
          "kind": "method",
          "signature": "dispose(): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {},
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "isDeclared": {
          "kind": "method",
          "signature": "static isDeclared(target: any, eventName: string): boolean;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "boolean",
            "description": []
          },
          "parameters": {
            "target": {
              "name": "target",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "any"
            },
            "eventName": {
              "name": "eventName",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Check to see if the target has declared support of the given event."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "isObserved": {
          "kind": "method",
          "signature": "static isObserved(target: any, eventName: string): boolean;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "boolean",
            "description": []
          },
          "parameters": {
            "target": {
              "name": "target",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "any"
            },
            "eventName": {
              "name": "eventName",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "off": {
          "kind": "method",
          "signature": "off(target?: any, eventName?: string, callback?: (args?: any) => void, options?: boolean | AddEventListenerOptions): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "target": {
              "name": "target",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "any"
            },
            "eventName": {
              "name": "eventName",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "string"
            },
            "callback": {
              "name": "callback",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "(args?: any) => void"
            },
            "options": {
              "name": "options",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "boolean | AddEventListenerOptions"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "on": {
          "kind": "method",
          "signature": "on(target: any, eventName: string, callback: (args?: any) => void, options?: boolean | AddEventListenerOptions): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "target": {
              "name": "target",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "any"
            },
            "eventName": {
              "name": "eventName",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "callback": {
              "name": "callback",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "(args?: any) => void"
            },
            "options": {
              "name": "options",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "boolean | AddEventListenerOptions"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "On the target, attach an event whose handler will be called in the context of the parent of this instance of EventGroup."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "onAll": {
          "kind": "method",
          "signature": "onAll(target: any, events: {\n        [key: string]: (args?: any) => void;\n    }, useCapture?: boolean): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "target": {
              "name": "target",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "any"
            },
            "events": {
              "name": "events",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "{\n        [key: string]: (args?: any) => void;\n    }"
            },
            "useCapture": {
              "name": "useCapture",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "boolean"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "On the target, attach a set of events, where the events object is a name to function mapping."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "raise": {
          "kind": "method",
          "signature": "static raise(target: any, eventName: string, eventArgs?: any, bubbleEvent?: boolean): boolean | undefined;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "boolean | undefined",
            "description": []
          },
          "parameters": {
            "target": {
              "name": "target",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "any"
            },
            "eventName": {
              "name": "eventName",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "eventArgs": {
              "name": "eventArgs",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "any"
            },
            "bubbleEvent": {
              "name": "bubbleEvent",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "boolean"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "For IE8, bubbleEvent is ignored here and must be dealt with by the handler. Events raised here by default have bubbling set to false and cancelable set to true. This applies also to built-in events being raised manually here on HTMLElements, which may lead to unexpected behavior if it differs from the defaults."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "stopPropagation": {
          "kind": "method",
          "signature": "static stopPropagation(event: any): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "event": {
              "name": "event",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "any"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        }
      }
    },
    "extendComponent": {
      "kind": "function",
      "signature": "export function extendComponent<T extends React.Component>(parent: T, methods: {\n    [key in keyof T]?: T[key];\n}): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "parent": {
          "name": "parent",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "T"
        },
        "methods": {
          "name": "methods",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "{\n    [key in keyof T]?: T[key];\n}"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Extends a component's lifetime methods by appending new functions to the existing lifetime functions."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "FabricPerformance": {
      "kind": "class",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Performance helper class for measuring things."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "measure": {
          "kind": "method",
          "signature": "static measure(name: string, func: () => void): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "name": {
              "name": "name",
              "description": [
                {
                  "kind": "text",
                  "text": "The name of this measurement"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "func": {
              "name": "func",
              "description": [
                {
                  "kind": "text",
                  "text": "The logic to be measured for execution time"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "() => void"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Measures execution time of the given syncronous function. If the same logic is executed multiple times, each individual measurement will be collected as well the overall numbers."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "reset": {
          "kind": "method",
          "signature": "static reset(): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {},
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "setPeriodicReset": {
          "kind": "method",
          "signature": "static setPeriodicReset(): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {},
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "summary": {
          "kind": "property",
          "signature": "static summary: IPerfSummary;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": true,
          "type": "IPerfSummary",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "filteredAssign": {
      "kind": "function",
      "signature": "export function filteredAssign(isAllowed: (propName: string) => boolean, target: any, ...args: any[]): any;",
      "returnValue": {
        "type": "any",
        "description": [
          {
            "kind": "text",
            "text": "Resulting merged target."
          }
        ]
      },
      "parameters": {
        "isAllowed": {
          "name": "isAllowed",
          "description": [
            {
              "kind": "text",
              "text": "Callback to determine if the given propName is allowed in the result."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "(propName: string) => boolean"
        },
        "target": {
          "name": "target",
          "description": [
            {
              "kind": "text",
              "text": "Target object to merge following object arguments into."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "any"
        },
        "args": {
          "name": "args",
          "description": [
            {
              "kind": "text",
              "text": "One or more objects that will be mixed into the target in the order they are provided."
            }
          ],
          "isOptional": false,
          "isSpread": true,
          "type": "any[]"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Makes a resulting merge of a bunch of objects, but allows a filter function to be passed in to filter the resulting merges. This allows for scenarios where you want to merge \"everything except that one thing\" or \"properties that start with data-\". Note that this will shallow merge; it will not create new cloned values for target members."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "find": {
      "kind": "function",
      "signature": "export function find<T>(array: T[], cb: (item: T, index: number) => boolean): T | undefined;",
      "returnValue": {
        "type": "T | undefined",
        "description": []
      },
      "parameters": {
        "array": {
          "name": "array",
          "description": [
            {
              "kind": "text",
              "text": "Array to search"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "T[]"
        },
        "cb": {
          "name": "cb",
          "description": [
            {
              "kind": "text",
              "text": "Callback which returns true on matches"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "(item: T, index: number) => boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Helper to find the first item within an array that satisfies the callback."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "findElementRecursive": {
      "kind": "function",
      "signature": "export function findElementRecursive(element: HTMLElement | null, matchFunction: (element: HTMLElement) => boolean): HTMLElement | null;",
      "returnValue": {
        "type": "HTMLElement | null",
        "description": [
          {
            "kind": "text",
            "text": "the matched element or null no match was found"
          }
        ]
      },
      "parameters": {
        "element": {
          "name": "element",
          "description": [
            {
              "kind": "text",
              "text": "element to start searching at"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement | null"
        },
        "matchFunction": {
          "name": "matchFunction",
          "description": [
            {
              "kind": "text",
              "text": "the function that determines if the element is a match"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "(element: HTMLElement) => boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Finds the first parent element where the matchFunction returns true"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "findIndex": {
      "kind": "function",
      "signature": "export function findIndex<T>(array: T[], cb: (item: T, index: number) => boolean): number;",
      "returnValue": {
        "type": "number",
        "description": []
      },
      "parameters": {
        "array": {
          "name": "array",
          "description": [
            {
              "kind": "text",
              "text": "Array to search."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "T[]"
        },
        "cb": {
          "name": "cb",
          "description": [
            {
              "kind": "text",
              "text": "Callback which returns true on matches."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "(item: T, index: number) => boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Helper to find the index of an item within an array, using a callback to determine the match."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "findScrollableParent": {
      "kind": "function",
      "signature": "export function findScrollableParent(startingElement: HTMLElement | null): HTMLElement | null;",
      "returnValue": {
        "type": "HTMLElement | null",
        "description": []
      },
      "parameters": {
        "startingElement": {
          "name": "startingElement",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement | null"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Traverses up the DOM for the element with the data-is-scrollable=true attribute, or returns document.body."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "fitContentToBounds": {
      "kind": "function",
      "signature": "export function fitContentToBounds(options: IFitContentToBoundsOptions): ISize;",
      "returnValue": {
        "type": "ISize",
        "description": []
      },
      "parameters": {
        "options": {
          "name": "options",
          "description": [
            {
              "kind": "text",
              "text": "the options for the bounds fit operation"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "IFitContentToBoundsOptions"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Produces a proportionally-scaled version of an input content size when fit to a bounding size. Given a "
        },
        {
          "kind": "code",
          "text": "contentSize",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " and a "
        },
        {
          "kind": "code",
          "text": "boundsSize",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": ", this function scales "
        },
        {
          "kind": "code",
          "text": "contentSize",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " proportionally using either "
        },
        {
          "kind": "code",
          "text": "contain",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " or "
        },
        {
          "kind": "code",
          "text": "cover",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " fit behaviors. Use this function to pre-calculate the layout for the CSS "
        },
        {
          "kind": "code",
          "text": "object-fit",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " and "
        },
        {
          "kind": "code",
          "text": "background-fit",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " behaviors. With "
        },
        {
          "kind": "code",
          "text": "contain",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": ", the output size must be the largest it can be while completely within the "
        },
        {
          "kind": "code",
          "text": "boundsSize",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": ". With "
        },
        {
          "kind": "code",
          "text": "cover",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": ", the output size must be the smallest it can be while completely around the "
        },
        {
          "kind": "code",
          "text": "boundsSize",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": ". By default, there is a "
        },
        {
          "kind": "code",
          "text": "maxScale",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " value of 1, which prevents the "
        },
        {
          "kind": "code",
          "text": "contentSize",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " from being scaled larger."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "flatten": {
      "kind": "function",
      "signature": "export function flatten<T>(array: (T | T[])[]): T[];",
      "returnValue": {
        "type": "T[]",
        "description": []
      },
      "parameters": {
        "array": {
          "name": "array",
          "description": [
            {
              "kind": "text",
              "text": "The array where each element can optionally also be an array"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "(T | T[])[]"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Given an array where each element is of type T or T[], flatten it into an array of T"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "focusAsync": {
      "kind": "function",
      "signature": "export function focusAsync(element: HTMLElement | {\n    focus: () => void;\n} | undefined | null): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "element": {
          "name": "element",
          "description": [
            {
              "kind": "text",
              "text": "The element to focus"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement | {\n    focus: () => void;\n} | undefined | null"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Sets focus to an element asynchronously. The focus will be set at the next browser repaint, meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame, only the latest called focusAsync element will actually be focused"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "focusFirstChild": {
      "kind": "function",
      "signature": "export function focusFirstChild(rootElement: HTMLElement): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": [
          {
            "kind": "text",
            "text": "True if focus was set, false if it was not."
          }
        ]
      },
      "parameters": {
        "rootElement": {
          "name": "rootElement",
          "description": [
            {
              "kind": "text",
              "text": "Element to start the search for a focusable child."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Attempts to focus the first focusable element that is a child or child's child of the rootElement."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "format": {
      "kind": "function",
      "signature": "export function format(s: string, ...values: any[]): string;",
      "returnValue": {
        "type": "string",
        "description": []
      },
      "parameters": {
        "s": {
          "name": "s",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "string"
        },
        "values": {
          "name": "values",
          "description": [],
          "isOptional": false,
          "isSpread": true,
          "type": "any[]"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "String format method, used for scenarios where at runtime you need to evaluate a formatted string given a tokenized string. This usually only is needed in localization scenarios."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getChildren": {
      "kind": "function",
      "signature": "export function getChildren(parent: HTMLElement, allowVirtualChildren?: boolean): HTMLElement[];",
      "returnValue": {
        "type": "HTMLElement[]",
        "description": []
      },
      "parameters": {
        "parent": {
          "name": "parent",
          "description": [
            {
              "kind": "text",
              "text": "The element to get the children of."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "allowVirtualChildren": {
          "name": "allowVirtualChildren",
          "description": [
            {
              "kind": "text",
              "text": "true if the method should enumerate virtual child elements."
            }
          ],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Gets the elements which are child elements of the given element. If "
        },
        {
          "kind": "code",
          "text": "allowVirtualChildren",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " is "
        },
        {
          "kind": "code",
          "text": "true",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": ", this method enumerates virtual child elements after the original children."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getDistanceBetweenPoints": {
      "kind": "function",
      "signature": "export function getDistanceBetweenPoints(point1: IPoint, point2: IPoint): number;",
      "returnValue": {
        "type": "number",
        "description": []
      },
      "parameters": {
        "point1": {
          "name": "point1",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "IPoint"
        },
        "point2": {
          "name": "point2",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "IPoint"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Determines the distance between two points."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getDocument": {
      "kind": "function",
      "signature": "export function getDocument(rootElement?: HTMLElement | null): Document | undefined;",
      "returnValue": {
        "type": "Document | undefined",
        "description": []
      },
      "parameters": {
        "rootElement": {
          "name": "rootElement",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "HTMLElement | null"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Helper to get the document object. Note that in popup window cases, document might be the wrong document, which is why we look at ownerDocument for the truth. Also note that the SSR flag is used to test ssr scenarios even if document is defined (from JSDOM for example.)"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getElementIndexPath": {
      "kind": "function",
      "signature": "export function getElementIndexPath(fromElement: HTMLElement, toElement: HTMLElement): number[];",
      "returnValue": {
        "type": "number[]",
        "description": []
      },
      "parameters": {
        "fromElement": {
          "name": "fromElement",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "toElement": {
          "name": "toElement",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Finds the element index path from a parent element to a child element."
        },
        {
          "kind": "paragraph"
        },
        {
          "kind": "text",
          "text": "If you had this node structure: \"A has children [B, C] and C has child D\", the index path from A to D would be [1, 0], or "
        },
        {
          "kind": "code",
          "text": "parent.chidren[1].children[0]",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": "."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getFirstFocusable": {
      "kind": "function",
      "signature": "export function getFirstFocusable(rootElement: HTMLElement, currentElement: HTMLElement, includeElementsInFocusZones?: boolean): HTMLElement | null;",
      "returnValue": {
        "type": "HTMLElement | null",
        "description": []
      },
      "parameters": {
        "rootElement": {
          "name": "rootElement",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "currentElement": {
          "name": "currentElement",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "includeElementsInFocusZones": {
          "name": "includeElementsInFocusZones",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Gets the first focusable element."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getFirstTabbable": {
      "kind": "function",
      "signature": "export function getFirstTabbable(rootElement: HTMLElement, currentElement: HTMLElement, includeElementsInFocusZones?: boolean, checkNode?: boolean): HTMLElement | null;",
      "returnValue": {
        "type": "HTMLElement | null",
        "description": []
      },
      "parameters": {
        "rootElement": {
          "name": "rootElement",
          "description": [
            {
              "kind": "text",
              "text": "The parent element to search beneath."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "currentElement": {
          "name": "currentElement",
          "description": [
            {
              "kind": "text",
              "text": "The descendant of rootElement to start the search at. This element is the first one checked, and iteration continues forward. Typical use passes rootElement.firstChild."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "includeElementsInFocusZones": {
          "name": "includeElementsInFocusZones",
          "description": [
            {
              "kind": "text",
              "text": "true if traversal should go into FocusZone descendants."
            }
          ],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        },
        "checkNode": {
          "name": "checkNode",
          "description": [
            {
              "kind": "text",
              "text": "Include currentElement in search when true. Defaults to true."
            }
          ],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Gets the first tabbable element. The difference between focusable and tabbable is that tabbable elements are focusable elements that also have tabIndex != -1."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getFocusableByIndexPath": {
      "kind": "function",
      "signature": "export function getFocusableByIndexPath(parent: HTMLElement, path: number[]): HTMLElement | undefined;",
      "returnValue": {
        "type": "HTMLElement | undefined",
        "description": []
      },
      "parameters": {
        "parent": {
          "name": "parent",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "path": {
          "name": "path",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "number[]"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Finds the closest focusable element via an index path from a parent. See "
        },
        {
          "kind": "code",
          "text": "getElementIndexPath",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " for getting an index path from an element to a child."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getId": {
      "kind": "function",
      "signature": "export function getId(prefix?: string): string;",
      "returnValue": {
        "type": "string",
        "description": []
      },
      "parameters": {
        "prefix": {
          "name": "prefix",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "string"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Generates a unique id in the global scope (this spans across duplicate copies of the same library.)"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getInitials": {
      "kind": "function",
      "signature": "export function getInitials(displayName: string | undefined | null, isRtl: boolean, allowPhoneInitials?: boolean): string;",
      "returnValue": {
        "type": "string",
        "description": []
      },
      "parameters": {
        "displayName": {
          "name": "displayName",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "string | undefined | null"
        },
        "isRtl": {
          "name": "isRtl",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "boolean"
        },
        "allowPhoneInitials": {
          "name": "allowPhoneInitials",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Get (up to 2 characters) initials based on display name of the persona."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getLanguage": {
      "kind": "function",
      "signature": "export function getLanguage(): string | null;",
      "returnValue": {
        "type": "string | null",
        "description": []
      },
      "parameters": {},
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Gets the rtl state of the page (returns true if in rtl.)"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getLastFocusable": {
      "kind": "function",
      "signature": "export function getLastFocusable(rootElement: HTMLElement, currentElement: HTMLElement, includeElementsInFocusZones?: boolean): HTMLElement | null;",
      "returnValue": {
        "type": "HTMLElement | null",
        "description": []
      },
      "parameters": {
        "rootElement": {
          "name": "rootElement",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "currentElement": {
          "name": "currentElement",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "includeElementsInFocusZones": {
          "name": "includeElementsInFocusZones",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Gets the last focusable element."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getLastTabbable": {
      "kind": "function",
      "signature": "export function getLastTabbable(rootElement: HTMLElement, currentElement: HTMLElement, includeElementsInFocusZones?: boolean, checkNode?: boolean): HTMLElement | null;",
      "returnValue": {
        "type": "HTMLElement | null",
        "description": []
      },
      "parameters": {
        "rootElement": {
          "name": "rootElement",
          "description": [
            {
              "kind": "text",
              "text": "The parent element to search beneath."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "currentElement": {
          "name": "currentElement",
          "description": [
            {
              "kind": "text",
              "text": "The descendant of rootElement to start the search at. This element is the first one checked, and iteration continues in reverse. Typical use passes rootElement.lastChild."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "includeElementsInFocusZones": {
          "name": "includeElementsInFocusZones",
          "description": [
            {
              "kind": "text",
              "text": "true if traversal should go into FocusZone descendants."
            }
          ],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        },
        "checkNode": {
          "name": "checkNode",
          "description": [
            {
              "kind": "text",
              "text": "Include currentElement in search when true. Defaults to true."
            }
          ],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Gets the last tabbable element. The difference between focusable and tabbable is that tabbable elements are focusable elements that also have tabIndex != -1."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getNativeProps": {
      "kind": "function",
      "signature": "export function getNativeProps<T>(props: {}, allowedPropNames: string[], excludedPropNames?: string[]): T;",
      "returnValue": {
        "type": "T",
        "description": [
          {
            "kind": "text",
            "text": "The filtered props"
          }
        ]
      },
      "parameters": {
        "props": {
          "name": "props",
          "description": [
            {
              "kind": "text",
              "text": "The unfiltered input props"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "{}"
        },
        "allowedPropNames": {
          "name": "allowedPropNames",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "string[]"
        },
        "excludedPropNames": {
          "name": "excludedPropNames",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "string[]"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Gets native supported props for an html element provided the allowance set. Use one of the property sets defined (divProperties, buttonPropertes, etc) to filter out supported properties from a given props set. Note that all data- and aria- prefixed attributes will be allowed. NOTE: getNativeProps should always be applied first when adding props to a react component. The non-native props should be applied second. This will prevent getNativeProps from overriding your custom props. For example, if props passed to getNativeProps has an onClick function and getNativeProps is added to the component after an onClick function is added, then the getNativeProps onClick will override it."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getNextElement": {
      "kind": "function",
      "signature": "export function getNextElement(rootElement: HTMLElement, currentElement: HTMLElement | null, checkNode?: boolean, suppressParentTraversal?: boolean, suppressChildTraversal?: boolean, includeElementsInFocusZones?: boolean, allowFocusRoot?: boolean, tabbable?: boolean): HTMLElement | null;",
      "returnValue": {
        "type": "HTMLElement | null",
        "description": []
      },
      "parameters": {
        "rootElement": {
          "name": "rootElement",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "currentElement": {
          "name": "currentElement",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement | null"
        },
        "checkNode": {
          "name": "checkNode",
          "description": [
            {
              "kind": "text",
              "text": "Include currentElement in search when true."
            }
          ],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        },
        "suppressParentTraversal": {
          "name": "suppressParentTraversal",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        },
        "suppressChildTraversal": {
          "name": "suppressChildTraversal",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        },
        "includeElementsInFocusZones": {
          "name": "includeElementsInFocusZones",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        },
        "allowFocusRoot": {
          "name": "allowFocusRoot",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        },
        "tabbable": {
          "name": "tabbable",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Traverse to find the next focusable element. If tabbable is true, the element must have tabIndex != -1."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getParent": {
      "kind": "function",
      "signature": "export function getParent(child: HTMLElement, allowVirtualParents?: boolean): HTMLElement | null;",
      "returnValue": {
        "type": "HTMLElement | null",
        "description": []
      },
      "parameters": {
        "child": {
          "name": "child",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "allowVirtualParents": {
          "name": "allowVirtualParents",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Gets the element which is the parent of a given element. If "
        },
        {
          "kind": "code",
          "text": "allowVirtuaParents",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " is "
        },
        {
          "kind": "code",
          "text": "true",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": ", this method prefers the virtual parent over real DOM parent when present."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getPreviousElement": {
      "kind": "function",
      "signature": "export function getPreviousElement(rootElement: HTMLElement, currentElement: HTMLElement | null, checkNode?: boolean, suppressParentTraversal?: boolean, traverseChildren?: boolean, includeElementsInFocusZones?: boolean, allowFocusRoot?: boolean, tabbable?: boolean): HTMLElement | null;",
      "returnValue": {
        "type": "HTMLElement | null",
        "description": []
      },
      "parameters": {
        "rootElement": {
          "name": "rootElement",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "currentElement": {
          "name": "currentElement",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement | null"
        },
        "checkNode": {
          "name": "checkNode",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        },
        "suppressParentTraversal": {
          "name": "suppressParentTraversal",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        },
        "traverseChildren": {
          "name": "traverseChildren",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        },
        "includeElementsInFocusZones": {
          "name": "includeElementsInFocusZones",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        },
        "allowFocusRoot": {
          "name": "allowFocusRoot",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        },
        "tabbable": {
          "name": "tabbable",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Traverse to find the previous element. If tabbable is true, the element must have tabIndex != -1."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getRect": {
      "kind": "function",
      "signature": "export function getRect(element: HTMLElement | Window | null): IRectangle | undefined;",
      "returnValue": {
        "type": "IRectangle | undefined",
        "description": []
      },
      "parameters": {
        "element": {
          "name": "element",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement | Window | null"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Helper to get bounding client rect. Passing in window will get the window size."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getResourceUrl": {
      "kind": "function",
      "signature": "export function getResourceUrl(url: string): string;",
      "returnValue": {
        "type": "string",
        "description": []
      },
      "parameters": {
        "url": {
          "name": "url",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "string"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Sets the current base url used for fetching images."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getRTL": {
      "kind": "function",
      "signature": "export function getRTL(): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": []
      },
      "parameters": {},
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Gets the rtl state of the page (returns true if in rtl.)"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getRTLSafeKeyCode": {
      "kind": "function",
      "signature": "export function getRTLSafeKeyCode(key: number): number;",
      "returnValue": {
        "type": "number",
        "description": []
      },
      "parameters": {
        "key": {
          "name": "key",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "number"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Returns the given key, but flips right/left arrows if necessary."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getScrollbarWidth": {
      "kind": "function",
      "signature": "export function getScrollbarWidth(): number;",
      "returnValue": {
        "type": "number",
        "description": []
      },
      "parameters": {},
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Calculates the width of a scrollbar for the browser/os."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getVirtualParent": {
      "kind": "function",
      "signature": "export function getVirtualParent(child: HTMLElement): HTMLElement | undefined;",
      "returnValue": {
        "type": "HTMLElement | undefined",
        "description": []
      },
      "parameters": {
        "child": {
          "name": "child",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Gets the virtual parent given the child element, if it exists."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "getWindow": {
      "kind": "function",
      "signature": "export function getWindow(rootElement?: Element | null): Window | undefined;",
      "returnValue": {
        "type": "Window | undefined",
        "description": []
      },
      "parameters": {
        "rootElement": {
          "name": "rootElement",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "Element | null"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Helper to get the window object. Note that in popup scenarios the window object may not be the window use ex"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "GlobalSettings": {
      "kind": "class",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Global settings helper, which stores settings in the global (window) namespace. If window is not provided, it will store settings in module scope. Provides a way to observe changes as well when their values change."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "addChangeListener": {
          "kind": "method",
          "signature": "static addChangeListener(cb: IChangeEventCallback): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "cb": {
              "name": "cb",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "IChangeEventCallback"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "getValue": {
          "kind": "method",
          "signature": "static getValue<T>(key: string, defaultValue?: T | (() => T)): T;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "T",
            "description": []
          },
          "parameters": {
            "key": {
              "name": "key",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "defaultValue": {
              "name": "defaultValue",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "T | (() => T)"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "removeChangeListener": {
          "kind": "method",
          "signature": "static removeChangeListener(cb: IChangeEventCallback): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "cb": {
              "name": "cb",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "IChangeEventCallback"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "setValue": {
          "kind": "method",
          "signature": "static setValue<T>(key: string, value: T): T;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": true,
          "returnValue": {
            "type": "T",
            "description": []
          },
          "parameters": {
            "key": {
              "name": "key",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "value": {
              "name": "value",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "T"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        }
      }
    },
    "hasHorizontalOverflow": {
      "kind": "function",
      "signature": "export function hasHorizontalOverflow(element: HTMLElement): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": [
          {
            "kind": "text",
            "text": "True if element's content overflows"
          }
        ]
      },
      "parameters": {
        "element": {
          "name": "element",
          "description": [
            {
              "kind": "text",
              "text": "Element to check for overflow"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Detects whether an element's content has horizontal overflow"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "hasOverflow": {
      "kind": "function",
      "signature": "export function hasOverflow(element: HTMLElement): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": [
          {
            "kind": "text",
            "text": "True if element's content overflows"
          }
        ]
      },
      "parameters": {
        "element": {
          "name": "element",
          "description": [
            {
              "kind": "text",
              "text": "Element to check for overflow"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Detects whether an element's content has overflow in any direction"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "hasVerticalOverflow": {
      "kind": "function",
      "signature": "export function hasVerticalOverflow(element: HTMLElement): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": [
          {
            "kind": "text",
            "text": "True if element's content overflows"
          }
        ]
      },
      "parameters": {
        "element": {
          "name": "element",
          "description": [
            {
              "kind": "text",
              "text": "Element to check for overflow"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Detects whether an element's content has vertical overflow"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "hoistMethods": {
      "kind": "function",
      "signature": "export function hoistMethods(destination: any, source: any, exclusions?: string[]): string[];",
      "returnValue": {
        "type": "string[]",
        "description": [
          {
            "kind": "text",
            "text": "An array of names of methods that were hoisted."
          }
        ]
      },
      "parameters": {
        "destination": {
          "name": "destination",
          "description": [
            {
              "kind": "text",
              "text": "The instance of the object to hoist the methods onto."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "any"
        },
        "source": {
          "name": "source",
          "description": [
            {
              "kind": "text",
              "text": "The instance of the object where the methods are hoisted from."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "any"
        },
        "exclusions": {
          "name": "exclusions",
          "description": [
            {
              "kind": "text",
              "text": "(Optional) What methods to exclude from being hoisted."
            }
          ],
          "isOptional": true,
          "isSpread": false,
          "type": "string[]"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Allows you to hoist methods, except those in an exclusion set from a source object into a destination object."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "hoistStatics": {
      "kind": "function",
      "signature": "export function hoistStatics<TSource, TDest>(source: TSource, dest: TDest): TDest;",
      "returnValue": {
        "type": "TDest",
        "description": [
          {
            "kind": "text",
            "text": "The dest object with methods added"
          }
        ]
      },
      "parameters": {
        "source": {
          "name": "source",
          "description": [
            {
              "kind": "text",
              "text": "The object where the methods are hoisted from."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "TSource"
        },
        "dest": {
          "name": "dest",
          "description": [
            {
              "kind": "text",
              "text": "The object to hoist the methods onto."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "TDest"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Allows you to hoist static functions in components. Created for the purpose of fixing broken static functions in classes that utilize decorators."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "IAsAsyncOptions": {
      "kind": "interface",
      "extends": "",
      "implements": "",
      "typeParameters": [
        "TProps"
      ],
      "deprecatedMessage": [],
      "summary": [],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "load": {
          "kind": "property",
          "signature": "load: () => Promise<React.ReactType<TProps>>;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "() => Promise<React.ReactType<TProps>>",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Callback which returns a promise resolving an object which exports the component."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "onError": {
          "kind": "property",
          "signature": "onError?: (error: Error) => void;",
          "isOptional": true,
          "isReadOnly": false,
          "isStatic": false,
          "type": "(error: Error) => void",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Callback when async loading fails."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "onLoad": {
          "kind": "property",
          "signature": "onLoad?: () => void;",
          "isOptional": true,
          "isReadOnly": false,
          "isStatic": false,
          "type": "() => void",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Callback executed when async loading is complete."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "IBaseProps": {
      "kind": "interface",
      "extends": "",
      "implements": "",
      "typeParameters": [
        "T = any"
      ],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "BaseProps interface."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "componentRef": {
          "kind": "property",
          "signature": "componentRef?: IRefObject<T>;",
          "isOptional": true,
          "isReadOnly": false,
          "isStatic": false,
          "type": "IRefObject<T>",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "IChangeDescription": {
      "kind": "interface",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Change description used for change callbacks in GlobalSettings."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "key": {
          "kind": "property",
          "signature": "key: string;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "string",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "oldValue": {
          "kind": "property",
          "signature": "oldValue: any;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "any",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "value": {
          "kind": "property",
          "signature": "value: any;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "any",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "IChangeEventCallback": {
      "kind": "interface",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Change event callback."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "__call": {
          "kind": "method",
          "signature": "(changeDescription?: IChangeDescription): void;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "changeDescription": {
              "name": "changeDescription",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "IChangeDescription"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "__id__": {
          "kind": "property",
          "signature": "__id__?: string;",
          "isOptional": true,
          "isReadOnly": false,
          "isStatic": false,
          "type": "string",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "ICustomizableProps": {
      "kind": "interface",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "fields": {
          "kind": "property",
          "signature": "fields?: string[];",
          "isOptional": true,
          "isReadOnly": false,
          "isStatic": false,
          "type": "string[]",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "List of fields which can be customized."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "scope": {
          "kind": "property",
          "signature": "scope: string;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "string",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Name of scope, which can be targeted using the Customizer."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "ICustomizations": {
      "kind": "interface",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "inCustomizerContext": {
          "kind": "property",
          "signature": "inCustomizerContext?: boolean;",
          "isOptional": true,
          "isReadOnly": false,
          "isStatic": false,
          "type": "boolean",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "scopedSettings": {
          "kind": "property",
          "signature": "scopedSettings:",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "{\n        [key: string]: ISettings;\n    }",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "settings": {
          "kind": "property",
          "signature": "settings: ISettings;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "ISettings",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "ICustomizerContext": {
      "kind": "interface",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "customizations": {
          "kind": "property",
          "signature": "customizations: ICustomizations;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "ICustomizations",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "IDelayedRenderProps": {
      "kind": "interface",
      "extends": "React.Props",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "DelayedRender component props."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "delay": {
          "kind": "property",
          "signature": "delay?: number;",
          "isOptional": true,
          "isReadOnly": false,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Number of milliseconds to delay rendering children."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "IDisposable": {
      "kind": "interface",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Disposable interface."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "dispose": {
          "kind": "property",
          "signature": "dispose: () => void;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "() => void",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "IFitContentToBoundsOptions": {
      "kind": "interface",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Options for fitting content sizes into bounding sizes."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "boundsSize": {
          "kind": "property",
          "signature": "boundsSize: ISize;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "ISize",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "The size of the bounds."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "contentSize": {
          "kind": "property",
          "signature": "contentSize: ISize;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "ISize",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "The size of the content to fit to the bounds. The output will be proportional to this value."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "maxScale": {
          "kind": "property",
          "signature": "maxScale?: number;",
          "isOptional": true,
          "isReadOnly": false,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "An optional maximum scale factor to apply. The default is 1. Use Infinity for an unbounded resize."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "mode": {
          "kind": "property",
          "signature": "mode: FitMode;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "FitMode",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "The fit mode to apply, either 'contain' or 'cover'."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "initializeComponentRef": {
      "kind": "function",
      "signature": "export function initializeComponentRef<TProps extends IBaseProps, TState>(obj: React.Component<TProps, TState>): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "obj": {
          "name": "obj",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "React.Component<TProps, TState>"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Helper to manage componentRef resolution. Internally appends logic to lifetime methods to resolve componentRef to the passed in object."
        },
        {
          "kind": "paragraph"
        },
        {
          "kind": "text",
          "text": "Usage: call initializeComponentRef(this) in the constructor,"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "initializeFocusRects": {
      "kind": "function",
      "signature": "export function initializeFocusRects(window?: Window): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "window": {
          "name": "window",
          "description": [
            {
              "kind": "text",
              "text": "the window used to add the event listeners"
            }
          ],
          "isOptional": true,
          "isSpread": false,
          "type": "Window"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Initializes the logic which:"
        },
        {
          "kind": "paragraph"
        },
        {
          "kind": "text",
          "text": "1. Subscribes keydown and mousedown events. (It will only do it once per window, so it's safe to call this method multiple times.) 2. When the user presses directional keyboard keys, adds the 'ms-Fabric--isFocusVisible' classname to the document body. 3. When the user clicks a mouse button, we remove the classname if it exists."
        },
        {
          "kind": "paragraph"
        },
        {
          "kind": "text",
          "text": "This logic allows components on the page to conditionally render focus treatments only if the global classname exists, which simplifies logic overall."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "IPoint": {
      "kind": "interface",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Point interface."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "x": {
          "kind": "property",
          "signature": "x: number;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "y": {
          "kind": "property",
          "signature": "y: number;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "IPropsWithStyles": {
      "kind": "interface",
      "extends": "",
      "implements": "",
      "typeParameters": [
        "TStyleProps",
        "TStyleSet extends IStyleSet<TStyleSet>"
      ],
      "deprecatedMessage": [],
      "summary": [],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "styles": {
          "kind": "property",
          "signature": "styles?: IStyleFunctionOrObject<TStyleProps, TStyleSet>;",
          "isOptional": true,
          "isReadOnly": false,
          "isStatic": false,
          "type": "IStyleFunctionOrObject<TStyleProps, TStyleSet>",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "IRectangle": {
      "kind": "interface",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Rectangle interface."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "bottom": {
          "kind": "property",
          "signature": "bottom?: number;",
          "isOptional": true,
          "isReadOnly": false,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "height": {
          "kind": "property",
          "signature": "height: number;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "left": {
          "kind": "property",
          "signature": "left: number;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "right": {
          "kind": "property",
          "signature": "right?: number;",
          "isOptional": true,
          "isReadOnly": false,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "top": {
          "kind": "property",
          "signature": "top: number;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "width": {
          "kind": "property",
          "signature": "width: number;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "IRenderComponent": {
      "kind": "interface",
      "extends": "",
      "implements": "",
      "typeParameters": [
        "TProps"
      ],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "An interface representing a component that will not output any DOM, will just render its children and pass through items to modify the children."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "children": {
          "kind": "property",
          "signature": "children: (props: TProps) => JSX.Element;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "(props: TProps) => JSX.Element",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "JSX.Element to return in this component's render() function."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "IRenderFunction": {
      "kind": "interface",
      "extends": "",
      "implements": "",
      "typeParameters": [
        "P"
      ],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Render function interface for providing overrideable render callbacks."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "__call": {
          "kind": "method",
          "signature": "(props?: P, defaultRender?: (props?: P) => JSX.Element | null): JSX.Element | null;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "JSX.Element | null",
            "description": []
          },
          "parameters": {
            "props": {
              "name": "props",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "P"
            },
            "defaultRender": {
              "name": "defaultRender",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "(props?: P) => JSX.Element | null"
            }
          },
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        }
      }
    },
    "isDirectionalKeyCode": {
      "kind": "function",
      "signature": "export function isDirectionalKeyCode(which: number): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": []
      },
      "parameters": {
        "which": {
          "name": "which",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "number"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Returns true if the keycode is a directional keyboard key."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "isElementFocusSubZone": {
      "kind": "function",
      "signature": "export function isElementFocusSubZone(element?: HTMLElement): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": []
      },
      "parameters": {
        "element": {
          "name": "element",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "HTMLElement"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Determines if a given element is a focus sub zone."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "isElementFocusZone": {
      "kind": "function",
      "signature": "export function isElementFocusZone(element?: HTMLElement): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": []
      },
      "parameters": {
        "element": {
          "name": "element",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "HTMLElement"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Determines if a given element is a focus zone."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "isElementTabbable": {
      "kind": "function",
      "signature": "export function isElementTabbable(element: HTMLElement, checkTabIndex?: boolean): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": []
      },
      "parameters": {
        "element": {
          "name": "element",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "checkTabIndex": {
          "name": "checkTabIndex",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Determines if an element can receive focus programmatically or via a mouse click. If checkTabIndex is true, additionally checks to ensure the element can be focused with the tab key, meaning tabIndex != -1."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "isElementVisible": {
      "kind": "function",
      "signature": "export function isElementVisible(element: HTMLElement | undefined | null): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": []
      },
      "parameters": {
        "element": {
          "name": "element",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement | undefined | null"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Determines if an element is visible."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "ISize": {
      "kind": "interface",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "height": {
          "kind": "property",
          "signature": "height: number;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "width": {
          "kind": "property",
          "signature": "width: number;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "isMac": {
      "kind": "function",
      "signature": "export function isMac(reset?: boolean): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": []
      },
      "parameters": {
        "reset": {
          "name": "reset",
          "description": [
            {
              "kind": "text",
              "text": "Reset the cached result value (mainly for testing)."
            }
          ],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Returns true if the user is on a Mac. Caches the result value."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "isVirtualElement": {
      "kind": "function",
      "signature": "export function isVirtualElement(element: HTMLElement | IVirtualElement): element is IVirtualElement;",
      "returnValue": {
        "type": "element is IVirtualElement",
        "description": []
      },
      "parameters": {
        "element": {
          "name": "element",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement | IVirtualElement"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Determines whether or not an element has the virtual hierarchy extension."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "IVirtualElement": {
      "kind": "interface",
      "extends": "HTMLElement",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Attached interface for elements which support virtual references. Used internally by the virtual hierarchy methods."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "_virtual": {
          "kind": "property",
          "signature": "_virtual:",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "{\n        parent?: IVirtualElement;\n        children: IVirtualElement[];\n    }",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "mapEnumByName": {
      "kind": "function",
      "signature": "export function mapEnumByName<T>(theEnum: any, callback: (name?: string, value?: string | number) => T | undefined): (T | undefined)[] | undefined;",
      "returnValue": {
        "type": "(T | undefined)[] | undefined",
        "description": []
      },
      "parameters": {
        "theEnum": {
          "name": "theEnum",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "any"
        },
        "callback": {
          "name": "callback",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "(name?: string, value?: string | number) => T | undefined"
        }
      },
      "deprecatedMessage": [],
      "summary": [],
      "remarks": [],
      "isBeta": false
    },
    "memoize": {
      "kind": "function",
      "signature": "export function memoize<T extends Function>(target: any, key: string, descriptor: TypedPropertyDescriptor<T>): {\n    configurable: boolean;\n    get(): T;\n};",
      "returnValue": {
        "type": "{\n    configurable: boolean;\n    get(): T;\n}",
        "description": []
      },
      "parameters": {
        "target": {
          "name": "target",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "any"
        },
        "key": {
          "name": "key",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "string"
        },
        "descriptor": {
          "name": "descriptor",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "TypedPropertyDescriptor<T>"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Memoize decorator to be used on class methods. WARNING: the "
        },
        {
          "kind": "code",
          "text": "this",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " reference will be inaccessible within a memoized method, given that a cached method's "
        },
        {
          "kind": "code",
          "text": "this",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " would not be instance-specific."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "memoizeFunction": {
      "kind": "function",
      "signature": "export function memoizeFunction<T extends (...args: any[]) => RET_TYPE, RET_TYPE>(cb: T, maxCacheSize?: number): T;",
      "returnValue": {
        "type": "T",
        "description": [
          {
            "kind": "text",
            "text": "A memoized version of the function."
          }
        ]
      },
      "parameters": {
        "cb": {
          "name": "cb",
          "description": [
            {
              "kind": "text",
              "text": "The function to memoize."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "T"
        },
        "maxCacheSize": {
          "name": "maxCacheSize",
          "description": [
            {
              "kind": "text",
              "text": "Max results to cache. If the cache exceeds this value, it will reset on the next call."
            }
          ],
          "isOptional": true,
          "isSpread": false,
          "type": "number"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Memoizes a function; when you pass in the same parameters multiple times, it returns a cached result. Be careful when passing in objects, you need to pass in the same INSTANCE for caching to work. Otherwise it will grow the cache unnecessarily. Also avoid using default values that evaluate functions; passing in undefined for a value and relying on a default function will execute it the first time, but will not re-evaluate subsequent times which may have been unexpected."
        },
        {
          "kind": "paragraph"
        },
        {
          "kind": "text",
          "text": "By default, the cache will reset after 100 permutations, to avoid abuse cases where the function is unintendedly called with unique objects. Without a reset, the cache could grow infinitely, so we safeguard by resetting. To override this behavior, pass a value of 0 to the maxCacheSize parameter."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "merge": {
      "kind": "function",
      "signature": "export function merge<T = {}>(target: Partial<T>, ...args: (Partial<T> | null | undefined | false)[]): T;",
      "returnValue": {
        "type": "T",
        "description": []
      },
      "parameters": {
        "target": {
          "name": "target",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "Partial<T>"
        },
        "args": {
          "name": "args",
          "description": [],
          "isOptional": false,
          "isSpread": true,
          "type": "(Partial<T> | null | undefined | false)[]"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Simple deep merge function. Takes all arguments and returns a deep copy of the objects merged together in the order provided. If an object creates a circular reference, it will assign the original reference."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "mergeAriaAttributeValues": {
      "kind": "function",
      "signature": "export function mergeAriaAttributeValues(...ariaAttributes: (string | undefined)[]): string | undefined;",
      "returnValue": {
        "type": "string | undefined",
        "description": []
      },
      "parameters": {
        "ariaAttributes": {
          "name": "ariaAttributes",
          "description": [
            {
              "kind": "text",
              "text": "ARIA attributes to merge"
            }
          ],
          "isOptional": false,
          "isSpread": true,
          "type": "(string | undefined)[]"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "ARIA helper to concatenate attributes, returning undefined if all attributes are undefined. (Empty strings are not a valid ARIA attribute value.)"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "mergeCustomizations": {
      "kind": "function",
      "signature": "export function mergeCustomizations(props: ICustomizerProps, parentContext: ICustomizerContext): ICustomizerContext;",
      "returnValue": {
        "type": "ICustomizerContext",
        "description": [
          {
            "kind": "text",
            "text": "Merged customizations."
          }
        ]
      },
      "parameters": {
        "props": {
          "name": "props",
          "description": [
            {
              "kind": "text",
              "text": "New settings to merge in."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "ICustomizerProps"
        },
        "parentContext": {
          "name": "parentContext",
          "description": [
            {
              "kind": "text",
              "text": "Context containing current settings."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "ICustomizerContext"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Merge props and customizations giving priority to props over context. NOTE: This function will always perform multiple merge operations. Use with caution."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "mergeScopedSettings": {
      "kind": "function",
      "signature": "export function mergeScopedSettings(oldSettings?: ISettings, newSettings?: ISettings | ISettingsFunction): ISettings;",
      "returnValue": {
        "type": "ISettings",
        "description": []
      },
      "parameters": {
        "oldSettings": {
          "name": "oldSettings",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "ISettings"
        },
        "newSettings": {
          "name": "newSettings",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "ISettings | ISettingsFunction"
        }
      },
      "deprecatedMessage": [],
      "summary": [],
      "remarks": [],
      "isBeta": false
    },
    "mergeSettings": {
      "kind": "function",
      "signature": "export function mergeSettings(oldSettings?: ISettings, newSettings?: ISettings | ISettingsFunction): ISettings;",
      "returnValue": {
        "type": "ISettings",
        "description": [
          {
            "kind": "text",
            "text": "Merged settings."
          }
        ]
      },
      "parameters": {
        "oldSettings": {
          "name": "oldSettings",
          "description": [
            {
              "kind": "text",
              "text": "Old settings to fall back to."
            }
          ],
          "isOptional": true,
          "isSpread": false,
          "type": "ISettings"
        },
        "newSettings": {
          "name": "newSettings",
          "description": [
            {
              "kind": "text",
              "text": "New settings that will be merged over oldSettings."
            }
          ],
          "isOptional": true,
          "isSpread": false,
          "type": "ISettings | ISettingsFunction"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Merge new and old settings, giving priority to new settings. New settings is optional in which case oldSettings is returned as-is."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "nullRender": {
      "kind": "function",
      "signature": "export function nullRender(): JSX.Element | null;",
      "returnValue": {
        "type": "JSX.Element | null",
        "description": []
      },
      "parameters": {},
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Simple constant function for returning null, used to render empty templates in JSX."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "on": {
      "kind": "function",
      "signature": "export function on(element: Element | Window, eventName: string, callback: (ev: Event) => void, options?: boolean): () => void;",
      "returnValue": {
        "type": "() => void",
        "description": []
      },
      "parameters": {
        "element": {
          "name": "element",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "Element | Window"
        },
        "eventName": {
          "name": "eventName",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "string"
        },
        "callback": {
          "name": "callback",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "(ev: Event) => void"
        },
        "options": {
          "name": "options",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [],
      "remarks": [],
      "isBeta": false
    },
    "portalContainsElement": {
      "kind": "function",
      "signature": "export function portalContainsElement(target: HTMLElement, parent?: HTMLElement): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": []
      },
      "parameters": {
        "target": {
          "name": "target",
          "description": [
            {
              "kind": "text",
              "text": "Element to query portal containment status of."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "parent": {
          "name": "parent",
          "description": [
            {
              "kind": "text",
              "text": "Optional parent perspective. Search for containing portal stops at parent (or root if parent is undefined or invalid.)"
            }
          ],
          "isOptional": true,
          "isSpread": false,
          "type": "HTMLElement"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Determine whether a target is within a portal from perspective of root or optional parent. This function only works against portal components that use the setPortalAttribute function. If both parent and child are within the same portal this function will return false."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "precisionRound": {
      "kind": "function",
      "signature": "export function precisionRound(value: number, precision: number, base?: number): number;",
      "returnValue": {
        "type": "number",
        "description": []
      },
      "parameters": {
        "value": {
          "name": "value",
          "description": [
            {
              "kind": "text",
              "text": "The value that is being rounded."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "number"
        },
        "precision": {
          "name": "precision",
          "description": [
            {
              "kind": "text",
              "text": "The number of decimal places to round the number to"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "number"
        },
        "base": {
          "name": "base",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "number"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Rounds a number to a certain level of precision. Accepts negative precision."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "provideContext": {
      "kind": "function",
      "signature": "export function provideContext<TContext, TProps>(contextTypes: PropTypes.ValidationMap<TContext>, mapPropsToContext: (props: TProps) => TContext): React.ComponentType<TProps>;",
      "returnValue": {
        "type": "React.ComponentType<TProps>",
        "description": []
      },
      "parameters": {
        "contextTypes": {
          "name": "contextTypes",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "PropTypes.ValidationMap<TContext>"
        },
        "mapPropsToContext": {
          "name": "mapPropsToContext",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "(props: TProps) => TContext"
        }
      },
      "deprecatedMessage": [
        {
          "kind": "text",
          "text": "This function uses the legacy context API, which is deprecated and should not be used in new code. Please migrate to the new context API. https://reactjs.org/docs/context.html"
        }
      ],
      "summary": [],
      "remarks": [],
      "isBeta": false
    },
    "raiseClick": {
      "kind": "function",
      "signature": "export function raiseClick(target: Element): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "target": {
          "name": "target",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "Element"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Raises a click event."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "Rectangle": {
      "kind": "class",
      "extends": "",
      "implements": "",
      "typeParameters": [],
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Rectangle helper class."
        }
      ],
      "remarks": [],
      "isBeta": false,
      "isSealed": false,
      "members": {
        "__constructor": {
          "kind": "constructor",
          "signature": "constructor(left?: number, right?: number, top?: number, bottom?: number);",
          "parameters": {
            "left": {
              "name": "left",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "number"
            },
            "right": {
              "name": "right",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "number"
            },
            "top": {
              "name": "top",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "number"
            },
            "bottom": {
              "name": "bottom",
              "description": [],
              "isOptional": true,
              "isSpread": false,
              "type": "number"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Constructs a new instance of the "
            },
            {
              "kind": "api-link",
              "elements": [
                {
                  "kind": "text",
                  "text": "Rectangle"
                }
              ],
              "target": {
                "scopeName": "@uifabric",
                "packageName": "utilities",
                "exportName": "Rectangle",
                "memberName": ""
              }
            },
            {
              "kind": "text",
              "text": " class"
            }
          ],
          "remarks": []
        },
        "bottom": {
          "kind": "property",
          "signature": "bottom: number;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "equals": {
          "kind": "method",
          "signature": "equals(rect: Rectangle): boolean;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnValue": {
            "type": "boolean",
            "description": []
          },
          "parameters": {
            "rect": {
              "name": "rect",
              "description": [],
              "isOptional": false,
              "isSpread": false,
              "type": "Rectangle"
            }
          },
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Tests if another rect is approximately equal to this rect (within 4 decimal places.)"
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false
        },
        "height": {
          "kind": "property",
          "signature": "readonly height: number;",
          "isOptional": false,
          "isReadOnly": true,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Calculated automatically by subtracting the bottom from top."
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "left": {
          "kind": "property",
          "signature": "left: number;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "right": {
          "kind": "property",
          "signature": "right: number;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "top": {
          "kind": "property",
          "signature": "top: number;",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        },
        "width": {
          "kind": "property",
          "signature": "readonly width: number;",
          "isOptional": false,
          "isReadOnly": true,
          "isStatic": false,
          "type": "number",
          "deprecatedMessage": [],
          "summary": [
            {
              "kind": "text",
              "text": "Calculated automatically by subtracting the right from left"
            }
          ],
          "remarks": [],
          "isBeta": false,
          "isSealed": false,
          "isVirtual": false,
          "isOverride": false,
          "isEventProperty": false
        }
      }
    },
    "removeIndex": {
      "kind": "function",
      "signature": "export function removeIndex<T>(array: T[], index: number): T[];",
      "returnValue": {
        "type": "T[]",
        "description": []
      },
      "parameters": {
        "array": {
          "name": "array",
          "description": [
            {
              "kind": "text",
              "text": "The array to operate on"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "T[]"
        },
        "index": {
          "name": "index",
          "description": [
            {
              "kind": "text",
              "text": "The index of the element to remove"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "number"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Given an array, it returns a new array that does not contain the item at the given index."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "replaceElement": {
      "kind": "function",
      "signature": "export function replaceElement<T>(array: T[], newElement: T, index: number): T[];",
      "returnValue": {
        "type": "T[]",
        "description": []
      },
      "parameters": {
        "array": {
          "name": "array",
          "description": [
            {
              "kind": "text",
              "text": "The array to operate on"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "T[]"
        },
        "newElement": {
          "name": "newElement",
          "description": [
            {
              "kind": "text",
              "text": "The element that will be placed in the new array"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "T"
        },
        "index": {
          "name": "index",
          "description": [
            {
              "kind": "text",
              "text": "The index of the element that should be replaced"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "number"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Given an array, this function returns a new array where the element at a given index has been replaced."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "resetIds": {
      "kind": "function",
      "signature": "export function resetIds(counter?: number): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "counter": {
          "name": "counter",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "number"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Resets id counter to an (optional) number."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "resetMemoizations": {
      "kind": "function",
      "signature": "export function resetMemoizations(): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {},
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Reset memoizations."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "setBaseUrl": {
      "kind": "function",
      "signature": "export function setBaseUrl(baseUrl: string): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "baseUrl": {
          "name": "baseUrl",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "string"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Gets the current base url used for fetching images."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "setLanguage": {
      "kind": "function",
      "signature": "export function setLanguage(language: string, avoidPersisting?: boolean): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "language": {
          "name": "language",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "string"
        },
        "avoidPersisting": {
          "name": "avoidPersisting",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Sets the rtl state of the page (by adjusting the dir attribute of the html element.)"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "setPortalAttribute": {
      "kind": "function",
      "signature": "export function setPortalAttribute(element: HTMLElement): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "element": {
          "name": "element",
          "description": [
            {
              "kind": "text",
              "text": "Element to mark as a portal."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Identify element as a portal by setting an attribute."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "setRTL": {
      "kind": "function",
      "signature": "export function setRTL(isRTL: boolean, persistSetting?: boolean): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "isRTL": {
          "name": "isRTL",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "boolean"
        },
        "persistSetting": {
          "name": "persistSetting",
          "description": [],
          "isOptional": true,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Sets the rtl state of the page (by adjusting the dir attribute of the html element.)"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "setSSR": {
      "kind": "function",
      "signature": "export function setSSR(isEnabled: boolean): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "isEnabled": {
          "name": "isEnabled",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Helper to set ssr mode to simulate no window object returned from getWindow helper."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "setVirtualParent": {
      "kind": "function",
      "signature": "export function setVirtualParent(child: HTMLElement, parent: HTMLElement): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "child": {
          "name": "child",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "parent": {
          "name": "parent",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Sets the virtual parent of an element. Pass "
        },
        {
          "kind": "code",
          "text": "undefined",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " as the "
        },
        {
          "kind": "code",
          "text": "parent",
          "highlighter": "plain"
        },
        {
          "kind": "text",
          "text": " to clear the virtual parent."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "setWarningCallback": {
      "kind": "function",
      "signature": "export function setWarningCallback(warningCallback?: (message: string) => void): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "warningCallback": {
          "name": "warningCallback",
          "description": [
            {
              "kind": "text",
              "text": "Callback to override the generated warnings."
            }
          ],
          "isOptional": true,
          "isSpread": false,
          "type": "(message: string) => void"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Configures the warning callback. Passing in undefined will reset it to use the default console.warn function."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "shallowCompare": {
      "kind": "function",
      "signature": "export function shallowCompare<TA, TB>(a: TA, b: TB): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": []
      },
      "parameters": {
        "a": {
          "name": "a",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "TA"
        },
        "b": {
          "name": "b",
          "description": [],
          "isOptional": false,
          "isSpread": false,
          "type": "TB"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Compares a to b and b to a."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "shouldWrapFocus": {
      "kind": "function",
      "signature": "export function shouldWrapFocus(element: HTMLElement, noWrapDataAttribute: 'data-no-vertical-wrap' | 'data-no-horizontal-wrap'): boolean;",
      "returnValue": {
        "type": "boolean",
        "description": [
          {
            "kind": "text",
            "text": "true if focus should wrap, false otherwise"
          }
        ]
      },
      "parameters": {
        "element": {
          "name": "element",
          "description": [
            {
              "kind": "text",
              "text": "element to start searching from"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "HTMLElement"
        },
        "noWrapDataAttribute": {
          "name": "noWrapDataAttribute",
          "description": [
            {
              "kind": "text",
              "text": "the no wrap data attribute to match (either)"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "'data-no-vertical-wrap' | 'data-no-horizontal-wrap'"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Determines if an, or any of its ancestors, sepcificies that it doesn't want focus to wrap"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "styled": {
      "kind": "function",
      "signature": "export function styled<TComponentProps extends IPropsWithStyles<TStyleProps, TStyleSet>, TStyleProps, TStyleSet extends IStyleSet<TStyleSet>>(Component: React.ComponentClass<TComponentProps> | React.StatelessComponent<TComponentProps>, baseStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet>, getProps?: (props: TComponentProps) => Partial<TComponentProps>, customizable?: ICustomizableProps): React.StatelessComponent<TComponentProps>;",
      "returnValue": {
        "type": "React.StatelessComponent<TComponentProps>",
        "description": []
      },
      "parameters": {
        "Component": {
          "name": "Component",
          "description": [
            {
              "kind": "text",
              "text": "The unstyled base component to render, which receives styles."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "React.ComponentClass<TComponentProps> | React.StatelessComponent<TComponentProps>"
        },
        "baseStyles": {
          "name": "baseStyles",
          "description": [
            {
              "kind": "text",
              "text": "The styles which should be curried with the component."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "IStyleFunctionOrObject<TStyleProps, TStyleSet>"
        },
        "getProps": {
          "name": "getProps",
          "description": [
            {
              "kind": "text",
              "text": "A helper which provides default props."
            }
          ],
          "isOptional": true,
          "isSpread": false,
          "type": "(props: TComponentProps) => Partial<TComponentProps>"
        },
        "customizable": {
          "name": "customizable",
          "description": [
            {
              "kind": "text",
              "text": "An object which defines which props can be customized using the Customizer."
            }
          ],
          "isOptional": true,
          "isSpread": false,
          "type": "ICustomizableProps"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "The styled HOC wrapper allows you to create a functional wrapper around a given component which will resolve getStyles functional props, and mix customized props passed in using concatStyleSets."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "toMatrix": {
      "kind": "function",
      "signature": "export function toMatrix<T>(items: T[], columnCount: number): T[][];",
      "returnValue": {
        "type": "T[][]",
        "description": [
          {
            "kind": "text",
            "text": "A matrix of items"
          }
        ]
      },
      "parameters": {
        "items": {
          "name": "items",
          "description": [
            {
              "kind": "text",
              "text": "The array to convert"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "T[]"
        },
        "columnCount": {
          "name": "columnCount",
          "description": [
            {
              "kind": "text",
              "text": "The number of columns for the resulting matrix"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "number"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Convert the given array to a matrix with columnCount number of columns."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "unhoistMethods": {
      "kind": "function",
      "signature": "export function unhoistMethods(source: any, methodNames: string[]): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "source": {
          "name": "source",
          "description": [
            {
              "kind": "text",
              "text": "The source object upon which methods were hoisted."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "any"
        },
        "methodNames": {
          "name": "methodNames",
          "description": [
            {
              "kind": "text",
              "text": "An array of method names to unhoist."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "string[]"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Provides a method for convenience to unhoist hoisted methods."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "values": {
      "kind": "function",
      "signature": "export function values<T>(obj: any): T[];",
      "returnValue": {
        "type": "T[]",
        "description": []
      },
      "parameters": {
        "obj": {
          "name": "obj",
          "description": [
            {
              "kind": "text",
              "text": "The dictionary to get values for"
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "any"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Get all values in an object dictionary"
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "warn": {
      "kind": "function",
      "signature": "export function warn(message: string): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "message": {
          "name": "message",
          "description": [
            {
              "kind": "text",
              "text": "Warning message."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "string"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Sends a warning to console, if the api is present."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "warnConditionallyRequiredProps": {
      "kind": "function",
      "signature": "export function warnConditionallyRequiredProps<P>(componentName: string, props: P, requiredProps: string[], conditionalPropName: string, condition: boolean): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "componentName": {
          "name": "componentName",
          "description": [
            {
              "kind": "text",
              "text": "The name of the component being used."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "string"
        },
        "props": {
          "name": "props",
          "description": [
            {
              "kind": "text",
              "text": "The props passed into the component."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "P"
        },
        "requiredProps": {
          "name": "requiredProps",
          "description": [
            {
              "kind": "text",
              "text": "The name of the props that are required when the condition is met."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "string[]"
        },
        "conditionalPropName": {
          "name": "conditionalPropName",
          "description": [
            {
              "kind": "text",
              "text": "The name of the prop that the condition is based on."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "string"
        },
        "condition": {
          "name": "condition",
          "description": [
            {
              "kind": "text",
              "text": "Whether the condition is met."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "boolean"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Warns when props are required if a condition is met."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "warnDeprecations": {
      "kind": "function",
      "signature": "export function warnDeprecations<P>(componentName: string, props: P, deprecationMap: ISettingsMap<P>): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "componentName": {
          "name": "componentName",
          "description": [
            {
              "kind": "text",
              "text": "The name of the component being used."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "string"
        },
        "props": {
          "name": "props",
          "description": [
            {
              "kind": "text",
              "text": "The props passed into the component."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "P"
        },
        "deprecationMap": {
          "name": "deprecationMap",
          "description": [
            {
              "kind": "text",
              "text": "The map of deprecations, where key is the prop name and the value is either null or a replacement prop name."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "ISettingsMap<P>"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Warns when a deprecated props are being used."
        }
      ],
      "remarks": [],
      "isBeta": false
    },
    "warnMutuallyExclusive": {
      "kind": "function",
      "signature": "export function warnMutuallyExclusive<P>(componentName: string, props: P, exclusiveMap: ISettingsMap<P>): void;",
      "returnValue": {
        "type": "void",
        "description": []
      },
      "parameters": {
        "componentName": {
          "name": "componentName",
          "description": [
            {
              "kind": "text",
              "text": "The name of the component being used."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "string"
        },
        "props": {
          "name": "props",
          "description": [
            {
              "kind": "text",
              "text": "The props passed into the component."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "P"
        },
        "exclusiveMap": {
          "name": "exclusiveMap",
          "description": [
            {
              "kind": "text",
              "text": "A map where the key is a parameter, and the value is the other parameter."
            }
          ],
          "isOptional": false,
          "isSpread": false,
          "type": "ISettingsMap<P>"
        }
      },
      "deprecatedMessage": [],
      "summary": [
        {
          "kind": "text",
          "text": "Warns when two props which are mutually exclusive are both being used."
        }
      ],
      "remarks": [],
      "isBeta": false
    }
  }
}
