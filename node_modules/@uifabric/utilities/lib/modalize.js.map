{"version":3,"file":"modalize.js","sourceRoot":"../src/","sources":["modalize.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAE,WAAW,EAAE,MAAM,mBAAmB,CAAC;AAEhD;;;GAGG;AACH,MAAM,UAAU,QAAQ,CAAC,MAAmB;;IAC1C,IAAI,aAAa,GAAkB,EAAE,CAAC;IACtC,IAAM,cAAc,GAAG,WAAW,CAAC,MAAM,CAAC,IAAI,QAAQ,CAAC;IAEvD,kFAAkF;IAClF,OAAO,MAAM,KAAK,cAAc,CAAC,IAAI,EAAE;QACrC,uCAAuC;QACvC,KAAsB,UAAiE,EAAjE,KAAC,MAAM,CAAC,aAAc,CAAC,QAA0C,EAAjE,cAAiE,EAAjE,IAAiE,EAAE;YAApF,IAAM,OAAO,SAAA;YAChB,mDAAmD;YACnD,IAAI,OAAO,KAAK,MAAM,IAAI,OAAA,OAAO,CAAC,YAAY,CAAC,aAAa,CAAC,0CAAE,WAAW,QAAO,MAAM,EAAE;gBACvF,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;aAC7B;SACF;QAED,IAAI,CAAC,MAAM,CAAC,aAAa,EAAE;YACzB,MAAM;SACP;QACD,MAAM,GAAG,MAAM,CAAC,aAAa,CAAC;KAC/B;IAED,2DAA2D;IAC3D,aAAa,CAAC,OAAO,CAAC,UAAA,IAAI;QACxB,IAAI,CAAC,YAAY,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC;IAC3C,CAAC,CAAC,CAAC;IAEH,OAAO;QACL,UAAU,CAAC,aAAa,CAAC,CAAC;QAC1B,aAAa,GAAG,EAAE,CAAC,CAAC,UAAU;IAChC,CAAC,CAAC;AACJ,CAAC;AAED;;GAEG;AACH,SAAS,UAAU,CAAC,aAA4B;IAC9C,aAAa,CAAC,OAAO,CAAC,UAAA,IAAI;QACxB,2GAA2G;QAC3G,IAAI,CAAC,YAAY,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;IAC5C,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["/**\n * The helper functions here will make the target element as modal to screen readers, by placing aria-hidden on elements\n * that are siblings to the target element and the target element's ancestors (because aria-hidden gets inherited).\n * That way, all other elements on the page are hidden to the screen reader.\n */\n\nimport { getDocument } from './dom/getDocument';\n\n/**\n * Call this on a target element to make it modal to screen readers.\n * Returns a function that undoes the changes it made.\n */\nexport function modalize(target: HTMLElement): () => void {\n  let affectedNodes: HTMLElement[] = [];\n  const targetDocument = getDocument(target) || document;\n\n  // start at target, then recurse and do the same for parent, until we reach <body>\n  while (target !== targetDocument.body) {\n    // grab all siblings of current element\n    for (const sibling of (target.parentElement!.children as unknown) as Array<HTMLElement>) {\n      // but ignore elements that are already aria-hidden\n      if (sibling !== target && sibling.getAttribute('aria-hidden')?.toLowerCase() !== 'true') {\n        affectedNodes.push(sibling);\n      }\n    }\n\n    if (!target.parentElement) {\n      break;\n    }\n    target = target.parentElement;\n  }\n\n  // take all those elements and set aria-hidden=true on them\n  affectedNodes.forEach(node => {\n    node.setAttribute('aria-hidden', 'true');\n  });\n\n  return () => {\n    unmodalize(affectedNodes);\n    affectedNodes = []; // dispose\n  };\n}\n\n/**\n * Undoes the changes that modalize() did.\n */\nfunction unmodalize(affectedNodes: HTMLElement[]) {\n  affectedNodes.forEach(node => {\n    // set instead of removing in case other components explicitly set aria-hidden and do ==\"true\" or ==\"false\"\n    node.setAttribute('aria-hidden', 'false');\n  });\n}\n"]}