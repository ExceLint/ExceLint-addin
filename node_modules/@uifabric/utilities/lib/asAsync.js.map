{"version":3,"file":"asAsync.js","sourceRoot":"../src/","sources":["asAsync.tsx"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;GAaG;;AAEH,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAmB/B;;;;GAIG;AACH,IAAM,gBAAgB,GACpB,OAAO,OAAO,KAAK,WAAW;IAC5B,CAAC,CAAC,kCAAkC;QAClC,IAAI,OAAO,EAAyE;IACtF,CAAC,CAAC,SAAS,CAAC;AAEhB;;;;;GAKG;AACH,MAAM,kBAA0B,OAAgC;IAC9D;QAAoB,iCAMnB;QAND;YAAA,qEA2CC;YApCQ,WAAK,GAAG;gBACb,SAAS,EAAE,gBAAgB,CAAC,CAAC,CAAC,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS;aAC7E,CAAC;;QAkCJ,CAAC;QAhCQ,sBAAM,GAAb;YACE,8GAA8G;YAC9G,kCAAkC;YAClC,IAAM,eAA4E,EAA1E,8BAAY,EAAE,iCAA6B,EAAE,+DAA6B,CAAC;YAC3E,IAAA,gCAAS,CAAgB;YAEjC,OAAO,SAAS,CAAC,CAAC,CAAC,oBAAC,SAAS,qBAAC,GAAG,EAAE,YAAY,IAAM,IAAI,EAAI,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,oBAAC,WAAW,OAAG,CAAC,CAAC,CAAC,IAAI,CAAC;QACvG,CAAC;QAEM,iCAAiB,GAAxB;YAAA,iBAsBC;YArBO,IAAA,gCAAS,CAAgB;YAE/B,IAAI,CAAC,SAAS,EAAE;gBACd,OAAO;qBACJ,IAAI,EAAE;qBACN,IAAI,CAAC,UAAC,eAAwC;oBAC7C,IAAI,eAAe,EAAE;wBACnB,wCAAwC;wBACxC,gBAAgB,IAAI,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;wBAExE,aAAa;wBACb,KAAI,CAAC,QAAQ,CACX;4BACE,SAAS,EAAE,eAAe;yBAC3B,EACD,OAAO,CAAC,MAAM,CACf,CAAC;qBACH;gBACH,CAAC,CAAC;qBACD,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;aAC3B;QACH,CAAC;QACH,YAAC;IAAD,CAAC,AA3CD,CAAoB,KAAK,CAAC,SAAS,GA2ClC;IAED,OAAO,KAAK,CAAC,UAAU,CAAC,UAAC,KAAsD,EAAE,GAAsB,IAAK,OAAA,CAC1G,oBAAC,KAAK,uBAAK,KAAK,IAAE,YAAY,EAAE,GAAG,IAAI,CACxC,EAF2G,CAE3G,CAAC,CAAC;AACL,CAAC","sourcesContent":["/**\r\n * asAsync - a HOC for async loading components.\r\n *\r\n * Usage:\r\n *\r\n * const AsyncDialog = asAsync({\r\n *   load: () => import('Dialog').then(result => result.default),\r\n * });\r\n *\r\n * React.render(domElement, <AsyncDialog asyncPlaceholder={ () => <Spinner/> } { ...dialogProps } />);\r\n *\r\n * Note the `asyncPlaceholder` prop will be respected when rendering the async component and it hasn't\r\n * been loaded yet.\r\n */\r\n\r\nimport * as React from 'react';\r\n\r\nexport interface IAsAsyncOptions<TProps> {\r\n  /**\r\n   * Callback which returns a promise resolving an object which exports the component.\r\n   */\r\n  load: () => Promise<React.ReactType<TProps>>;\r\n\r\n  /**\r\n   * Callback executed when async loading is complete.\r\n   */\r\n  onLoad?: () => void;\r\n\r\n  /**\r\n   * Callback when async loading fails.\r\n   */\r\n  onError?: (error: Error) => void;\r\n}\r\n\r\n/**\r\n * If possible, use a WeakMap to maintain a cache of loaded components.\r\n * This can be used to synchronously render components that have already been loaded,\r\n * rather than having to wait for at least one async tick.\r\n */\r\nconst _syncModuleCache =\r\n  typeof WeakMap !== 'undefined'\r\n    ? // tslint:disable-next-line:no-any\r\n      new WeakMap<() => Promise<React.ReactType<any>>, React.ReactType<any> | undefined>()\r\n    : undefined;\r\n\r\n/**\r\n * Produces a component which internally loads the target component before first mount.\r\n * The component passes all props through to the loaded component.\r\n *\r\n * This overload accepts a module with a default export for the component.\r\n */\r\nexport function asAsync<TProps>(options: IAsAsyncOptions<TProps>): React.ComponentType<TProps & { asyncPlaceholder?: React.ReactType }> {\r\n  class Async extends React.Component<\r\n    TProps & {\r\n      asyncPlaceholder?: React.ReactType;\r\n      forwardedRef: React.Ref<TProps>;\r\n    },\r\n    { Component?: React.ReactType<TProps> }\r\n  > {\r\n    public state = {\r\n      Component: _syncModuleCache ? _syncModuleCache.get(options.load) : undefined\r\n    };\r\n\r\n    public render(): JSX.Element | null {\r\n      // Typescript issue: the rest can't be pulled without the any cast, as TypeScript fails with rest on generics.\r\n      // tslint:disable-next-line:no-any\r\n      const { forwardedRef, asyncPlaceholder: Placeholder, ...rest } = this.props as any;\r\n      const { Component } = this.state;\r\n\r\n      return Component ? <Component ref={forwardedRef} {...rest} /> : Placeholder ? <Placeholder /> : null;\r\n    }\r\n\r\n    public componentDidMount(): void {\r\n      let { Component } = this.state;\r\n\r\n      if (!Component) {\r\n        options\r\n          .load()\r\n          .then((LoadedComponent: React.ReactType<TProps>) => {\r\n            if (LoadedComponent) {\r\n              // Cache component for future reference.\r\n              _syncModuleCache && _syncModuleCache.set(options.load, LoadedComponent);\r\n\r\n              // Set state.\r\n              this.setState(\r\n                {\r\n                  Component: LoadedComponent\r\n                },\r\n                options.onLoad\r\n              );\r\n            }\r\n          })\r\n          .catch(options.onError);\r\n      }\r\n    }\r\n  }\r\n\r\n  return React.forwardRef((props: TProps & { asyncPlaceholder?: React.ReactType }, ref: React.Ref<TProps>) => (\r\n    <Async {...props} forwardedRef={ref} />\r\n  ));\r\n}\r\n"]}