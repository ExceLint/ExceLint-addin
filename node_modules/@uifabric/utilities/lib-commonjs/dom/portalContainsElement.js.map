{"version":3,"file":"portalContainsElement.js","sourceRoot":"../src/","sources":["dom/portalContainsElement.ts"],"names":[],"mappings":";;AAAA,+DAA8D;AAC9D,2DAA6D;AAE7D;;;;;;GAMG;AACH,+BAAsC,MAAmB,EAAE,MAAoB;IAC7E,IAAM,YAAY,GAAG,2CAAoB,CACvC,MAAM,EACN,UAAC,WAAwB,IAAK,OAAA,MAAM,KAAK,WAAW,IAAI,WAAW,CAAC,YAAY,CAAC,0CAAqB,CAAC,EAAzE,CAAyE,CACxG,CAAC;IACF,OAAO,YAAY,KAAK,IAAI,IAAI,YAAY,CAAC,YAAY,CAAC,0CAAqB,CAAC,CAAC;AACnF,CAAC;AAND,sDAMC","sourcesContent":["import { findElementRecursive } from './findElementRecursive';\r\nimport { DATA_PORTAL_ATTRIBUTE } from './setPortalAttribute';\r\n\r\n/**\r\n * Determine whether a target is within a portal from perspective of root or optional parent.\r\n * This function only works against portal components that use the setPortalAttribute function.\r\n * If both parent and child are within the same portal this function will return false.\r\n * @param target - Element to query portal containment status of.\r\n * @param parent - Optional parent perspective. Search for containing portal stops at parent (or root if parent is undefined or invalid.)\r\n */\r\nexport function portalContainsElement(target: HTMLElement, parent?: HTMLElement): boolean {\r\n  const elementMatch = findElementRecursive(\r\n    target,\r\n    (testElement: HTMLElement) => parent === testElement || testElement.hasAttribute(DATA_PORTAL_ATTRIBUTE)\r\n  );\r\n  return elementMatch !== null && elementMatch.hasAttribute(DATA_PORTAL_ATTRIBUTE);\r\n}\r\n"]}