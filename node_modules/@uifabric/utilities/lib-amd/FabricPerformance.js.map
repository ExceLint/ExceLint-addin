{"version":3,"file":"FabricPerformance.js","sourceRoot":"../src/","sources":["FabricPerformance.ts"],"names":[],"mappings":";;;IAgCA,IAAM,GAAG,GAAiB,cAAM,OAAA,CAAC,OAAO,WAAW,KAAK,WAAW,IAAI,CAAC,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,EAA1F,CAA0F,CAAC;IAE3H,IAAM,cAAc,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC,6BAA6B;IAEnE;;;;OAIG;IACH;QAAA;QAyCA,CAAC;QArCC;;;;;WAKG;QACW,yBAAO,GAArB,UAAsB,IAAY,EAAE,IAAgB;YAClD,IAAI,iBAAiB,CAAC,UAAU,EAAE;gBAChC,iBAAiB,CAAC,gBAAgB,EAAE,CAAC;aACtC;YACD,IAAM,KAAK,GAAG,GAAG,EAAE,CAAC;YACpB,IAAI,EAAE,CAAC;YACP,IAAM,GAAG,GAAG,GAAG,EAAE,CAAC;YAClB,IAAM,WAAW,GAAqB,iBAAiB,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI;gBACvE,aAAa,EAAE,CAAC;gBAChB,KAAK,EAAE,CAAC;gBACR,GAAG,EAAE,EAAE;aACR,CAAC;YACF,IAAM,QAAQ,GAAG,GAAG,GAAG,KAAK,CAAC;YAC7B,WAAW,CAAC,aAAa,IAAI,QAAQ,CAAC;YACtC,WAAW,CAAC,KAAK,EAAE,CAAC;YACpB,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC;gBACnB,QAAQ,EAAE,QAAQ;gBAClB,SAAS,EAAE,GAAG;aACf,CAAC,CAAC;YACH,iBAAiB,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC;QAChD,CAAC;QAEa,uBAAK,GAAnB;YACE,iBAAiB,CAAC,OAAO,GAAG,EAAE,CAAC;YAC/B,YAAY,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;YAC3C,iBAAiB,CAAC,UAAU,GAAG,GAAG,CAAC;QACrC,CAAC;QAEa,kCAAgB,GAA9B;YACE,iBAAiB,CAAC,UAAU,GAAG,UAAU,CAAC,cAAM,OAAA,iBAAiB,CAAC,KAAK,EAAE,EAAzB,CAAyB,EAAE,cAAc,CAAC,CAAC;QAC7F,CAAC;QAvCa,yBAAO,GAAiB,EAAE,CAAC;QAwC3C,wBAAC;KAAA,AAzCD,IAyCC;IAzCY,8CAAiB","sourcesContent":["declare const setTimeout: (cb: () => void, delay: number) => number;\r\n\r\n/**\r\n * PerfData interface.\r\n *\r\n * @internal\r\n */\r\nexport interface IPerfData {\r\n  duration: number;\r\n  timeStamp: number;\r\n}\r\n\r\n/**\r\n * PerfMeasurement interface.\r\n *\r\n * @internal\r\n */\r\nexport interface IPerfMeasurement {\r\n  totalDuration: number;\r\n  count: number;\r\n  all: IPerfData[];\r\n}\r\n\r\n/**\r\n * PerfSummary interface.\r\n *\r\n * @internal\r\n */\r\nexport interface IPerfSummary {\r\n  [key: string]: IPerfMeasurement;\r\n}\r\n\r\nconst now: () => number = () => (typeof performance !== 'undefined' && !!performance.now ? performance.now() : Date.now());\r\n\r\nconst RESET_INTERVAL = 3 * 60 * 1000; // auto reset every 3 minutes\r\n\r\n/**\r\n * Performance helper class for measuring things.\r\n *\r\n * @public\r\n */\r\nexport class FabricPerformance {\r\n  public static summary: IPerfSummary = {};\r\n  private static _timeoutId: number;\r\n\r\n  /**\r\n   * Measures execution time of the given syncronous function. If the same logic is executed multiple times,\r\n   * each individual measurement will be collected as well the overall numbers.\r\n   * @param name - The name of this measurement\r\n   * @param func - The logic to be measured for execution time\r\n   */\r\n  public static measure(name: string, func: () => void): void {\r\n    if (FabricPerformance._timeoutId) {\r\n      FabricPerformance.setPeriodicReset();\r\n    }\r\n    const start = now();\r\n    func();\r\n    const end = now();\r\n    const measurement: IPerfMeasurement = FabricPerformance.summary[name] || {\r\n      totalDuration: 0,\r\n      count: 0,\r\n      all: []\r\n    };\r\n    const duration = end - start;\r\n    measurement.totalDuration += duration;\r\n    measurement.count++;\r\n    measurement.all.push({\r\n      duration: duration,\r\n      timeStamp: end\r\n    });\r\n    FabricPerformance.summary[name] = measurement;\r\n  }\r\n\r\n  public static reset(): void {\r\n    FabricPerformance.summary = {};\r\n    clearTimeout(FabricPerformance._timeoutId);\r\n    FabricPerformance._timeoutId = NaN;\r\n  }\r\n\r\n  public static setPeriodicReset(): void {\r\n    FabricPerformance._timeoutId = setTimeout(() => FabricPerformance.reset(), RESET_INTERVAL);\r\n  }\r\n}\r\n"]}