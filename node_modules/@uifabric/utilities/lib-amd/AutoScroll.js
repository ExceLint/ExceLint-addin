define(["require", "exports", "./EventGroup", "./scroll", "./dom/getRect"], function (require, exports, EventGroup_1, scroll_1, getRect_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SCROLL_ITERATION_DELAY = 16;
    var SCROLL_GUTTER_HEIGHT = 100;
    var MAX_SCROLL_VELOCITY = 15;
    /**
     * AutoScroll simply hooks up mouse events given a parent element, and scrolls the container
     * up/down depending on how close the mouse is to the top/bottom of the container.
     *
     * Once you don't want autoscroll any more, just dispose the helper and it will unhook events.
     *
     * @public
     */
    var AutoScroll = /** @class */ (function () {
        function AutoScroll(element) {
            this._events = new EventGroup_1.EventGroup(this);
            this._scrollableParent = scroll_1.findScrollableParent(element);
            this._incrementScroll = this._incrementScroll.bind(this);
            this._scrollRect = getRect_1.getRect(this._scrollableParent);
            // tslint:disable-next-line:no-any
            if (this._scrollableParent === window) {
                this._scrollableParent = document.body;
            }
            if (this._scrollableParent) {
                this._events.on(window, 'mousemove', this._onMouseMove, true);
                this._events.on(window, 'touchmove', this._onTouchMove, true);
            }
        }
        AutoScroll.prototype.dispose = function () {
            this._events.dispose();
            this._stopScroll();
        };
        AutoScroll.prototype._onMouseMove = function (ev) {
            this._computeScrollVelocity(ev.clientY);
        };
        AutoScroll.prototype._onTouchMove = function (ev) {
            if (ev.touches.length > 0) {
                this._computeScrollVelocity(ev.touches[0].clientY);
            }
        };
        AutoScroll.prototype._computeScrollVelocity = function (clientY) {
            if (!this._scrollRect) {
                return;
            }
            var scrollRectTop = this._scrollRect.top;
            var scrollClientBottom = scrollRectTop + this._scrollRect.height - SCROLL_GUTTER_HEIGHT;
            if (clientY < scrollRectTop + SCROLL_GUTTER_HEIGHT) {
                this._scrollVelocity = Math.max(-MAX_SCROLL_VELOCITY, -MAX_SCROLL_VELOCITY * ((SCROLL_GUTTER_HEIGHT - (clientY - scrollRectTop)) / SCROLL_GUTTER_HEIGHT));
            }
            else if (clientY > scrollClientBottom) {
                this._scrollVelocity = Math.min(MAX_SCROLL_VELOCITY, MAX_SCROLL_VELOCITY * ((clientY - scrollClientBottom) / SCROLL_GUTTER_HEIGHT));
            }
            else {
                this._scrollVelocity = 0;
            }
            if (this._scrollVelocity) {
                this._startScroll();
            }
            else {
                this._stopScroll();
            }
        };
        AutoScroll.prototype._startScroll = function () {
            if (!this._timeoutId) {
                this._incrementScroll();
            }
        };
        AutoScroll.prototype._incrementScroll = function () {
            if (this._scrollableParent) {
                this._scrollableParent.scrollTop += Math.round(this._scrollVelocity);
            }
            this._timeoutId = setTimeout(this._incrementScroll, SCROLL_ITERATION_DELAY);
        };
        AutoScroll.prototype._stopScroll = function () {
            if (this._timeoutId) {
                clearTimeout(this._timeoutId);
                delete this._timeoutId;
            }
        };
        return AutoScroll;
    }());
    exports.AutoScroll = AutoScroll;
});
//# sourceMappingURL=AutoScroll.js.map