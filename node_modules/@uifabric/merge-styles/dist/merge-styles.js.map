{"version":3,"file":"merge-styles.js","sources":["webpack://MergeStyles/webpack/bootstrap","webpack://MergeStyles/D:/a/1/s/common/temp/node_modules/.registry.npmjs.org/tslib/1.9.3/node_modules/tslib/tslib.es6.js","webpack://MergeStyles/index.ts","webpack://MergeStyles/setVersion.ts","webpack://MergeStyles/Stylesheet.ts","webpack://MergeStyles/concatStyleSets.ts","webpack://MergeStyles/extractStyleParts.ts","webpack://MergeStyles/fontFace.ts","webpack://MergeStyles/getVendorSettings.ts","webpack://MergeStyles/keyframes.ts","webpack://MergeStyles/mergeStyleSets.ts","webpack://MergeStyles/mergeStyles.ts","webpack://MergeStyles/styleToClassName.ts","webpack://MergeStyles/transforms/kebabRules.ts","webpack://MergeStyles/transforms/prefixRules.ts","webpack://MergeStyles/transforms/provideUnits.ts","webpack://MergeStyles/transforms/rtlifyRules.ts","webpack://MergeStyles/version.ts"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/index.js\");\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { setVersion } from './setVersion';\r\nexport { setVersion };\r\n\r\nsetVersion('@uifabric/set-version', '6.0.0');\r\n","// A packages cache that makes sure that we don't inject the same packageName twice in the same bundle -\r\n// this cache is local to the module closure inside this bundle\r\nconst packagesCache: { [name: string]: string } = {};\r\nexport function setVersion(packageName: string, packageVersion: string): void {\r\n  if (typeof window !== 'undefined') {\r\n    // tslint:disable-next-line:no-any\r\n    const packages = ((window as any).__packages__ = (window as any).__packages__ || {});\r\n\r\n    // We allow either the global packages or local packages caches to invalidate so testing can just clear the global to set this state\r\n    if (!packages[packageName] || !packagesCache[packageName]) {\r\n      packagesCache[packageName] = packageVersion;\r\n      const versions = (packages[packageName] = packages[packageName] || []);\r\n      versions.push(packageVersion);\r\n    }\r\n  }\r\n}\r\n","import { IStyle } from './IStyle';\r\n\r\nexport const InjectionMode = {\r\n  /**\r\n   * Avoids style injection, use getRules() to read the styles.\r\n   */\r\n  none: 0 as 0,\r\n\r\n  /**\r\n   * Inserts rules using the insertRule api.\r\n   */\r\n  insertNode: 1 as 1,\r\n\r\n  /**\r\n   * Appends rules using appendChild.\r\n   */\r\n  appendChild: 2 as 2\r\n};\r\n\r\nexport type InjectionMode = typeof InjectionMode[keyof typeof InjectionMode];\r\n\r\n/**\r\n * Stylesheet config.\r\n *\r\n * @public\r\n */\r\nexport interface IStyleSheetConfig {\r\n  /**\r\n   * Injection mode for how rules are inserted.\r\n   */\r\n  injectionMode?: InjectionMode;\r\n\r\n  /**\r\n   * Default 'displayName' to use for a className.\r\n   * @defaultvalue 'css'\r\n   */\r\n  defaultPrefix?: string;\r\n\r\n  /**\r\n   * Default 'namespace' to attach before the className.\r\n   */\r\n  namespace?: string;\r\n\r\n  /**\r\n   * Callback executed when a rule is inserted.\r\n   */\r\n  onInsertRule?: (rule: string) => void;\r\n}\r\n\r\nconst STYLESHEET_SETTING = '__stylesheet__';\r\n\r\n// tslint:disable-next-line:no-any\r\nconst _fileScopedGlobal: { [key: string]: any } = {};\r\nlet _stylesheet: Stylesheet;\r\n\r\n/**\r\n * Represents the state of styles registered in the page. Abstracts\r\n * the surface for adding styles to the stylesheet, exposes helpers\r\n * for reading the styles registered in server rendered scenarios.\r\n *\r\n * @public\r\n */\r\nexport class Stylesheet {\r\n  private _lastStyleElement?: HTMLStyleElement;\r\n  private _styleElement?: HTMLStyleElement;\r\n  private _rules: string[] = [];\r\n  private _preservedRules: string[] = [];\r\n  private _config: IStyleSheetConfig;\r\n  private _rulesToInsert: string[] = [];\r\n  private _counter = 0;\r\n  private _keyToClassName: { [key: string]: string } = {};\r\n  private _onResetCallbacks: (() => void)[] = [];\r\n\r\n  // tslint:disable-next-line:no-any\r\n  private _classNameToArgs: { [key: string]: { args: any; rules: string[] } } = {};\r\n\r\n  /**\r\n   * Gets the singleton instance.\r\n   */\r\n  public static getInstance(): Stylesheet {\r\n    // tslint:disable-next-line:no-any\r\n    const global: any = typeof window !== 'undefined' ? window : _fileScopedGlobal;\r\n    _stylesheet = global[STYLESHEET_SETTING] as Stylesheet;\r\n\r\n    if (!_stylesheet || (_stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== document)) {\r\n      // tslint:disable-next-line:no-string-literal\r\n      const fabricConfig = (global && global['FabricConfig']) || {};\r\n\r\n      _stylesheet = global[STYLESHEET_SETTING] = new Stylesheet(fabricConfig.mergeStyles);\r\n    }\r\n\r\n    return _stylesheet;\r\n  }\r\n\r\n  constructor(config?: IStyleSheetConfig) {\r\n    this._config = {\r\n      injectionMode: InjectionMode.insertNode,\r\n      defaultPrefix: 'css',\r\n      namespace: undefined,\r\n      ...config\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Configures the stylesheet.\r\n   */\r\n  public setConfig(config?: IStyleSheetConfig): void {\r\n    this._config = {\r\n      ...this._config,\r\n      ...config\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Configures a reset callback.\r\n   *\r\n   * @param callback - A callback which will be called when the Stylesheet is reset.\r\n   */\r\n  public onReset(callback: () => void): void {\r\n    this._onResetCallbacks.push(callback);\r\n  }\r\n\r\n  /**\r\n   * Generates a unique classname.\r\n   *\r\n   * @param displayName - Optional value to use as a prefix.\r\n   */\r\n  public getClassName(displayName?: string): string {\r\n    const { namespace } = this._config;\r\n    const prefix = displayName || this._config.defaultPrefix;\r\n\r\n    return `${namespace ? namespace + '-' : ''}${prefix}-${this._counter++}`;\r\n  }\r\n\r\n  /**\r\n   * Used internally to cache information about a class which was\r\n   * registered with the stylesheet.\r\n   */\r\n  public cacheClassName(className: string, key: string, args: IStyle[], rules: string[]): void {\r\n    this._keyToClassName[key] = className;\r\n    this._classNameToArgs[className] = {\r\n      args,\r\n      rules\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets the appropriate classname given a key which was previously\r\n   * registered using cacheClassName.\r\n   */\r\n  public classNameFromKey(key: string): string | undefined {\r\n    return this._keyToClassName[key];\r\n  }\r\n\r\n  /**\r\n   * Gets the arguments associated with a given classname which was\r\n   * previously registered using cacheClassName.\r\n   */\r\n  public argsFromClassName(className: string): IStyle[] | undefined {\r\n    const entry = this._classNameToArgs[className];\r\n\r\n    return entry && entry.args;\r\n  }\r\n\r\n  /**\r\n   * Gets the arguments associated with a given classname which was\r\n   * previously registered using cacheClassName.\r\n   */\r\n  public insertedRulesFromClassName(className: string): string[] | undefined {\r\n    const entry = this._classNameToArgs[className];\r\n\r\n    return entry && entry.rules;\r\n  }\r\n\r\n  /**\r\n   * Inserts a css rule into the stylesheet.\r\n   * @param preserve - Preserves the rule beyond a reset boundary.\r\n   */\r\n  public insertRule(rule: string, preserve?: boolean): void {\r\n    const { injectionMode } = this._config;\r\n    const element = injectionMode !== InjectionMode.none ? this._getStyleElement() : undefined;\r\n\r\n    if (preserve) {\r\n      this._preservedRules.push(rule);\r\n    }\r\n\r\n    if (element) {\r\n      switch (this._config.injectionMode) {\r\n        case InjectionMode.insertNode:\r\n          const { sheet } = element!;\r\n\r\n          try {\r\n            (sheet as CSSStyleSheet).insertRule(rule, (sheet as CSSStyleSheet).cssRules.length);\r\n          } catch (e) {\r\n            // The browser will throw exceptions on unsupported rules (such as a moz prefix in webkit.)\r\n            // We need to swallow the exceptions for this scenario, otherwise we'd need to filter\r\n            // which could be slower and bulkier.\r\n          }\r\n          break;\r\n\r\n        case InjectionMode.appendChild:\r\n          element.appendChild(document.createTextNode(rule));\r\n          break;\r\n      }\r\n    } else {\r\n      this._rules.push(rule);\r\n    }\r\n\r\n    if (this._config.onInsertRule) {\r\n      this._config.onInsertRule(rule);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets all rules registered with the stylesheet; only valid when\r\n   * using InsertionMode.none.\r\n   */\r\n  public getRules(includePreservedRules?: boolean): string {\r\n    return (includePreservedRules ? this._preservedRules.join('') : '') + this._rules.join('') + this._rulesToInsert.join('');\r\n  }\r\n\r\n  /**\r\n   * Resets the internal state of the stylesheet. Only used in server\r\n   * rendered scenarios where we're using InsertionMode.none.\r\n   */\r\n  public reset(): void {\r\n    this._rules = [];\r\n    this._rulesToInsert = [];\r\n    this._counter = 0;\r\n    this._classNameToArgs = {};\r\n    this._keyToClassName = {};\r\n\r\n    this._onResetCallbacks.forEach((callback: () => void) => callback());\r\n  }\r\n\r\n  // Forces the regeneration of incoming styles without totally resetting the stylesheet.\r\n  public resetKeys(): void {\r\n    this._keyToClassName = {};\r\n  }\r\n\r\n  private _getStyleElement(): HTMLStyleElement | undefined {\r\n    if (!this._styleElement && typeof document !== 'undefined') {\r\n      this._styleElement = this._createStyleElement();\r\n\r\n      // Reset the style element on the next frame.\r\n      window.requestAnimationFrame(() => {\r\n        this._styleElement = undefined;\r\n      });\r\n    }\r\n    return this._styleElement;\r\n  }\r\n\r\n  private _createStyleElement(): HTMLStyleElement {\r\n    const styleElement = document.createElement('style');\r\n\r\n    styleElement.setAttribute('data-merge-styles', 'true');\r\n    styleElement.type = 'text/css';\r\n\r\n    if (this._lastStyleElement && this._lastStyleElement.nextElementSibling) {\r\n      document.head!.insertBefore(styleElement, this._lastStyleElement.nextElementSibling);\r\n    } else {\r\n      document.head!.appendChild(styleElement);\r\n    }\r\n    this._lastStyleElement = styleElement;\r\n\r\n    return styleElement;\r\n  }\r\n}\r\n","import { IStyleSet, IConcatenatedStyleSet } from './IStyleSet';\r\nimport { IStyleBase, IStyle } from './IStyle';\r\nimport { IStyleFunctionOrObject } from './IStyleFunction';\r\n\r\n/**\r\n * Combine a set of styles together (but does not register css classes).\r\n * @param styleSet - The first style set to be concatenated.\r\n */\r\nexport function concatStyleSets<TStyleSet extends IStyleSet<TStyleSet>>(\r\n  styleSet: TStyleSet | false | null | undefined\r\n): IConcatenatedStyleSet<TStyleSet>;\r\n\r\n/**\r\n * Combine a set of styles together (but does not register css classes).\r\n * @param styleSet1 - The first style set to be concatenated.\r\n * @param styleSet2 - The second style set to be concatenated.\r\n */\r\nexport function concatStyleSets<TStyleSet1 extends IStyleSet<TStyleSet1>, TStyleSet2 extends IStyleSet<TStyleSet2>>(\r\n  styleSet1: TStyleSet1 | false | null | undefined,\r\n  styleSet2: TStyleSet2 | false | null | undefined\r\n): IConcatenatedStyleSet<TStyleSet1 & TStyleSet2>;\r\n\r\n/**\r\n * Combine a set of styles together (but does not register css classes).\r\n * @param styleSet1 - The first style set to be concatenated.\r\n * @param styleSet2 - The second style set to be concatenated.\r\n * @param styleSet3 - The third style set to be concatenated.\r\n */\r\nexport function concatStyleSets<\r\n  TStyleSet1 extends IStyleSet<TStyleSet1>,\r\n  TStyleSet2 extends IStyleSet<TStyleSet2>,\r\n  TStyleSet3 extends IStyleSet<TStyleSet3>\r\n>(\r\n  styleSet1: TStyleSet1 | false | null | undefined,\r\n  styleSet2: TStyleSet2 | false | null | undefined,\r\n  styleSet3: TStyleSet3 | false | null | undefined\r\n): IConcatenatedStyleSet<TStyleSet1 & TStyleSet2 & TStyleSet3>;\r\n\r\n/**\r\n * Combine a set of styles together (but does not register css classes).\r\n * @param styleSet1 - The first style set to be concatenated.\r\n * @param styleSet2 - The second style set to be concatenated.\r\n * @param styleSet3 - The third style set to be concatenated.\r\n * @param styleSet4 - The fourth style set to be concatenated.\r\n */\r\nexport function concatStyleSets<\r\n  TStyleSet1 extends IStyleSet<TStyleSet1>,\r\n  TStyleSet2 extends IStyleSet<TStyleSet2>,\r\n  TStyleSet3 extends IStyleSet<TStyleSet3>,\r\n  TStyleSet4 extends IStyleSet<TStyleSet4>\r\n>(\r\n  styleSet1: TStyleSet1 | false | null | undefined,\r\n  styleSet2: TStyleSet2 | false | null | undefined,\r\n  styleSet3: TStyleSet3 | false | null | undefined,\r\n  styleSet4: TStyleSet3 | false | null | undefined\r\n): IConcatenatedStyleSet<TStyleSet1 & TStyleSet2 & TStyleSet3 & TStyleSet4>;\r\n\r\n/**\r\n * Combine a set of styles together (but does not register css classes).\r\n * @param styleSet1 - The first style set to be concatenated.\r\n * @param styleSet2 - The second style set to be concatenated.\r\n * @param styleSet3 - The third style set to be concatenated.\r\n * @param styleSet4 - The fourth style set to be concatenated.\r\n */\r\nexport function concatStyleSets<\r\n  TStyleSet1 extends IStyleSet<TStyleSet1>,\r\n  TStyleSet2 extends IStyleSet<TStyleSet2>,\r\n  TStyleSet3 extends IStyleSet<TStyleSet3>,\r\n  TStyleSet4 extends IStyleSet<TStyleSet4>\r\n>(\r\n  styleSet1: TStyleSet1 | false | null | undefined,\r\n  styleSet2: TStyleSet2 | false | null | undefined,\r\n  styleSet3: TStyleSet3 | false | null | undefined,\r\n  styleSet4: TStyleSet4 | false | null | undefined\r\n): IConcatenatedStyleSet<TStyleSet1 & TStyleSet2 & TStyleSet3 & TStyleSet4>;\r\n\r\n/**\r\n * Combine a set of styles together (but does not register css classes).\r\n * @param styleSet1 - The first style set to be concatenated.\r\n * @param styleSet2 - The second style set to be concatenated.\r\n * @param styleSet3 - The third style set to be concatenated.\r\n * @param styleSet4 - The fourth style set to be concatenated.\r\n * @param styleSet5 - The fifth set to be concatenated.\r\n */\r\nexport function concatStyleSets<\r\n  TStyleSet1 extends IStyleSet<TStyleSet1>,\r\n  TStyleSet2 extends IStyleSet<TStyleSet2>,\r\n  TStyleSet3 extends IStyleSet<TStyleSet3>,\r\n  TStyleSet4 extends IStyleSet<TStyleSet4>,\r\n  TStyleSet5 extends IStyleSet<TStyleSet5>\r\n>(\r\n  styleSet1: TStyleSet1 | false | null | undefined,\r\n  styleSet2: TStyleSet2 | false | null | undefined,\r\n  styleSet3: TStyleSet3 | false | null | undefined,\r\n  styleSet4: TStyleSet4 | false | null | undefined,\r\n  styleSet5: TStyleSet5 | false | null | undefined\r\n): IConcatenatedStyleSet<TStyleSet1 & TStyleSet2 & TStyleSet3 & TStyleSet4 & TStyleSet5>;\r\n\r\n/**\r\n * Combine a set of styles together (but does not register css classes).\r\n * @param styleSet1 - The first style set to be concatenated.\r\n * @param styleSet2 - The second style set to be concatenated.\r\n * @param styleSet3 - The third style set to be concatenated.\r\n * @param styleSet4 - The fourth style set to be concatenated.\r\n * @param styleSet5 - The fifth set to be concatenated.\r\n * @param styleSet6 - The sixth set to be concatenated.\r\n */\r\nexport function concatStyleSets<\r\n  TStyleSet1 extends IStyleSet<TStyleSet1>,\r\n  TStyleSet2 extends IStyleSet<TStyleSet2>,\r\n  TStyleSet3 extends IStyleSet<TStyleSet3>,\r\n  TStyleSet4 extends IStyleSet<TStyleSet4>,\r\n  TStyleSet5 extends IStyleSet<TStyleSet5>,\r\n  TStyleSet6 extends IStyleSet<TStyleSet6>\r\n>(\r\n  styleSet1: TStyleSet1 | false | null | undefined,\r\n  styleSet2: TStyleSet2 | false | null | undefined,\r\n  styleSet3: TStyleSet3 | false | null | undefined,\r\n  styleSet4: TStyleSet4 | false | null | undefined,\r\n  styleSet5: TStyleSet5 | false | null | undefined,\r\n  styleSet6: TStyleSet6 | false | null | undefined\r\n): IConcatenatedStyleSet<TStyleSet1 & TStyleSet2 & TStyleSet3 & TStyleSet4 & TStyleSet5 & TStyleSet6>;\r\n\r\n/**\r\n * Combine a set of styles together (but does not register css classes).\r\n * @param styleSets - One or more stylesets to be merged (each param can also be falsy).\r\n */\r\nexport function concatStyleSets(...styleSets: (IStyleSet<any> | false | null | undefined)[]): IConcatenatedStyleSet<any>;\r\n\r\n/**\r\n * Combine a set of styles together (but does not register css classes).\r\n * @param styleSets - One or more stylesets to be merged (each param can also be falsy).\r\n */\r\nexport function concatStyleSets(...styleSets: (IStyleSet<any> | false | null | undefined)[]): IConcatenatedStyleSet<any> {\r\n  const mergedSet: IConcatenatedStyleSet<any> = {};\r\n\r\n  // We process sub component styles in two phases. First we collect them, then we combine them into 1 style function.\r\n  const workingSubcomponentStyles: { [key: string]: Array<IStyleFunctionOrObject<any, any>> } = {};\r\n\r\n  for (const currentSet of styleSets) {\r\n    if (currentSet) {\r\n      for (const prop in currentSet) {\r\n        if (currentSet.hasOwnProperty(prop)) {\r\n          if (prop === 'subComponentStyles' && currentSet.subComponentStyles !== undefined) {\r\n            // subcomponent styles - style functions or objects\r\n\r\n            const currentComponentStyles = currentSet.subComponentStyles;\r\n            for (const subCompProp in currentComponentStyles) {\r\n              if (currentComponentStyles.hasOwnProperty(subCompProp)) {\r\n                if (workingSubcomponentStyles.hasOwnProperty(subCompProp)) {\r\n                  workingSubcomponentStyles[subCompProp].push(currentComponentStyles[subCompProp]);\r\n                } else {\r\n                  workingSubcomponentStyles[subCompProp] = [currentComponentStyles[subCompProp]];\r\n                }\r\n              }\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          // the as any casts below is a workaround for ts 2.8.\r\n          // todo: remove cast to any in ts 2.9.\r\n          const mergedValue: IStyle = (mergedSet as any)[prop];\r\n          const currentValue = (currentSet as any)[prop];\r\n\r\n          if (mergedValue === undefined) {\r\n            (mergedSet as any)[prop] = currentValue;\r\n          } else {\r\n            (mergedSet as any)[prop] = [\r\n              // https://github.com/Microsoft/TypeScript/issues/25474\r\n              ...(Array.isArray(mergedValue) ? mergedValue : [mergedValue as IStyleBase]),\r\n              ...(Array.isArray(currentValue) ? currentValue : [currentValue as IStyleBase])\r\n            ];\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (Object.keys(workingSubcomponentStyles).length > 0) {\r\n    mergedSet.subComponentStyles = {};\r\n    const mergedSubStyles = mergedSet.subComponentStyles;\r\n\r\n    // now we process the subcomponent styles if there are any\r\n    for (const subCompProp in workingSubcomponentStyles) {\r\n      if (workingSubcomponentStyles.hasOwnProperty(subCompProp)) {\r\n        const workingSet = workingSubcomponentStyles[subCompProp];\r\n        mergedSubStyles[subCompProp] = (styleProps: any) => {\r\n          return concatStyleSets(\r\n            ...workingSet.map(\r\n              (styleFunctionOrObject: IStyleFunctionOrObject<any, any>) =>\r\n                typeof styleFunctionOrObject === 'function' ? styleFunctionOrObject(styleProps) : styleFunctionOrObject\r\n            )\r\n          );\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  return mergedSet;\r\n}\r\n","import { IStyle, IStyleBaseArray } from './IStyle';\r\nimport { Stylesheet } from './Stylesheet';\r\n\r\n/**\r\n * Separates the classes and style objects. Any classes that are pre-registered\r\n * args are auto expanded into objects.\r\n */\r\nexport function extractStyleParts(\r\n  ...args: (IStyle | IStyle[] | false | null | undefined)[]\r\n): { classes: string[]; objects: IStyleBaseArray } {\r\n  const classes: string[] = [];\r\n  const objects: {}[] = [];\r\n  const stylesheet = Stylesheet.getInstance();\r\n\r\n  function _processArgs(argsList: (IStyle | IStyle[])[]): void {\r\n    for (const arg of argsList) {\r\n      if (arg) {\r\n        if (typeof arg === 'string') {\r\n          if (arg.indexOf(' ') >= 0) {\r\n            _processArgs(arg.split(' '));\r\n          } else {\r\n            const translatedArgs = stylesheet.argsFromClassName(arg);\r\n\r\n            if (translatedArgs) {\r\n              _processArgs(translatedArgs);\r\n            } else {\r\n              // Avoid adding the same class twice.\r\n              if (classes.indexOf(arg) === -1) {\r\n                classes.push(arg);\r\n              }\r\n            }\r\n          }\r\n        } else if (Array.isArray(arg)) {\r\n          _processArgs(arg);\r\n        } else if (typeof arg === 'object') {\r\n          objects.push(arg);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  _processArgs(args);\r\n\r\n  return {\r\n    classes,\r\n    objects\r\n  };\r\n}\r\n","import { Stylesheet } from './Stylesheet';\r\nimport { IFontFace } from './IRawStyleBase';\r\nimport { serializeRuleEntries } from './styleToClassName';\r\n\r\n/**\r\n * Registers a font face.\r\n * @public\r\n */\r\nexport function fontFace(font: IFontFace): void {\r\n  Stylesheet.getInstance().insertRule(`@font-face{${serializeRuleEntries(font as {})}}`, true);\r\n}\r\n","export interface IVendorSettings {\r\n  isWebkit?: boolean;\r\n  isMoz?: boolean;\r\n  isMs?: boolean;\r\n  isOpera?: boolean;\r\n}\r\n\r\nlet _vendorSettings: IVendorSettings | undefined;\r\n\r\nexport function getVendorSettings(): IVendorSettings {\r\n  if (!_vendorSettings) {\r\n    const doc = typeof document !== 'undefined' ? document : undefined;\r\n    const nav = typeof navigator !== 'undefined' ? navigator : undefined;\r\n    const userAgent = nav ? nav.userAgent.toLowerCase() : undefined;\r\n\r\n    if (!doc) {\r\n      _vendorSettings = {\r\n        isWebkit: true,\r\n        isMoz: true,\r\n        isOpera: true,\r\n        isMs: true\r\n      };\r\n    } else {\r\n      _vendorSettings = {\r\n        isWebkit: !!(doc && 'WebkitAppearance' in doc.documentElement.style),\r\n        isMoz: !!(userAgent && userAgent.indexOf('firefox') > -1),\r\n        isOpera: !!(userAgent && userAgent.indexOf('opera') > -1),\r\n        isMs: !!(nav && (/rv:11.0/i.test(nav.userAgent) || /Edge\\/\\d./i.test(navigator.userAgent)))\r\n      };\r\n    }\r\n  }\r\n\r\n  return _vendorSettings;\r\n}\r\n\r\n/**\r\n * Sets the vendor settings for prefixing and vendor specific operations.\r\n */\r\nexport function setVendorSettings(vendorSettings?: IVendorSettings): void {\r\n  _vendorSettings = vendorSettings;\r\n}\r\n","import { Stylesheet } from './Stylesheet';\r\nimport { serializeRuleEntries } from './styleToClassName';\r\n\r\n/**\r\n * Registers keyframe definitions.\r\n *\r\n * @public\r\n */\r\nexport function keyframes(timeline: { [key: string]: {} }): string {\r\n  const stylesheet = Stylesheet.getInstance();\r\n  const name = stylesheet.getClassName();\r\n\r\n  const rulesArray: string[] = [];\r\n\r\n  for (const prop in timeline) {\r\n    if (timeline.hasOwnProperty(prop)) {\r\n      rulesArray.push(prop, '{', serializeRuleEntries(timeline[prop]), '}');\r\n    }\r\n  }\r\n  const rules = rulesArray.join('');\r\n\r\n  stylesheet.insertRule(`@keyframes ${name}{${rules}}`, true);\r\n\r\n  stylesheet.cacheClassName(name, rules, [], ['keyframes', rules]);\r\n\r\n  return name;\r\n}\r\n","import { extractStyleParts } from './extractStyleParts';\r\nimport { concatStyleSets } from './concatStyleSets';\r\nimport { IStyle } from './IStyle';\r\nimport { styleToRegistration, applyRegistration } from './styleToClassName';\r\nimport { IStyleSet, IProcessedStyleSet, IConcatenatedStyleSet } from './IStyleSet';\r\n\r\n/**\r\n * Takes in one or more style set objects, each consisting of a set of areas,\r\n * each which will produce a class name. Using this is analogous to calling\r\n * `mergeStyles` for each property in the object, but ensures we maintain the\r\n * set ordering when multiple style sets are merged.\r\n *\r\n * @param styleSet - The first style set to be merged and reigstered.\r\n */\r\nexport function mergeStyleSets<TStyleSet extends IStyleSet<TStyleSet>>(\r\n  styleSet: TStyleSet | false | null | undefined\r\n): IProcessedStyleSet<TStyleSet>;\r\n\r\n/**\r\n * Takes in one or more style set objects, each consisting of a set of areas,\r\n * each which will produce a class name. Using this is analogous to calling\r\n * `mergeStyles` for each property in the object, but ensures we maintain the\r\n * set ordering when multiple style sets are merged.\r\n *\r\n * @param styleSet1 - The first style set to be merged.\r\n * @param styleSet2 - The second style set to be merged.\r\n */\r\nexport function mergeStyleSets<TStyleSet1 extends IStyleSet<TStyleSet1>, TStyleSet2 extends IStyleSet<TStyleSet2>>(\r\n  styleSet1: TStyleSet1 | false | null | undefined,\r\n  styleSet2: TStyleSet2 | false | null | undefined\r\n): IProcessedStyleSet<TStyleSet1 & TStyleSet2>;\r\n\r\n/**\r\n * Takes in one or more style set objects, each consisting of a set of areas,\r\n * each which will produce a class name. Using this is analogous to calling\r\n * `mergeStyles` for each property in the object, but ensures we maintain the\r\n * set ordering when multiple style sets are merged.\r\n *\r\n * @param styleSet1 - The first style set to be merged.\r\n * @param styleSet2 - The second style set to be merged.\r\n * @param styleSet3 - The third style set to be merged.\r\n */\r\nexport function mergeStyleSets<\r\n  TStyleSet1 extends IStyleSet<TStyleSet1>,\r\n  TStyleSet2 extends IStyleSet<TStyleSet2>,\r\n  TStyleSet3 extends IStyleSet<TStyleSet3>\r\n>(\r\n  styleSet1: TStyleSet1 | false | null | undefined,\r\n  styleSet2: TStyleSet2 | false | null | undefined,\r\n  styleSet3: TStyleSet3 | false | null | undefined\r\n): IProcessedStyleSet<TStyleSet1 & TStyleSet2 & TStyleSet3>;\r\n\r\n/**\r\n * Takes in one or more style set objects, each consisting of a set of areas,\r\n * each which will produce a class name. Using this is analogous to calling\r\n * `mergeStyles` for each property in the object, but ensures we maintain the\r\n * set ordering when multiple style sets are merged.\r\n *\r\n * @param styleSet1 - The first style set to be merged.\r\n * @param styleSet2 - The second style set to be merged.\r\n * @param styleSet3 - The third style set to be merged.\r\n * @param styleSet4 - The fourth style set to be merged.\r\n */\r\nexport function mergeStyleSets<\r\n  TStyleSet1 extends IStyleSet<TStyleSet1>,\r\n  TStyleSet2 extends IStyleSet<TStyleSet2>,\r\n  TStyleSet3 extends IStyleSet<TStyleSet3>,\r\n  TStyleSet4 extends IStyleSet<TStyleSet4>\r\n>(\r\n  styleSet1: TStyleSet1 | false | null | undefined,\r\n  styleSet2: TStyleSet2 | false | null | undefined,\r\n  styleSet3: TStyleSet3 | false | null | undefined,\r\n  styleSet4: TStyleSet4 | false | null | undefined\r\n): IProcessedStyleSet<TStyleSet1 & TStyleSet2 & TStyleSet3 & TStyleSet4>;\r\n\r\n/**\r\n * Takes in one or more style set objects, each consisting of a set of areas,\r\n * each which will produce a class name. Using this is analogous to calling\r\n * `mergeStyles` for each property in the object, but ensures we maintain the\r\n * set ordering when multiple style sets are merged.\r\n *\r\n * @param styleSets - One or more style sets to be merged.\r\n */\r\nexport function mergeStyleSets(...styleSets: Array<IStyleSet<any> | undefined | false | null>): IProcessedStyleSet<any>;\r\n\r\n/**\r\n * Takes in one or more style set objects, each consisting of a set of areas,\r\n * each which will produce a class name. Using this is analogous to calling\r\n * `mergeStyles` for each property in the object, but ensures we maintain the\r\n * set ordering when multiple style sets are merged.\r\n *\r\n * @param styleSets - One or more style sets to be merged.\r\n */\r\nexport function mergeStyleSets(...styleSets: Array<IStyleSet<any> | undefined | false | null>): IProcessedStyleSet<any> {\r\n  // tslint:disable-next-line:no-any\r\n  const classNameSet: IProcessedStyleSet<any> = { subComponentStyles: {} };\r\n  const classMap: { [key: string]: string } = {};\r\n\r\n  const styleSet = styleSets[0];\r\n\r\n  if (!styleSet && styleSets.length <= 1) {\r\n    return { subComponentStyles: {} };\r\n  }\r\n\r\n  let concatenatedStyleSet: IConcatenatedStyleSet<any> | IStyleSet<any> =\r\n    // we have guarded against falsey values just above.\r\n    styleSet!;\r\n\r\n  concatenatedStyleSet = concatStyleSets(...styleSets);\r\n\r\n  const registrations = [];\r\n\r\n  for (const styleSetArea in concatenatedStyleSet) {\r\n    if (concatenatedStyleSet.hasOwnProperty(styleSetArea)) {\r\n      if (styleSetArea === 'subComponentStyles') {\r\n        classNameSet.subComponentStyles = (concatenatedStyleSet as IConcatenatedStyleSet<any>).subComponentStyles || {};\r\n        continue;\r\n      }\r\n\r\n      const styles: IStyle = (concatenatedStyleSet as any)[styleSetArea];\r\n\r\n      const { classes, objects } = extractStyleParts(styles);\r\n      const registration = styleToRegistration({ displayName: styleSetArea }, objects);\r\n\r\n      registrations.push(registration);\r\n\r\n      if (registration) {\r\n        classMap[styleSetArea] = registration.className;\r\n        // as any cast not needed in ts >=2.9\r\n        (classNameSet as any)[styleSetArea] = classes.concat([registration.className]).join(' ');\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const registration of registrations) {\r\n    if (registration) {\r\n      applyRegistration(registration, classMap);\r\n    }\r\n  }\r\n\r\n  return classNameSet;\r\n}\r\n","import { IStyle, IStyleBaseArray } from './IStyle';\r\nimport { styleToClassName } from './styleToClassName';\r\nimport { extractStyleParts } from './extractStyleParts';\r\n\r\n/**\r\n * Concatination helper, which can merge class names together. Skips over falsey values.\r\n *\r\n * @public\r\n */\r\nexport function mergeStyles(...args: (IStyle | IStyleBaseArray | false | null | undefined)[]): string {\r\n  const { classes, objects } = extractStyleParts(args);\r\n\r\n  if (objects.length) {\r\n    classes.push(styleToClassName(objects));\r\n  }\r\n\r\n  return classes.join(' ');\r\n}\r\n","import { IRawStyle, IStyle } from './IStyle';\r\n\r\nimport { Stylesheet } from './Stylesheet';\r\nimport { kebabRules } from './transforms/kebabRules';\r\nimport { prefixRules } from './transforms/prefixRules';\r\nimport { provideUnits } from './transforms/provideUnits';\r\nimport { rtlifyRules } from './transforms/rtlifyRules';\r\n\r\nconst DISPLAY_NAME = 'displayName';\r\n\r\n// tslint:disable-next-line:no-any\r\ntype IDictionary = { [key: string]: any };\r\n\r\ninterface IRuleSet {\r\n  __order: string[];\r\n  [key: string]: IDictionary;\r\n}\r\n\r\nfunction getDisplayName(rules?: { [key: string]: IRawStyle }): string | undefined {\r\n  const rootStyle: IStyle = rules && rules['&'];\r\n\r\n  return rootStyle ? (rootStyle as IRawStyle).displayName : undefined;\r\n}\r\n\r\nconst globalSelectorRegExp = /\\:global\\((.+?)\\)/g;\r\n\r\ntype ReplacementInfo = [number, number, string];\r\n\r\n/**\r\n * Finds comma separated selectors in a :global() e.g. \":global(.class1, .class2, .class3)\"\r\n * and wraps them each in their own global \":global(.class1), :global(.class2), :global(.class3)\"\r\n *\r\n * @param selectorWithGlobals The selector to process\r\n * @returns The updated selector\r\n */\r\nfunction expandCommaSeparatedGlobals(selectorWithGlobals: string): string {\r\n  // We the selector does not have a :global() we can shortcut\r\n  if (!globalSelectorRegExp.test(selectorWithGlobals)) {\r\n    return selectorWithGlobals;\r\n  }\r\n\r\n  const replacementInfo: ReplacementInfo[] = [];\r\n\r\n  const findGlobal = /\\:global\\((.+?)\\)/g;\r\n  let match = null;\r\n  // Create a result list for global selectors so we can replace them.\r\n  while ((match = findGlobal.exec(selectorWithGlobals))) {\r\n    // Only if the found selector is a comma separated list we'll process it.\r\n    if (match[1].indexOf(',') > -1) {\r\n      replacementInfo.push([\r\n        match.index,\r\n        match.index + match[0].length,\r\n        // Wrap each of the found selectors in :global()\r\n        match[1]\r\n          .split(',')\r\n          .map((v: string) => `:global(${v.trim()})`)\r\n          .join(', ')\r\n      ]);\r\n    }\r\n  }\r\n\r\n  // Replace the found selectors with their wrapped variants in reverse order\r\n  return replacementInfo.reverse().reduce((selector: string, [matchIndex, matchEndIndex, replacement]: ReplacementInfo) => {\r\n    const prefix = selector.slice(0, matchIndex);\r\n    const suffix = selector.slice(matchEndIndex);\r\n\r\n    return prefix + replacement + suffix;\r\n  }, selectorWithGlobals);\r\n}\r\n\r\nfunction expandSelector(newSelector: string, currentSelector: string): string {\r\n  if (newSelector.indexOf(':global(') >= 0) {\r\n    return newSelector.replace(globalSelectorRegExp, '$1');\r\n  } else if (newSelector.indexOf(':') === 0) {\r\n    return currentSelector + newSelector;\r\n  } else if (newSelector.indexOf('&') < 0) {\r\n    return currentSelector + ' ' + newSelector;\r\n  }\r\n\r\n  return newSelector;\r\n}\r\n\r\nfunction extractRules(args: IStyle[], rules: IRuleSet = { __order: [] }, currentSelector: string = '&'): IRuleSet {\r\n  const stylesheet = Stylesheet.getInstance();\r\n  let currentRules: IDictionary | undefined = rules[currentSelector] as IDictionary;\r\n\r\n  if (!currentRules) {\r\n    currentRules = {};\r\n    rules[currentSelector] = currentRules;\r\n    rules.__order.push(currentSelector);\r\n  }\r\n\r\n  for (const arg of args) {\r\n    // If the arg is a string, we need to look up the class map and merge.\r\n    if (typeof arg === 'string') {\r\n      const expandedRules = stylesheet.argsFromClassName(arg);\r\n\r\n      if (expandedRules) {\r\n        extractRules(expandedRules, rules, currentSelector);\r\n      }\r\n      // Else if the arg is an array, we need to recurse in.\r\n    } else if (Array.isArray(arg)) {\r\n      extractRules(arg, rules, currentSelector);\r\n    } else {\r\n      // tslint:disable-next-line:no-any\r\n      for (const prop in arg as any) {\r\n        if (prop === 'selectors') {\r\n          // tslint:disable-next-line:no-any\r\n          const selectors: { [key: string]: IStyle } = (arg as any).selectors;\r\n\r\n          for (let newSelector in selectors) {\r\n            if (selectors.hasOwnProperty(newSelector)) {\r\n              const selectorValue = selectors[newSelector];\r\n\r\n              if (newSelector.indexOf('@') === 0) {\r\n                newSelector = newSelector + '{' + currentSelector;\r\n                extractRules([selectorValue], rules, newSelector);\r\n              } else if (newSelector.indexOf(',') > -1) {\r\n                const commaSeparatedSelectors = expandCommaSeparatedGlobals(newSelector)\r\n                  .split(/,/g)\r\n                  .map((s: string) => s.trim());\r\n                extractRules(\r\n                  [selectorValue],\r\n                  rules,\r\n                  commaSeparatedSelectors\r\n                    .map((commaSeparatedSelector: string) => expandSelector(commaSeparatedSelector, currentSelector))\r\n                    .join(', ')\r\n                );\r\n              } else {\r\n                extractRules([selectorValue], rules, expandSelector(newSelector, currentSelector));\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          if ((arg as any)[prop] !== undefined) {\r\n            // Else, add the rule to the currentSelector.\r\n            if (prop === 'margin' || prop === 'padding') {\r\n              // tslint:disable-next-line:no-any\r\n              expandQuads(currentRules, prop, (arg as any)[prop]);\r\n            } else {\r\n              // tslint:disable-next-line:no-any\r\n              (currentRules as any)[prop] = (arg as any)[prop] as any;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return rules;\r\n}\r\n\r\nfunction expandQuads(currentRules: IDictionary, name: string, value: string): void {\r\n  const parts = typeof value === 'string' ? value.split(' ') : [value];\r\n\r\n  currentRules[name + 'Top'] = parts[0];\r\n  currentRules[name + 'Right'] = parts[1] || parts[0];\r\n  currentRules[name + 'Bottom'] = parts[2] || parts[0];\r\n  currentRules[name + 'Left'] = parts[3] || parts[1] || parts[0];\r\n}\r\n\r\nfunction getKeyForRules(rules: IRuleSet): string | undefined {\r\n  const serialized: string[] = [];\r\n  let hasProps = false;\r\n\r\n  for (const selector of rules.__order) {\r\n    serialized.push(selector);\r\n    const rulesForSelector = rules[selector];\r\n\r\n    for (const propName in rulesForSelector) {\r\n      if (rulesForSelector.hasOwnProperty(propName) && rulesForSelector[propName] !== undefined) {\r\n        hasProps = true;\r\n        serialized.push(propName, rulesForSelector[propName]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return hasProps ? serialized.join('') : undefined;\r\n}\r\n\r\nexport function serializeRuleEntries(ruleEntries: { [key: string]: string | number }): string {\r\n  if (!ruleEntries) {\r\n    return '';\r\n  }\r\n\r\n  const allEntries: (string | number)[] = [];\r\n\r\n  for (const entry in ruleEntries) {\r\n    if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME && ruleEntries[entry] !== undefined) {\r\n      allEntries.push(entry, ruleEntries[entry]);\r\n    }\r\n  }\r\n\r\n  // Apply transforms.\r\n  for (let i = 0; i < allEntries.length; i += 2) {\r\n    kebabRules(allEntries, i);\r\n    provideUnits(allEntries, i);\r\n    rtlifyRules(allEntries, i);\r\n    prefixRules(allEntries, i);\r\n  }\r\n\r\n  // Apply punctuation.\r\n  for (let i = 1; i < allEntries.length; i += 4) {\r\n    allEntries.splice(i, 1, ':', allEntries[i], ';');\r\n  }\r\n\r\n  return allEntries.join('');\r\n}\r\n\r\nexport interface IRegistration {\r\n  className: string;\r\n  key: string;\r\n  args: IStyle[];\r\n  rulesToInsert: string[];\r\n}\r\n\r\nexport function styleToRegistration(...args: IStyle[]): IRegistration | undefined {\r\n  const rules: IRuleSet = extractRules(args);\r\n  const key = getKeyForRules(rules);\r\n\r\n  if (key) {\r\n    const stylesheet = Stylesheet.getInstance();\r\n    const registration: Partial<IRegistration> = {\r\n      className: stylesheet.classNameFromKey(key),\r\n      key,\r\n      args\r\n    };\r\n\r\n    if (!registration.className) {\r\n      registration.className = stylesheet.getClassName(getDisplayName(rules));\r\n      const rulesToInsert: string[] = [];\r\n\r\n      for (const selector of rules.__order) {\r\n        rulesToInsert.push(selector, serializeRuleEntries(rules[selector]));\r\n      }\r\n      registration.rulesToInsert = rulesToInsert;\r\n    }\r\n\r\n    return registration as IRegistration;\r\n  }\r\n}\r\n\r\nexport function applyRegistration(registration: IRegistration, classMap?: { [key: string]: string }): void {\r\n  const stylesheet = Stylesheet.getInstance();\r\n  const { className, key, args, rulesToInsert } = registration;\r\n\r\n  if (rulesToInsert) {\r\n    // rulesToInsert is an ordered array of selector/rule pairs.\r\n    for (let i = 0; i < rulesToInsert.length; i += 2) {\r\n      const rules = rulesToInsert[i + 1];\r\n      if (rules) {\r\n        let selector = rulesToInsert[i];\r\n\r\n        // Fix selector using map.\r\n        selector = selector.replace(\r\n          /(&)|\\$([\\w-]+)\\b/g,\r\n          (match: string, amp: string, cn: string): string => {\r\n            if (amp) {\r\n              return '.' + registration.className;\r\n            } else if (cn) {\r\n              return '.' + ((classMap && classMap[cn]) || cn);\r\n            }\r\n            return '';\r\n          }\r\n        );\r\n\r\n        // Insert. Note if a media query, we must close the query with a final bracket.\r\n        const processedRule = `${selector}{${rules}}${selector.indexOf('@') === 0 ? '}' : ''}`;\r\n\r\n        stylesheet.insertRule(processedRule);\r\n      }\r\n    }\r\n    stylesheet.cacheClassName(className!, key!, args!, rulesToInsert);\r\n  }\r\n}\r\n\r\nexport function styleToClassName(...args: IStyle[]): string {\r\n  const registration = styleToRegistration(...args);\r\n  if (registration) {\r\n    applyRegistration(registration);\r\n\r\n    return registration.className;\r\n  }\r\n\r\n  return '';\r\n}\r\n","export function kebabRules(rulePairs: (string | number)[], index: number): void {\r\n  rulePairs[index] = (rulePairs[index] as string).replace(/([A-Z])/g, '-$1').toLowerCase();\r\n}\r\n","import { getVendorSettings } from '../getVendorSettings';\r\n\r\nconst autoPrefixNames: { [key: string]: number } = {\r\n  'user-select': 1\r\n};\r\n\r\nexport function prefixRules(rulePairs: (string | number)[], index: number): void {\r\n  const vendorSettings = getVendorSettings();\r\n\r\n  const name = rulePairs[index];\r\n\r\n  if (autoPrefixNames[name]) {\r\n    const value = rulePairs[index + 1];\r\n\r\n    if (autoPrefixNames[name]) {\r\n      if (vendorSettings.isWebkit) {\r\n        rulePairs.push('-webkit-' + name, value);\r\n      }\r\n      if (vendorSettings.isMoz) {\r\n        rulePairs.push('-moz-' + name, value);\r\n      }\r\n      if (vendorSettings.isMs) {\r\n        rulePairs.push('-ms-' + name, value);\r\n      }\r\n      if (vendorSettings.isOpera) {\r\n        rulePairs.push('-o-' + name, value);\r\n      }\r\n    }\r\n  }\r\n}\r\n","const NON_PIXEL_NUMBER_PROPS = [\r\n  'column-count',\r\n  'font-weight',\r\n  'flex-basis',\r\n  'flex',\r\n  'flex-grow',\r\n  'flex-shrink',\r\n  'fill-opacity',\r\n  'opacity',\r\n  'order',\r\n  'z-index',\r\n  'zoom'\r\n];\r\n\r\nexport function provideUnits(rulePairs: (string | number)[], index: number): void {\r\n  const name = rulePairs[index];\r\n  const value = rulePairs[index + 1];\r\n\r\n  if (typeof value === 'number') {\r\n    const unit = NON_PIXEL_NUMBER_PROPS.indexOf(name as string) === -1 ? 'px' : '';\r\n\r\n    rulePairs[index + 1] = `${value}${unit}`;\r\n  }\r\n}\r\n","import { Stylesheet } from '../Stylesheet';\r\n\r\nconst LEFT = 'left';\r\nconst RIGHT = 'right';\r\nconst NO_FLIP = '@noflip';\r\nconst NAME_REPLACEMENTS: { [key: string]: string } = {\r\n  [LEFT]: RIGHT,\r\n  [RIGHT]: LEFT\r\n};\r\nconst VALUE_REPLACEMENTS: { [key: string]: string } = {\r\n  'w-resize': 'e-resize',\r\n  'sw-resize': 'se-resize',\r\n  'nw-resize': 'ne-resize'\r\n};\r\n\r\nlet _rtl = getRTL();\r\n\r\n/**\r\n * Sets the current RTL value.\r\n */\r\nexport function setRTL(isRTL: boolean): void {\r\n  if (_rtl !== isRTL) {\r\n    Stylesheet.getInstance().resetKeys();\r\n    _rtl = isRTL;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets the current RTL value.\r\n */\r\nexport function getRTL(): boolean {\r\n  if (_rtl === undefined) {\r\n    _rtl = typeof document !== 'undefined' && !!document.documentElement && document.documentElement.getAttribute('dir') === 'rtl';\r\n  }\r\n  return _rtl;\r\n}\r\n\r\n/**\r\n * RTLifies the rulePair in the array at the current index. This mutates the array for performance\r\n * reasons.\r\n */\r\nexport function rtlifyRules(rulePairs: (string | number)[], index: number): void {\r\n  if (getRTL()) {\r\n    const name = rulePairs[index] as string;\r\n\r\n    if (!name) {\r\n      return;\r\n    }\r\n\r\n    const value = rulePairs[index + 1] as string;\r\n\r\n    if (typeof value === 'string' && value.indexOf(NO_FLIP) >= 0) {\r\n      rulePairs[index + 1] = value.replace(/\\s*(?:\\/\\*\\s*)?\\@noflip\\b(?:\\s*\\*\\/)?\\s*?/g, '');\r\n    } else if (name.indexOf(LEFT) >= 0) {\r\n      rulePairs[index] = name.replace(LEFT, RIGHT);\r\n    } else if (name.indexOf(RIGHT) >= 0) {\r\n      rulePairs[index] = name.replace(RIGHT, LEFT);\r\n    } else if (String(value).indexOf(LEFT) >= 0) {\r\n      rulePairs[index + 1] = value.replace(LEFT, RIGHT);\r\n    } else if (String(value).indexOf(RIGHT) >= 0) {\r\n      rulePairs[index + 1] = value.replace(RIGHT, LEFT);\r\n    } else if (NAME_REPLACEMENTS[name]) {\r\n      rulePairs[index] = NAME_REPLACEMENTS[name];\r\n    } else if (VALUE_REPLACEMENTS[value]) {\r\n      rulePairs[index + 1] = VALUE_REPLACEMENTS[value];\r\n    } else {\r\n      switch (name) {\r\n        case 'margin':\r\n        case 'padding':\r\n          rulePairs[index + 1] = flipQuad(value);\r\n          break;\r\n        case 'box-shadow':\r\n          rulePairs[index + 1] = negateNum(value, 0);\r\n          break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Given a string value in a space delimited format (e.g. \"1 2 3 4\"), negates a particular value.\r\n */\r\nfunction negateNum(value: string, partIndex: number): string {\r\n  const parts = value.split(' ');\r\n  const numberVal = parseInt(parts[partIndex], 10);\r\n\r\n  parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));\r\n\r\n  return parts.join(' ');\r\n}\r\n\r\n/**\r\n * Given a string quad, flips the left and right values.\r\n */\r\nfunction flipQuad(value: string): string {\r\n  if (typeof value === 'string') {\r\n    const parts = value.split(' ');\r\n\r\n    if (parts.length === 4) {\r\n      return `${parts[0]} ${parts[3]} ${parts[2]} ${parts[1]}`;\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n","// @uifabric/merge-styles@6.16.4\n  // Do not modify this file, the file is generated as part of publish. The checked in version is a placeholder only.\n  import { setVersion } from '@uifabric/set-version';\n  setVersion('@uifabric/merge-styles', '6.16.4');"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACzLA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;;;;;;;;;ACHA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACbA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AAgCA;AAEA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AAgCA;AA7BA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAqBA;AAMA;AAzBA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAWA;;AAEA;AACA;AACA;AAIA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;;;;;;;;;;AC1IA;AAAA;AAAA;;;AAGA;AACA;AAAA;AAAA;AAAA;;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAGA;AACA;AACA;AAbA;AACA;AAAA;AAYA;AACA;AAEA;AACA;;;;;;;;;ACvMA;AAAA;AAAA;AAAA;AAEA;;;AAGA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;AC/CA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;;;AAGA;AACA;AACA;AACA;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;;;ANhCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;;;;;;;;;AOtBA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAkFA;;;;;;;AAOA;AACA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;AC5IA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;;;;AAIA;AACA;AAAA;AAAA;AAAA;;AACA;AAEA;AACA;AACA;AAEA;AACA;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAUA;AACA;AAEA;AACA;AAEA;AAIA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AASA;AAAA;AAAA;AAAA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;;;;;;;;AC7RA;AAAA;AAAA;AACA;AACA;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC7BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;ACxGA;AAAA;AAAA;AACA;AACA;AACA;;;;;A","sourceRoot":""}