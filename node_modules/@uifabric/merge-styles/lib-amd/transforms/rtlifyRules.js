define(["require", "exports", "../Stylesheet"], function (require, exports, Stylesheet_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LEFT = 'left';
    var RIGHT = 'right';
    var NO_FLIP = '@noflip';
    var NAME_REPLACEMENTS = (_a = {},
        _a[LEFT] = RIGHT,
        _a[RIGHT] = LEFT,
        _a);
    var VALUE_REPLACEMENTS = {
        'w-resize': 'e-resize',
        'sw-resize': 'se-resize',
        'nw-resize': 'ne-resize'
    };
    var _rtl = getRTL();
    /**
     * Sets the current RTL value.
     */
    function setRTL(isRTL) {
        if (_rtl !== isRTL) {
            Stylesheet_1.Stylesheet.getInstance().resetKeys();
            _rtl = isRTL;
        }
    }
    exports.setRTL = setRTL;
    /**
     * Gets the current RTL value.
     */
    function getRTL() {
        if (_rtl === undefined) {
            _rtl = typeof document !== 'undefined' && !!document.documentElement && document.documentElement.getAttribute('dir') === 'rtl';
        }
        return _rtl;
    }
    exports.getRTL = getRTL;
    /**
     * RTLifies the rulePair in the array at the current index. This mutates the array for performance
     * reasons.
     */
    function rtlifyRules(rulePairs, index) {
        if (getRTL()) {
            var name_1 = rulePairs[index];
            if (!name_1) {
                return;
            }
            var value = rulePairs[index + 1];
            if (typeof value === 'string' && value.indexOf(NO_FLIP) >= 0) {
                rulePairs[index + 1] = value.replace(/\s*(?:\/\*\s*)?\@noflip\b(?:\s*\*\/)?\s*?/g, '');
            }
            else if (name_1.indexOf(LEFT) >= 0) {
                rulePairs[index] = name_1.replace(LEFT, RIGHT);
            }
            else if (name_1.indexOf(RIGHT) >= 0) {
                rulePairs[index] = name_1.replace(RIGHT, LEFT);
            }
            else if (String(value).indexOf(LEFT) >= 0) {
                rulePairs[index + 1] = value.replace(LEFT, RIGHT);
            }
            else if (String(value).indexOf(RIGHT) >= 0) {
                rulePairs[index + 1] = value.replace(RIGHT, LEFT);
            }
            else if (NAME_REPLACEMENTS[name_1]) {
                rulePairs[index] = NAME_REPLACEMENTS[name_1];
            }
            else if (VALUE_REPLACEMENTS[value]) {
                rulePairs[index + 1] = VALUE_REPLACEMENTS[value];
            }
            else {
                switch (name_1) {
                    case 'margin':
                    case 'padding':
                        rulePairs[index + 1] = flipQuad(value);
                        break;
                    case 'box-shadow':
                        rulePairs[index + 1] = negateNum(value, 0);
                        break;
                }
            }
        }
    }
    exports.rtlifyRules = rtlifyRules;
    /**
     * Given a string value in a space delimited format (e.g. "1 2 3 4"), negates a particular value.
     */
    function negateNum(value, partIndex) {
        var parts = value.split(' ');
        var numberVal = parseInt(parts[partIndex], 10);
        parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));
        return parts.join(' ');
    }
    /**
     * Given a string quad, flips the left and right values.
     */
    function flipQuad(value) {
        if (typeof value === 'string') {
            var parts = value.split(' ');
            if (parts.length === 4) {
                return parts[0] + " " + parts[3] + " " + parts[2] + " " + parts[1];
            }
        }
        return value;
    }
    var _a;
});
//# sourceMappingURL=rtlifyRules.js.map