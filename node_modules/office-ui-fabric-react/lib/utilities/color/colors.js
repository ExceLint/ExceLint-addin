import * as tslib_1 from "tslib";
import { COLOR_VALUES } from './colorValues';
export var MAX_COLOR_SATURATION = 100;
export var MAX_COLOR_HUE = 359;
export var MAX_COLOR_VALUE = 100;
export var MAX_COLOR_RGB = 255;
/** @deprecated Use MAX_COLOR_RGB (255) or MAX_COLOR_ALPHA (100) */
export var MAX_COLOR_RGBA = MAX_COLOR_RGB;
export var MAX_COLOR_ALPHA = 100;
/**
 * Converts a valid CSS color string to an RGB color.
 * Note that hex colors *must* be prefixed with # to be considered valid.
 * Alpha in returned color defaults to 100.
 */
export function cssColor(color) {
    if (!color) {
        return undefined;
    }
    return _named(color) || _hex3(color) || _hex6(color) || _rgba(color) || _hsla(color);
}
/** Converts RGB components to a hex color string (without # prefix). */
export function rgb2hex(r, g, b) {
    return [_rgbToPaddedHex(r), _rgbToPaddedHex(g), _rgbToPaddedHex(b)].join('');
}
/** Converts HSV components to a hex color string (without # prefix). */
export function hsv2hex(h, s, v) {
    var _a = hsv2rgb(h, s, v), r = _a.r, g = _a.g, b = _a.b;
    return rgb2hex(r, g, b);
}
/** Converts RGB components to an HSV color. */
export function rgb2hsv(r, g, b) {
    var h = NaN;
    var s;
    var v;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var delta = max - min;
    // hue
    if (delta === 0) {
        h = 0;
    }
    else if (r === max) {
        h = ((g - b) / delta) % 6;
    }
    else if (g === max) {
        h = (b - r) / delta + 2;
    }
    else if (b === max) {
        h = (r - g) / delta + 4;
    }
    h = Math.round(h * 60);
    if (h < 0) {
        h += 360;
    }
    // saturation
    s = Math.round((max === 0 ? 0 : delta / max) * 100);
    // value
    v = Math.round((max / MAX_COLOR_RGB) * 100);
    return { h: h, s: s, v: v };
}
/** Converts HSL components to an HSV color. */
export function hsl2hsv(h, s, l) {
    s *= (l < 50 ? l : 100 - l) / 100;
    var v = l + s;
    return {
        h: h,
        s: v === 0 ? 0 : ((2 * s) / v) * 100,
        v: v
    };
}
/** Converts HSV components to an HSL color. */
export function hsv2hsl(h, s, v) {
    s /= MAX_COLOR_SATURATION;
    v /= MAX_COLOR_VALUE;
    var l = (2 - s) * v;
    var sl = s * v;
    sl /= l <= 1 ? l : 2 - l;
    sl = sl || 0;
    l /= 2;
    return { h: h, s: sl * 100, l: l * 100 };
}
/** Converts HSL components to an RGB color. Does not set the alpha value. */
export function hsl2rgb(h, s, l) {
    var hsv = hsl2hsv(h, s, l);
    return hsv2rgb(hsv.h, hsv.s, hsv.v);
}
/** Converts HSV components to an RGB color. Does not set the alpha value. */
export function hsv2rgb(h, s, v) {
    s = s / 100;
    v = v / 100;
    var rgb = [];
    var c = v * s;
    var hh = h / 60;
    var x = c * (1 - Math.abs((hh % 2) - 1));
    var m = v - c;
    switch (Math.floor(hh)) {
        case 0:
            rgb = [c, x, 0];
            break;
        case 1:
            rgb = [x, c, 0];
            break;
        case 2:
            rgb = [0, c, x];
            break;
        case 3:
            rgb = [0, x, c];
            break;
        case 4:
            rgb = [x, 0, c];
            break;
        case 5:
            rgb = [c, 0, x];
            break;
    }
    return {
        r: Math.round(MAX_COLOR_RGB * (rgb[0] + m)),
        g: Math.round(MAX_COLOR_RGB * (rgb[1] + m)),
        b: Math.round(MAX_COLOR_RGB * (rgb[2] + m))
    };
}
/**
 * Converts a CSS color string to a color object.
 * Note that hex colors *must* be prefixed with # to be considered valid.
 *
 * `inputColor` will be used unmodified as the `str` property of the returned object.
 * Alpha defaults to 100 if not specified in `inputColor`.
 * Returns undefined if the color string is invalid/not recognized.
 */
export function getColorFromString(inputColor) {
    var color = cssColor(inputColor);
    if (!color) {
        return;
    }
    return tslib_1.__assign({}, getColorFromRGBA(color), { str: inputColor });
}
/** Converts an RGBA color to a color object (alpha defaults to 100). */
export function getColorFromRGBA(rgba) {
    var _a = rgba.a, a = _a === void 0 ? MAX_COLOR_ALPHA : _a, b = rgba.b, g = rgba.g, r = rgba.r;
    var _b = rgb2hsv(r, g, b), h = _b.h, s = _b.s, v = _b.v;
    var hex = rgb2hex(r, g, b);
    var str = _rgbaOrHexString(r, g, b, a, hex);
    return { a: a, b: b, g: g, h: h, hex: hex, r: r, s: s, str: str, v: v };
}
/**
 * Converts an HSV color (and optional alpha value) to a color object.
 * If `a` is not given, a default of 100 is used.
 * Hex in the returned value will *not* be prefixed with #.
 * If `a` is unspecified or 100, the result's `str` property will contain a hex value
 * (*not* prefixed with #)
 */
export function getColorFromHSV(hsv, a) {
    var h = hsv.h, s = hsv.s, v = hsv.v;
    a = typeof a === 'number' ? a : MAX_COLOR_ALPHA;
    var _a = hsv2rgb(h, s, v), r = _a.r, g = _a.g, b = _a.b;
    var hex = hsv2hex(h, s, v);
    var str = _rgbaOrHexString(r, g, b, a, hex);
    return { a: a, b: b, g: g, h: h, hex: hex, r: r, s: s, str: str, v: v };
}
/**
 * Converts a color hue to an HTML color string (with # prefix).
 * This implementation ignores all components of `color` except hue.
 */
export function getFullColorString(color) {
    return "#" + hsv2hex(color.h, MAX_COLOR_SATURATION, MAX_COLOR_VALUE);
}
/**
 * Gets a color with the same hue as `color` and other components updated to match the given
 * saturation and value.
 *
 * Does not modify the original `color` and does not supply a default alpha value.
 */
export function updateSV(color, s, v) {
    var _a = hsv2rgb(color.h, s, v), r = _a.r, g = _a.g, b = _a.b;
    var hex = rgb2hex(r, g, b);
    return {
        a: color.a,
        b: b,
        g: g,
        h: color.h,
        hex: hex,
        r: r,
        s: s,
        str: _rgbaOrHexString(r, g, b, color.a, hex),
        v: v
    };
}
/**
 * Gets a color with the same saturation and value as `color` and the other components updated
 * to match the given hue.
 *
 * Does not modify the original `color` and does not supply a default alpha value.
 */
export function updateH(color, h) {
    var _a = hsv2rgb(h, color.s, color.v), r = _a.r, g = _a.g, b = _a.b;
    var hex = rgb2hex(r, g, b);
    return {
        a: color.a,
        b: b,
        g: g,
        h: h,
        hex: hex,
        r: r,
        s: color.s,
        str: _rgbaOrHexString(r, g, b, color.a, hex),
        v: color.v
    };
}
/**
 * Gets a color with a single RGBA component updated to a new value.
 * Does not modify the original `color`. Alpha defaults to 100 if not set.
 */
export function updateRGB(color, component, value) {
    return getColorFromRGBA((_a = {
            r: color.r,
            g: color.g,
            b: color.b,
            a: color.a
        },
        _a[component] = value,
        _a));
    var _a;
}
/**
 * Gets a color with the given alpha value and the same other components as `color`.
 * Does not modify the original color.
 */
export function updateA(color, a) {
    return tslib_1.__assign({}, color, { a: a, str: _rgbaOrHexString(color.r, color.g, color.b, a, color.hex) });
}
/** Corrects an RGB color to fall within the valid range.  */
export function correctRGB(color) {
    return {
        r: clamp(color.r, MAX_COLOR_RGB),
        g: clamp(color.g, MAX_COLOR_RGB),
        b: clamp(color.b, MAX_COLOR_RGB),
        a: typeof color.a === 'number' ? clamp(color.a, MAX_COLOR_ALPHA) : color.a
    };
}
/** Corrects an HSV color to fall within the valid range. */
export function correctHSV(color) {
    return {
        h: clamp(color.h, MAX_COLOR_HUE),
        s: clamp(color.s, MAX_COLOR_SATURATION),
        v: clamp(color.v, MAX_COLOR_VALUE)
    };
}
/** Clamp a value to ensure it falls within a given range. */
export function clamp(value, max, min) {
    if (min === void 0) { min = 0; }
    return value < min ? min : value > max ? max : value;
}
/** Converts an RGB component to a 0-padded hex component of length 2. */
function _rgbToPaddedHex(num) {
    num = clamp(num, MAX_COLOR_RGB);
    var hex = num.toString(16);
    return hex.length === 1 ? '0' + hex : hex;
}
/**
 * If `str` is a valid HTML color name, returns an RGB color (with alpha 100).
 * Otherwise returns undefined.
 */
function _named(str) {
    var c = COLOR_VALUES[str.toLowerCase()];
    if (c) {
        return {
            r: c[0],
            g: c[1],
            b: c[2],
            a: MAX_COLOR_ALPHA
        };
    }
}
/**
 * If `str` is in valid `rgb()` or `rgba()` format, returns an RGB color (alpha defaults to 100).
 * Otherwise returns undefined.
 */
function _rgba(str) {
    var match = str.match(/^rgb(a?)\(([\d., ]+)\)$/);
    if (match) {
        var hasAlpha = !!match[1];
        var expectedPartCount = hasAlpha ? 4 : 3;
        var parts = match[2].split(/ *, */).map(Number);
        if (parts.length === expectedPartCount) {
            return {
                r: parts[0],
                g: parts[1],
                b: parts[2],
                a: hasAlpha ? parts[3] * 100 : MAX_COLOR_ALPHA
            };
        }
    }
}
/**
 * If `str` is in valid 6-digit hex format *with* # prefix, returns an RGB color (with alpha 100).
 * Otherwise returns undefined.
 */
function _hex6(str) {
    if ('#' === str[0] && 7 === str.length && /^#[\da-fA-F]{6}$/.test(str)) {
        return {
            r: parseInt(str.slice(1, 3), 16),
            g: parseInt(str.slice(3, 5), 16),
            b: parseInt(str.slice(5, 7), 16),
            a: MAX_COLOR_ALPHA
        };
    }
}
/**
 * If `str` is in valid 3-digit hex format *with* # prefix, returns an RGB color (with alpha 100).
 * Otherwise returns undefined.
 */
function _hex3(str) {
    if ('#' === str[0] && 4 === str.length && /^#[\da-fA-F]{3}$/.test(str)) {
        return {
            r: parseInt(str[1] + str[1], 16),
            g: parseInt(str[2] + str[2], 16),
            b: parseInt(str[3] + str[3], 16),
            a: MAX_COLOR_ALPHA
        };
    }
}
/**
 * If `str` is in `hsl()` or `hsla()` format, returns an RGB color (alpha defaults to 100).
 * Otherwise returns undefined.
 */
function _hsla(str) {
    var match = str.match(/^hsl(a?)\(([\d., ]+)\)$/);
    if (match) {
        var hasAlpha = !!match[1];
        var expectedPartCount = hasAlpha ? 4 : 3;
        var parts = match[2].split(/ *, */).map(Number);
        if (parts.length === expectedPartCount) {
            var rgba = hsl2rgb(parts[0], parts[1], parts[2]);
            rgba.a = hasAlpha ? parts[3] * 100 : MAX_COLOR_ALPHA;
            return rgba;
        }
    }
}
/**
 * Get a CSS color string from some color components.
 * If `a` is specified and not 100, returns an `rgba()` string.
 * Otherwise returns `hex` prefixed with #.
 */
function _rgbaOrHexString(r, g, b, a, hex) {
    return a === MAX_COLOR_ALPHA || typeof a !== 'number' ? "#" + hex : "rgba(" + r + ", " + g + ", " + b + ", " + a / MAX_COLOR_ALPHA + ")";
}
//# sourceMappingURL=colors.js.map