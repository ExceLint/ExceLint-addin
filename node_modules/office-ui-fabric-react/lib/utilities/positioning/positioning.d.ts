import { DirectionalHint } from '../../common/DirectionalHint';
import { Rectangle as FullRectangle, IRectangle } from '../../Utilities';
import { IPositionDirectionalHintData, IPositionedData, IPoint, ICalloutPositionedInfo, ICalloutBeakPositionedInfo, IPositionProps, RectangleEdge } from './positioning.types';
export declare class Rectangle extends FullRectangle {
    [key: string]: number | boolean | any;
}
/**
 * Do not call methods from this directly, use either positionCallout or positionElement or make another function that
 * utilizes them.
 * START Private functions and interfaces
 */
export interface IElementPosition {
    elementRectangle: Rectangle;
    targetEdge: RectangleEdge;
    alignmentEdge: RectangleEdge | undefined;
}
export interface IElementPositionInfo extends IElementPosition {
    targetRectangle: Rectangle;
}
export declare const __positioningTestPackage: {
    _finalizePositionData: (positionedElement: IElementPosition, hostElement: HTMLElement, bounds?: Rectangle | undefined, coverTarget?: boolean | undefined) => IPositionedData;
    _finalizeBeakPosition: (elementPosition: IElementPosition, positionedBeak: Rectangle, bounds?: Rectangle | undefined) => ICalloutBeakPositionedInfo;
    _calculateActualBeakWidthInPixels: (beakWidth: number) => number;
    _positionElementWithinBounds: (elementToPosition: Rectangle, target: Rectangle, bounding: Rectangle, positionData: IPositionDirectionalHintData, gap: number, directionalHintFixed?: boolean | undefined, coverTarget?: boolean | undefined) => IElementPosition;
    _positionBeak: (beakWidth: number, elementPosition: IElementPositionInfo) => Rectangle;
    _getPositionData: (directionalHint?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13, directionalHintForRTL?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | undefined, previousPositions?: IPositionDirectionalHintData | undefined) => IPositionDirectionalHintData;
    _getMaxHeightFromTargetRectangle: (targetRectangle: Rectangle, targetEdge: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13, gapSpace: number, bounds: Rectangle, coverTarget?: boolean | undefined) => number;
};
/**
 * Used to position an element relative to the given positioning props.
 * If positioning has been completed before, previousPositioningData
 * can be passed to ensure that the positioning element repositions based on
 * its previous targets rather than starting with directionalhint.
 *
 * @export
 * @param {IPositionProps} props
 * @param {HTMLElement} hostElement
 * @param {HTMLElement} elementToPosition
 * @param {IPositionedData} previousPositions
 * @returns
 */
export declare function positionElement(props: IPositionProps, hostElement: HTMLElement, elementToPosition: HTMLElement, previousPositions?: IPositionedData): IPositionedData;
export declare function positionCallout(props: IPositionProps, hostElement: HTMLElement, elementToPosition: HTMLElement, previousPositions?: ICalloutPositionedInfo): ICalloutPositionedInfo;
/**
 * Get's the maximum height that a rectangle can have in order to fit below or above a target.
 * If the directional hint specifies a left or right edge (i.e. leftCenter) it will limit the height to the topBorder
 * of the target given.
 * If no bounds are provided then the window is treated as the bounds.
 */
export declare function getMaxHeight(target: Element | MouseEvent | IPoint, targetEdge: DirectionalHint, gapSpace?: number, bounds?: IRectangle, coverTarget?: boolean): number;
/**
 * Returns the opposite edge of the given RectangleEdge.
 */
export declare function getOppositeEdge(edge: RectangleEdge): RectangleEdge;
