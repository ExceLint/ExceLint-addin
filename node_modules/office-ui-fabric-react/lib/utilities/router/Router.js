import * as tslib_1 from "tslib";
import * as React from 'react';
import { BaseComponent } from '../../Utilities';
var Router = /** @class */ (function (_super) {
    tslib_1.__extends(Router, _super);
    function Router() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Router.prototype.componentDidMount = function () {
        var _this = this;
        this._events.on(window, 'hashchange', function () { return _this.forceUpdate(); });
    };
    Router.prototype.render = function () {
        return this._resolveRoute();
    };
    Router.prototype._getPath = function () {
        var path = location.hash;
        var hashIndex = path.lastIndexOf('#'), questionMarkIndex = path.indexOf('?');
        // Look for the start of a query in the currentPath, then strip out the query to find the correct page to render
        if (questionMarkIndex > -1) {
            path = path.substr(0, questionMarkIndex);
        }
        if (hashIndex > 0) {
            path = path.substr(0, hashIndex);
        }
        return path;
    };
    Router.prototype._resolveRoute = function (path, children) {
        var _this = this;
        path = path || this._getPath();
        children = children || this.props.children;
        var routes = React.Children.toArray(children);
        var _loop_1 = function (i) {
            var route = routes[i];
            if (_match(path, route)) {
                var getComponent_1 = route.props.getComponent;
                var component_1 = route.props.component;
                if (getComponent_1) {
                    var asynchronouslyResolved_1 = false;
                    if (getComponent_1.component) {
                        component_1 = getComponent_1.component;
                    }
                    else {
                        getComponent_1(function (resolved) {
                            component_1 = getComponent_1.component = resolved;
                            if (asynchronouslyResolved_1) {
                                _this.forceUpdate();
                            }
                        });
                    }
                    // Note: in webpack 2, this ends up always async.
                    asynchronouslyResolved_1 = true;
                }
                if (component_1) {
                    var componentChildren = this_1._resolveRoute(path, route.props.children || []);
                    if (componentChildren) {
                        return { value: React.createElement(component_1, { key: route.key }, componentChildren) };
                    }
                    else {
                        return { value: React.createElement(component_1, { key: route.key }) };
                    }
                }
                else if (getComponent_1) {
                    return { value: null };
                }
            }
        };
        var this_1 = this;
        for (var i = 0; i < routes.length; i++) {
            var state_1 = _loop_1(i);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        return null;
    };
    return Router;
}(BaseComponent));
export { Router };
function _match(currentPath, child) {
    if (child.props) {
        var path = child.props.path;
        path = path || '';
        currentPath = currentPath || '';
        return !path || path.toLowerCase() === currentPath.toLowerCase();
    }
    return false;
}
//# sourceMappingURL=Router.js.map