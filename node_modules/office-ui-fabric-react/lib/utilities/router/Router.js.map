{"version":3,"file":"Router.js","sourceRoot":"../src/","sources":["utilities/router/Router.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\r\nimport { BaseComponent } from '../../Utilities';\r\n\r\nexport interface IRouterProps {\r\n  /**\r\n   * Gets the component ref.\r\n   */\r\n  componentRef?: () => void;\r\n\r\n  replaceState?: boolean;\r\n  children?: any;\r\n  onNewRouteLoaded?: () => void;\r\n}\r\n\r\nexport class Router extends BaseComponent<IRouterProps, {}> {\r\n  public componentDidMount(): void {\r\n    this._events.on(window, 'hashchange', () => this.forceUpdate());\r\n  }\r\n\r\n  public render(): JSX.Element | null {\r\n    return this._resolveRoute();\r\n  }\r\n\r\n  private _getPath(): string {\r\n    let path = location.hash;\r\n    const hashIndex = path.lastIndexOf('#'),\r\n      questionMarkIndex = path.indexOf('?');\r\n\r\n    // Look for the start of a query in the currentPath, then strip out the query to find the correct page to render\r\n    if (questionMarkIndex > -1) {\r\n      path = path.substr(0, questionMarkIndex);\r\n    }\r\n\r\n    if (hashIndex > 0) {\r\n      path = path.substr(0, hashIndex);\r\n    }\r\n\r\n    return path;\r\n  }\r\n\r\n  private _resolveRoute(path?: string, children?: React.ReactNode): React.DOMElement<any, Element> | null {\r\n    path = path || this._getPath();\r\n    children = children || this.props.children;\r\n\r\n    const routes = React.Children.toArray(children);\r\n\r\n    for (let i = 0; i < routes.length; i++) {\r\n      const route: any = routes[i];\r\n\r\n      if (_match(path, route)) {\r\n        const { getComponent } = route.props;\r\n        let { component } = route.props;\r\n\r\n        if (getComponent) {\r\n          let asynchronouslyResolved = false;\r\n\r\n          if (getComponent.component) {\r\n            component = getComponent.component;\r\n          } else {\r\n            getComponent((resolved: any) => {\r\n              component = getComponent.component = resolved;\r\n\r\n              if (asynchronouslyResolved) {\r\n                this.forceUpdate();\r\n              }\r\n            });\r\n          }\r\n          // Note: in webpack 2, this ends up always async.\r\n          asynchronouslyResolved = true;\r\n        }\r\n\r\n        if (component) {\r\n          const componentChildren = this._resolveRoute(path, route.props.children || []);\r\n\r\n          if (componentChildren) {\r\n            return React.createElement(component, { key: route.key }, componentChildren) as React.DOMElement<any, any>;\r\n          } else {\r\n            return React.createElement(component, { key: route.key }) as React.DOMElement<any, any>;\r\n          }\r\n        } else if (getComponent) {\r\n          // We are asynchronously fetching this component.\r\n          return null;\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nfunction _match(currentPath: string, child: any): boolean {\r\n  if (child.props) {\r\n    let { path } = child.props;\r\n\r\n    path = path || '';\r\n    currentPath = currentPath || '';\r\n\r\n    return !path || path.toLowerCase() === currentPath.toLowerCase();\r\n  }\r\n\r\n  return false;\r\n}\r\n"]}