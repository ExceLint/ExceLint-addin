{"version":3,"file":"ComboBox.js","sourceRoot":"../src/","sources":["components/ComboBox/ComboBox.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Autofill, IAutofill } from '../Autofill/index';\nimport {\n  initializeComponentRef,\n  css,\n  customizable,\n  divProperties,\n  findElementRecursive,\n  findIndex,\n  focusAsync,\n  getId,\n  getNativeProps,\n  isIOS,\n  isMac,\n  KeyCodes,\n  shallowCompare,\n  mergeAriaAttributeValues,\n  warnMutuallyExclusive,\n  Async,\n  EventGroup,\n} from '../../Utilities';\nimport { Callout } from '../../Callout';\nimport { Checkbox } from '../../Checkbox';\nimport { CommandButton, IButtonStyles, IconButton } from '../../Button';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { getCaretDownButtonStyles, getOptionStyles, getStyles } from './ComboBox.styles';\nimport { getClassNames, getComboBoxOptionClassNames } from './ComboBox.classNames';\nimport {\n  IComboBoxOption,\n  IComboBoxOptionStyles,\n  IComboBoxProps,\n  IOnRenderComboBoxLabelProps,\n  IComboBoxClassNames,\n} from './ComboBox.types';\nimport { KeytipData } from '../../KeytipData';\nimport { Label } from '../../Label';\nimport { SelectableOptionMenuItemType, getAllSelectedOptions } from '../../utilities/selectableOption/index';\nimport { BaseButton, Button } from '../Button/index';\nimport { ICalloutProps } from '../../Callout';\n\nexport interface IComboBoxState {\n  /** The open state */\n  isOpen?: boolean;\n\n  /** The currently selected indices */\n  selectedIndices?: number[];\n\n  /** The focused state of the comboBox */\n  focusState?: 'none' | 'focused' | 'focusing';\n\n  /** This value is used for the autocomplete hint value */\n  suggestedDisplayValue?: string;\n\n  /** The options currently available for the callout */\n  currentOptions: IComboBoxOption[];\n\n  /**\n   * When taking input, this will store the index that the options input matches\n   * (-1 if no input or match)\n   */\n  currentPendingValueValidIndex: number;\n\n  /**\n   * Stores the hovered over value in the dropdown\n   * (used for styling the options without updating the input)\n   */\n  currentPendingValueValidIndexOnHover: number;\n\n  /** When taking input, this will store the actual text that is being entered */\n  currentPendingValue?: string;\n}\n\nenum SearchDirection {\n  backward = -1,\n  none = 0,\n  forward = 1,\n}\n\nenum HoverStatus {\n  /** Used when the user was hovering and has since moused out of the menu items */\n  clearAll = -2,\n  /** Default \"normal\" state, when no hover has happened or a hover is in progress */\n  default = -1,\n}\n\nconst ScrollIdleDelay = 250; /* ms */\nconst TouchIdleDelay = 500; /* ms */\n\n/**\n * This is used to clear any pending autocomplete text (used when autocomplete is true and\n * allowFreeform is false)\n */\nconst ReadOnlyPendingAutoCompleteTimeout = 1000; /* ms */\n\ninterface IComboBoxOptionWrapperProps extends IComboBoxOption {\n  /** True if the option is currently selected */\n  isSelected: boolean;\n\n  /** True if the option is currently checked (multi-select) */\n  isChecked: boolean;\n\n  /**\n   * A function that returns the children of the OptionWrapper. We pass this in as a function to ensure that\n   * children methods don't get called unnecessarily if the component doesn't need to be updated. This leads\n   * to a significant performance increase in ComboBoxes with many options and/or complex onRenderOption functions\n   */\n  render: () => JSX.Element;\n}\n\n/**\n * Internal class that is used to wrap all ComboBox options.\n * This is used to customize when we want to rerender components,\n * so we don't rerender every option every time render is executed.\n */\nclass ComboBoxOptionWrapper extends React.Component<IComboBoxOptionWrapperProps, {}> {\n  public render(): React.ReactNode {\n    return this.props.render();\n  }\n\n  public shouldComponentUpdate(newProps: IComboBoxOptionWrapperProps): boolean {\n    // The render function will always be different, so we ignore that prop\n    return !shallowCompare({ ...this.props, render: undefined }, { ...newProps, render: undefined });\n  }\n}\n\nconst COMPONENT_NAME = 'ComboBox';\n\n@customizable('ComboBox', ['theme', 'styles'], true)\nexport class ComboBox extends React.Component<IComboBoxProps, IComboBoxState> {\n  public static defaultProps: IComboBoxProps = {\n    options: [],\n    allowFreeform: false,\n    autoComplete: 'on',\n    buttonIconProps: { iconName: 'ChevronDown' },\n  };\n\n  private _root = React.createRef<HTMLDivElement>();\n\n  /** The input aspect of the comboBox */\n  private _autofill = React.createRef<IAutofill>();\n\n  /** The wrapping div of the input and button */\n  private _comboBoxWrapper = React.createRef<HTMLDivElement>();\n\n  /** The callout element */\n  private _comboBoxMenu = React.createRef<HTMLDivElement>();\n\n  /** The menu item element that is currently selected */\n  private _selectedElement = React.createRef<HTMLSpanElement>();\n\n  /** The base id for the ComboBox */\n  private _id: string;\n\n  /**\n   * After a character is inserted when autocomplete is true and allowFreeform is false,\n   * remember the task that will clear the pending string of characters.\n   */\n  private _lastReadOnlyAutoCompleteChangeTimeoutId: number | undefined;\n\n  /** Promise used when resolving the comboBox options */\n  private _currentPromise: PromiseLike<IComboBoxOption[]>;\n\n  /** The current visible value sent to the auto fill on render */\n  private _currentVisibleValue: string | undefined;\n  private _classNames: IComboBoxClassNames;\n  private _isScrollIdle: boolean;\n  private _hasPendingValue: boolean;\n  private _scrollIdleTimeoutId: number | undefined;\n  private _processingTouch: boolean;\n  private _lastTouchTimeoutId: number | undefined;\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\n  private _lastKeyDownWasAltOrMeta: boolean | undefined;\n\n  /**\n   * Determines if we should be setting focus back to the input when the menu closes.\n   * The general rule of thumb is if the menu was launched via the keyboard focus should go back\n   * to the input, if it was dropped via the mouse focus should not be forced back to the input.\n   */\n  private _focusInputAfterClose: boolean;\n\n  /** Flag for when we get the first mouseMove */\n  private _gotMouseMove: boolean;\n\n  private _processingClearPendingInfo: boolean;\n\n  private _async: Async;\n  private _events: EventGroup;\n\n  constructor(props: IComboBoxProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    warnMutuallyExclusive(COMPONENT_NAME, props, {\n      defaultSelectedKey: 'selectedKey',\n      text: 'defaultSelectedKey',\n      selectedKey: 'value',\n      dropdownWidth: 'useComboBoxAsMenuWidth',\n    });\n\n    this._id = props.id || getId('ComboBox');\n    const selectedKeys: string[] | number[] = this._buildDefaultSelectedKeys(\n      props.defaultSelectedKey,\n      props.selectedKey,\n    );\n\n    this._isScrollIdle = true;\n    this._processingTouch = false;\n    this._gotMouseMove = false;\n    this._processingClearPendingInfo = false;\n\n    const initialSelectedIndices: number[] = this._getSelectedIndices(props.options, selectedKeys);\n\n    this.state = {\n      isOpen: false,\n      selectedIndices: initialSelectedIndices,\n      focusState: 'none',\n      suggestedDisplayValue: undefined,\n      currentOptions: this.props.options,\n      currentPendingValueValidIndex: -1,\n      currentPendingValue: undefined,\n      currentPendingValueValidIndexOnHover: HoverStatus.default,\n    };\n  }\n\n  /**\n   * All selected options\n   */\n  public get selectedOptions(): IComboBoxOption[] {\n    const { currentOptions, selectedIndices } = this.state;\n\n    return getAllSelectedOptions(currentOptions, selectedIndices!);\n  }\n\n  public componentDidMount(): void {\n    if (this._comboBoxWrapper.current && !this.props.disabled) {\n      // hook up resolving the options if needed on focus\n      this._events.on(this._comboBoxWrapper.current, 'focus', this._onResolveOptions, true);\n      if ('onpointerdown' in this._comboBoxWrapper.current) {\n        // For ComboBoxes, touching anywhere in the combo box should drop the dropdown, including the input element.\n        // This gives more hit target space for touch environments. We're setting the onpointerdown here, because React\n        // does not support Pointer events yet.\n        this._events.on(this._comboBoxWrapper.current, 'pointerdown', this._onPointerDown, true);\n      }\n    }\n  }\n\n  public UNSAFE_componentWillReceiveProps(newProps: IComboBoxProps): void {\n    // Update the selectedIndex and currentOptions state if\n    // the selectedKey, value, or options have changed\n    if (\n      newProps.selectedKey !== this.props.selectedKey ||\n      newProps.text !== this.props.text ||\n      newProps.options !== this.props.options\n    ) {\n      const selectedKeys: string[] | number[] = this._buildSelectedKeys(newProps.selectedKey);\n      const indices: number[] = this._getSelectedIndices(newProps.options, selectedKeys);\n\n      this.setState({\n        selectedIndices: indices,\n        currentOptions: newProps.options,\n      });\n      if (newProps.selectedKey === null) {\n        this.setState({\n          suggestedDisplayValue: undefined,\n        });\n      }\n    }\n  }\n\n  public componentDidUpdate(prevProps: IComboBoxProps, prevState: IComboBoxState) {\n    const { allowFreeform, text, onMenuOpen, onMenuDismissed } = this.props;\n    const { isOpen, selectedIndices, currentPendingValueValidIndex } = this.state;\n\n    // If we are newly open or are open and the pending valid index changed,\n    // make sure the currently selected/pending option is scrolled into view\n    if (isOpen && (!prevState.isOpen || prevState.currentPendingValueValidIndex !== currentPendingValueValidIndex)) {\n      // Need this timeout so that the selectedElement ref is correctly updated\n      this._async.setTimeout(() => this._scrollIntoView(), 0);\n    }\n\n    // if an action is taken that put focus in the ComboBox\n    // and If we are open or we are just closed, shouldFocusAfterClose is set,\n    // but we are not the activeElement set focus on the input\n    if (\n      this._hasFocus() &&\n      (isOpen ||\n        (prevState.isOpen &&\n          !isOpen &&\n          this._focusInputAfterClose &&\n          this._autofill.current &&\n          document.activeElement !== this._autofill.current.inputElement))\n    ) {\n      this.focus(undefined /*shouldOpenOnFocus*/, true /*useFocusAsync*/);\n    }\n\n    // If we should focusAfterClose AND\n    //   just opened/closed the menu OR\n    //   are focused AND\n    //     updated the selectedIndex with the menu closed OR\n    //     are not allowing freeform OR\n    //     the value changed\n    // we need to set selection\n    if (\n      this._focusInputAfterClose &&\n      ((prevState.isOpen && !isOpen) ||\n        (this._hasFocus() &&\n          ((!isOpen &&\n            !this.props.multiSelect &&\n            prevState.selectedIndices &&\n            selectedIndices &&\n            prevState.selectedIndices[0] !== selectedIndices[0]) ||\n            !allowFreeform ||\n            text !== prevProps.text)))\n    ) {\n      this._onFocus();\n    }\n\n    this._notifyPendingValueChanged(prevState);\n\n    if (isOpen && !prevState.isOpen && onMenuOpen) {\n      onMenuOpen();\n    }\n\n    if (!isOpen && prevState.isOpen && onMenuDismissed) {\n      onMenuDismissed();\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  // Primary Render\n  public render(): JSX.Element {\n    const id = this._id;\n    const errorMessageId = id + '-error';\n    const {\n      className,\n      disabled,\n      required,\n      errorMessage,\n      onRenderContainer = this._onRenderContainer,\n      onRenderLabel = this._onRenderLabel,\n      onRenderList = this._onRenderList,\n      onRenderItem = this._onRenderItem,\n      onRenderOption = this._onRenderOptionContent,\n      allowFreeform,\n      styles: customStyles,\n      theme,\n      keytipProps,\n      persistMenu,\n      multiSelect,\n    } = this.props;\n    const { isOpen, suggestedDisplayValue } = this.state;\n    this._currentVisibleValue = this._getVisibleValue();\n\n    // Single select is already accessible since the whole text is selected\n    // when focus enters the input. Since multiselect appears to clear the input\n    // it needs special accessible text\n    const multiselectAccessibleText = multiSelect\n      ? this._getMultiselectDisplayString(this.state.selectedIndices, this.state.currentOptions, suggestedDisplayValue)\n      : undefined;\n\n    const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties, [\n      'onChange',\n      'value',\n    ]);\n\n    const hasErrorMessage = errorMessage && errorMessage.length > 0 ? true : false;\n\n    this._classNames = this.props.getClassNames\n      ? this.props.getClassNames(\n          theme!,\n          !!isOpen,\n          !!disabled,\n          !!required,\n          !!this._hasFocus(),\n          !!allowFreeform,\n          !!hasErrorMessage,\n          className,\n        )\n      : getClassNames(\n          getStyles(theme!, customStyles),\n          className!,\n          !!isOpen,\n          !!disabled,\n          !!required,\n          !!this._hasFocus(),\n          !!allowFreeform,\n          !!hasErrorMessage,\n        );\n\n    const comboBoxWrapper = keytipProps ? (\n      <KeytipData keytipProps={keytipProps} disabled={disabled}>\n        {(keytipAttributes: any): JSX.Element =>\n          this._renderComboBoxWrapper(multiselectAccessibleText, errorMessageId, keytipAttributes)\n        }\n      </KeytipData>\n    ) : (\n      this._renderComboBoxWrapper(multiselectAccessibleText, errorMessageId)\n    );\n\n    return (\n      <div {...divProps} ref={this._root} className={this._classNames.container}>\n        {onRenderLabel({ props: this.props, multiselectAccessibleText }, this._onRenderLabel)}\n        {comboBoxWrapper}\n        {(persistMenu || isOpen) &&\n          onRenderContainer(\n            {\n              ...this.props,\n              onRenderList,\n              onRenderItem,\n              onRenderOption,\n              options: this.state.currentOptions.map((item, index) => ({ ...item, index: index })),\n              onDismiss: this._onDismiss,\n            },\n            this._onRenderContainer,\n          )}\n        <div\n          role=\"region\"\n          aria-live=\"polite\"\n          aria-atomic=\"true\"\n          id={errorMessageId}\n          className={hasErrorMessage ? this._classNames.errorMessage : ''}\n        >\n          {errorMessage !== undefined ? errorMessage : ''}\n        </div>\n      </div>\n    );\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public focus = (shouldOpenOnFocus?: boolean, useFocusAsync?: boolean): void => {\n    if (this._autofill.current) {\n      if (useFocusAsync) {\n        focusAsync(this._autofill.current);\n      } else {\n        this._autofill.current.focus();\n      }\n\n      if (shouldOpenOnFocus) {\n        this.setState({\n          isOpen: true,\n        });\n      }\n    }\n\n    // Programatically setting focus means that there is nothing else that needs to be done\n    // Focus is now contained\n    if (!this._hasFocus()) {\n      this.setState({ focusState: 'focused' });\n    }\n  };\n\n  /**\n   * Close menu callout if it is open\n   */\n  public dismissMenu = (): void => {\n    const { isOpen } = this.state;\n    isOpen && this.setState({ isOpen: false });\n  };\n\n  /**\n   * componentWillReceiveProps handler for the auto fill component\n   * Checks/updates the iput value to set, if needed\n   * @param defaultVisibleValue - the defaultVisibleValue that got passed\n   *  in to the auto fill's componentWillReceiveProps\n   * @returns - the updated value to set, if needed\n   */\n  private _onUpdateValueInAutofillWillReceiveProps = (): string | null => {\n    const comboBox = this._autofill.current;\n\n    if (!comboBox) {\n      return null;\n    }\n\n    if (comboBox.value === null || comboBox.value === undefined) {\n      return null;\n    }\n\n    const visibleValue = this._normalizeToString(this._currentVisibleValue);\n    if (comboBox.value !== visibleValue) {\n      // If visibleValue is empty, ensure that the empty string is used\n      return visibleValue || '';\n    }\n\n    return comboBox.value;\n  };\n\n  private _renderComboBoxWrapper = (\n    multiselectAccessibleText: string | undefined,\n    errorMessageId: string,\n    keytipAttributes: any = {},\n  ): JSX.Element => {\n    const {\n      label,\n      disabled,\n      ariaLabel,\n      ariaDescribedBy,\n      required,\n      errorMessage,\n      buttonIconProps,\n      isButtonAriaHidden = true,\n      title,\n      placeholder: placeholderProp,\n      tabIndex,\n      autofill,\n      iconButtonProps,\n    } = this.props;\n\n    const { isOpen, suggestedDisplayValue } = this.state;\n\n    // If the combobox has focus, is multiselect, and has a display string, then use that placeholder\n    // so that the selected items don't appear to vanish. This is not ideal but it's the only reasonable way\n    // to correct the behavior where the input is cleared so the user can type. If a full refactor is done, then this\n    // should be removed and the multiselect combobox should behave like a picker.\n    const placeholder =\n      this._hasFocus() && this.props.multiSelect && multiselectAccessibleText\n        ? multiselectAccessibleText\n        : placeholderProp;\n\n    return (\n      <div\n        data-ktp-target={keytipAttributes['data-ktp-target']}\n        ref={this._comboBoxWrapper}\n        id={this._id + 'wrapper'}\n        className={this._classNames.root}\n      >\n        <Autofill\n          data-ktp-execute-target={keytipAttributes['data-ktp-execute-target']}\n          data-is-interactable={!disabled}\n          componentRef={this._autofill}\n          id={this._id + '-input'}\n          className={this._classNames.input}\n          type=\"text\"\n          onFocus={this._onFocus}\n          onBlur={this._onBlur}\n          onKeyDown={this._onInputKeyDown}\n          onKeyUp={this._onInputKeyUp}\n          onClick={this._onAutofillClick}\n          onTouchStart={this._onTouchStart}\n          onInputValueChange={this._onInputChange}\n          aria-expanded={isOpen}\n          aria-autocomplete={this._getAriaAutoCompleteValue()}\n          role=\"combobox\"\n          readOnly={disabled}\n          aria-labelledby={label && this._id + '-label'}\n          aria-label={ariaLabel && !label ? ariaLabel : undefined}\n          aria-describedby={\n            errorMessage !== undefined\n              ? mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby'], errorMessageId)\n              : mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby'])\n          }\n          aria-activedescendant={this._getAriaActiveDescendantValue()}\n          aria-required={required}\n          aria-disabled={disabled}\n          aria-owns={isOpen ? this._id + '-list' : undefined}\n          spellCheck={false}\n          defaultVisibleValue={this._currentVisibleValue}\n          suggestedDisplayValue={suggestedDisplayValue}\n          updateValueInWillReceiveProps={this._onUpdateValueInAutofillWillReceiveProps}\n          shouldSelectFullInputValueInComponentDidUpdate={\n            this._onShouldSelectFullInputValueInAutofillComponentDidUpdate\n          }\n          title={title}\n          preventValueSelection={!this._hasFocus()}\n          placeholder={placeholder}\n          tabIndex={tabIndex}\n          {...autofill}\n        />\n        <IconButton\n          className={'ms-ComboBox-CaretDown-button'}\n          styles={this._getCaretButtonStyles()}\n          role=\"presentation\"\n          aria-hidden={isButtonAriaHidden}\n          data-is-focusable={false}\n          tabIndex={-1}\n          onClick={this._onComboBoxClick}\n          onBlur={this._onBlur}\n          iconProps={buttonIconProps}\n          disabled={disabled}\n          checked={isOpen}\n          {...iconButtonProps}\n        />\n      </div>\n    );\n  };\n\n  /**\n   * componentDidUpdate handler for the auto fill component\n   *\n   * @param defaultVisibleValue - the current defaultVisibleValue in the auto fill's componentDidUpdate\n   * @param suggestedDisplayValue - the current suggestedDisplayValue in the auto fill's componentDidUpdate\n   * @returns - should the full value of the input be selected?\n   * True if the defaultVisibleValue equals the suggestedDisplayValue, false otherwise\n   */\n  private _onShouldSelectFullInputValueInAutofillComponentDidUpdate = (): boolean => {\n    return this._currentVisibleValue === this.state.suggestedDisplayValue;\n  };\n\n  /**\n   * Get the correct value to pass to the input\n   * to show to the user based off of the current props and state\n   * @returns the value to pass to the input\n   */\n  private _getVisibleValue = (): string | undefined => {\n    const { text, allowFreeform, autoComplete } = this.props;\n    const {\n      selectedIndices,\n      currentPendingValueValidIndex,\n      currentOptions,\n      currentPendingValue,\n      suggestedDisplayValue,\n      isOpen,\n    } = this.state;\n\n    const currentPendingIndexValid = this._indexWithinBounds(currentOptions, currentPendingValueValidIndex);\n\n    // If the user passed is a value prop, use that\n    // unless we are open and have a valid current pending index\n    if (\n      !(isOpen && currentPendingIndexValid) &&\n      text &&\n      (currentPendingValue === null || currentPendingValue === undefined)\n    ) {\n      return text;\n    }\n\n    if (this.props.multiSelect) {\n      // Multi-select\n      if (this._hasFocus()) {\n        let index = -1;\n        if (autoComplete === 'on' && currentPendingIndexValid) {\n          index = currentPendingValueValidIndex;\n        }\n        return this._getPendingString(currentPendingValue, currentOptions, index);\n      } else {\n        return this._getMultiselectDisplayString(selectedIndices, currentOptions, suggestedDisplayValue);\n      }\n    } else {\n      // Single-select\n      let index: number = this._getFirstSelectedIndex();\n      if (allowFreeform) {\n        // If we are allowing freeform and autocomplete is also true\n        // and we've got a pending value that matches an option, remember\n        // the matched option's index\n        if (autoComplete === 'on' && currentPendingIndexValid) {\n          index = currentPendingValueValidIndex;\n        }\n\n        // Since we are allowing freeform, if there is currently a pending value, use that\n        // otherwise use the index determined above (falling back to '' if we did not get a valid index)\n        return this._getPendingString(currentPendingValue, currentOptions, index);\n      } else {\n        // If we are not allowing freeform and have a\n        // valid index that matches the pending value,\n        // we know we will need some version of the pending value\n        if (currentPendingIndexValid && autoComplete === 'on') {\n          // If autoComplete is on, return the\n          // raw pending value, otherwise remember\n          // the matched option's index\n          index = currentPendingValueValidIndex;\n          return this._normalizeToString(currentPendingValue);\n        } else if (!this.state.isOpen && currentPendingValue) {\n          return this._indexWithinBounds(currentOptions, index)\n            ? currentPendingValue\n            : this._normalizeToString(suggestedDisplayValue);\n        } else {\n          return this._indexWithinBounds(currentOptions, index)\n            ? currentOptions[index].text\n            : this._normalizeToString(suggestedDisplayValue);\n        }\n      }\n    }\n  };\n\n  private _getPendingString(\n    currentPendingValue: string | null | undefined,\n    currentOptions: IComboBoxOption[],\n    index: number,\n  ) {\n    return currentPendingValue !== null && currentPendingValue !== undefined\n      ? currentPendingValue\n      : this._indexWithinBounds(currentOptions, index)\n      ? currentOptions[index].text\n      : '';\n  }\n\n  /**\n   * Returns a string that concatenates all of the selected values\n   * for multiselect combobox.\n   */\n  private _getMultiselectDisplayString(\n    selectedIndices: number[] | undefined,\n    currentOptions: IComboBoxOption[],\n    suggestedDisplayValue: string | undefined,\n  ) {\n    const displayValues = [];\n    for (let idx = 0; selectedIndices && idx < selectedIndices.length; idx++) {\n      const index: number = selectedIndices[idx];\n      displayValues.push(\n        this._indexWithinBounds(currentOptions, index)\n          ? currentOptions[index].text\n          : this._normalizeToString(suggestedDisplayValue),\n      );\n    }\n    const { multiSelectDelimiter = ', ' } = this.props;\n    return displayValues.join(multiSelectDelimiter);\n  }\n\n  /**\n   * Is the index within the bounds of the array?\n   * @param options - options to check if the index is valid for\n   * @param index - the index to check\n   * @returns - true if the index is valid for the given options, false otherwise\n   */\n  private _indexWithinBounds(options: IComboBoxOption[] | undefined, index: number): boolean {\n    if (!options) {\n      return false;\n    }\n    return index >= 0 && index < options.length;\n  }\n\n  /**\n   * Handler for typing changes on the input\n   * @param updatedValue - the newly changed value\n   */\n  private _onInputChange = (updatedValue: string): void => {\n    if (this.props.disabled) {\n      this._handleInputWhenDisabled(null /* event */);\n      return;\n    }\n\n    this.props.allowFreeform\n      ? this._processInputChangeWithFreeform(updatedValue)\n      : this._processInputChangeWithoutFreeform(updatedValue);\n  };\n\n  /**\n   * Process the new input's new value when the comboBox\n   * allows freeform entry\n   * @param updatedValue - the input's newly changed value\n   */\n  private _processInputChangeWithFreeform(updatedValue: string): void {\n    const { currentOptions } = this.state;\n    let newCurrentPendingValueValidIndex = -1;\n\n    // if the new value is empty, see if we have an exact match\n    // and then set the pending info\n    if (updatedValue === '') {\n      const items = currentOptions\n        .map((item, index) => {\n          return { ...item, index };\n        })\n        .filter(\n          option =>\n            option.itemType !== SelectableOptionMenuItemType.Header &&\n            option.itemType !== SelectableOptionMenuItemType.Divider,\n        )\n        .filter(option => this._getPreviewText(option) === updatedValue);\n\n      // if we found a match remember the index\n      if (items.length === 1) {\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n\n      this._setPendingInfo(updatedValue, newCurrentPendingValueValidIndex, updatedValue);\n      return;\n    }\n\n    // Remember the original value and then,\n    // make the value lowercase for comparison\n    const originalUpdatedValue: string = updatedValue;\n    updatedValue = updatedValue.toLocaleLowerCase();\n\n    let newSuggestedDisplayValue = '';\n\n    // If autoComplete is on, attempt to find a match from the available options\n    if (this.props.autoComplete === 'on') {\n      // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n      const items = currentOptions\n        .map((item, index) => {\n          return { ...item, index };\n        })\n        .filter(\n          option =>\n            option.itemType !== SelectableOptionMenuItemType.Header &&\n            option.itemType !== SelectableOptionMenuItemType.Divider,\n        )\n        .filter(\n          option =>\n            this._getPreviewText(option)\n              .toLocaleLowerCase()\n              .indexOf(updatedValue) === 0,\n        );\n      if (items.length > 0) {\n        // use ariaLabel as the value when the option is set\n        const text: string = this._getPreviewText(items[0]);\n\n        // If the user typed out the complete option text, we don't need any suggested display text anymore\n        newSuggestedDisplayValue = text.toLocaleLowerCase() !== updatedValue ? text : '';\n\n        // remember the index of the match we found\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n    } else {\n      // If autoComplete is off, attempt to find a match only when the value is exactly equal to the text of an option\n      const items = currentOptions\n        .map((item, index) => {\n          return { ...item, index };\n        })\n        .filter(\n          option =>\n            option.itemType !== SelectableOptionMenuItemType.Header &&\n            option.itemType !== SelectableOptionMenuItemType.Divider,\n        )\n        .filter(option => this._getPreviewText(option).toLocaleLowerCase() === updatedValue);\n\n      // if we found a match remember the index\n      if (items.length === 1) {\n        newCurrentPendingValueValidIndex = items[0].index;\n      }\n    }\n\n    // Set the updated state\n    this._setPendingInfo(originalUpdatedValue, newCurrentPendingValueValidIndex, newSuggestedDisplayValue);\n  }\n\n  /**\n   * Process the new input's new value when the comboBox\n   * does not allow freeform entry\n   * @param updatedValue - the input's newly changed value\n   */\n  private _processInputChangeWithoutFreeform(updatedValue: string): void {\n    const { currentPendingValue, currentPendingValueValidIndex, currentOptions } = this.state;\n\n    if (this.props.autoComplete === 'on') {\n      // If autoComplete is on while allow freeform is off,\n      // we will remember the keypresses and build up a string to attempt to match\n      // as long as characters are typed within a the timeout span of each other,\n      // otherwise we will clear the string and start building a new one on the next keypress.\n      // Also, only do this processing if we have a non-empty value\n      if (updatedValue !== '') {\n        // If we have a pending autocomplete clearing task,\n        // we know that the user is typing with keypresses happening\n        // within the timeout of each other so remove the clearing task\n        // and continue building the pending value with the udpated value\n        if (this._lastReadOnlyAutoCompleteChangeTimeoutId !== undefined) {\n          this._async.clearTimeout(this._lastReadOnlyAutoCompleteChangeTimeoutId);\n          this._lastReadOnlyAutoCompleteChangeTimeoutId = undefined;\n          updatedValue = this._normalizeToString(currentPendingValue) + updatedValue;\n        }\n\n        const originalUpdatedValue: string = updatedValue;\n        updatedValue = updatedValue.toLocaleLowerCase();\n\n        // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\n        const items = currentOptions\n          .map((item, i) => {\n            return { ...item, index: i };\n          })\n          .filter(\n            option =>\n              option.itemType !== SelectableOptionMenuItemType.Header &&\n              option.itemType !== SelectableOptionMenuItemType.Divider,\n          )\n          .filter(option => option.text.toLocaleLowerCase().indexOf(updatedValue) === 0);\n\n        // If we found a match, udpdate the state\n        if (items.length > 0) {\n          this._setPendingInfo(originalUpdatedValue, items[0].index, this._getPreviewText(items[0]));\n        }\n\n        // Schedule a timeout to clear the pending value after the timeout span\n        this._lastReadOnlyAutoCompleteChangeTimeoutId = this._async.setTimeout(() => {\n          this._lastReadOnlyAutoCompleteChangeTimeoutId = undefined;\n        }, ReadOnlyPendingAutoCompleteTimeout);\n        return;\n      }\n    }\n\n    // If we get here, either autoComplete is on or we did not find a match with autoComplete on.\n    // Remember we are not allowing freeform, so at this point, if we have a pending valid value index\n    // use that; otherwise use the selectedIndex\n    const index = currentPendingValueValidIndex >= 0 ? currentPendingValueValidIndex : this._getFirstSelectedIndex();\n\n    // Since we are not allowing freeform, we need to\n    // set both the pending and suggested values/index\n    // to allow us to select all content in the input to\n    // give the illusion that we are readonly (e.g. freeform off)\n    this._setPendingInfoFromIndex(index);\n  }\n\n  private _getFirstSelectedIndex(): number {\n    return this.state.selectedIndices && this.state.selectedIndices.length > 0 ? this.state.selectedIndices[0] : -1;\n  }\n\n  /**\n   * Walk along the options starting at the index, stepping by the delta (positive or negative)\n   * looking for the next valid selectable index (e.g. skipping headings and dividers)\n   * @param index - the index to get the next selectable index from\n   * @param delta - optional delta to step by when finding the next index, defaults to 0\n   * @returns - the next valid selectable index. If the new index is outside of the bounds,\n   * it will snap to the edge of the options array. If delta == 0 and the given index is not selectable\n   */\n  private _getNextSelectableIndex(index: number, searchDirection: SearchDirection): number {\n    const { currentOptions } = this.state;\n\n    let newIndex = index + searchDirection;\n\n    newIndex = Math.max(0, Math.min(currentOptions.length - 1, newIndex));\n\n    if (!this._indexWithinBounds(currentOptions, newIndex)) {\n      return -1;\n    }\n\n    const option: IComboBoxOption = currentOptions[newIndex];\n\n    if (\n      option.itemType === SelectableOptionMenuItemType.Header ||\n      option.itemType === SelectableOptionMenuItemType.Divider ||\n      option.hidden === true\n    ) {\n      // Should we continue looking for an index to select?\n      if (\n        searchDirection !== SearchDirection.none &&\n        ((newIndex > 0 && searchDirection < SearchDirection.none) ||\n          (newIndex >= 0 && newIndex < currentOptions.length && searchDirection > SearchDirection.none))\n      ) {\n        newIndex = this._getNextSelectableIndex(newIndex, searchDirection);\n      } else {\n        // If we cannot perform a useful search just return the index we were given\n        return index;\n      }\n    }\n\n    // We have the next valid selectable index, return it\n    return newIndex;\n  }\n\n  /**\n   * Set the selected index. Note, this is\n   * the \"real\" selected index, not the pending selected index\n   * @param index - the index to set (or the index to set from if a search direction is provided)\n   * @param searchDirection - the direction to search along the options from the given index\n   */\n  private _setSelectedIndex(\n    index: number,\n    submitPendingValueEvent: React.SyntheticEvent<any>,\n    searchDirection: SearchDirection = SearchDirection.none,\n  ): void {\n    const { onChange, onPendingValueChanged } = this.props;\n    const { currentOptions } = this.state;\n    const { selectedIndices: initialIndices } = this.state;\n\n    // Clone selectedIndices so we don't mutate state\n    let selectedIndices = initialIndices ? initialIndices.slice() : [];\n\n    // Find the next selectable index, if searchDirection is none\n    // we will get our starting index back\n    index = this._getNextSelectableIndex(index, searchDirection);\n\n    if (!this._indexWithinBounds(currentOptions, index)) {\n      return;\n    }\n\n    // Are we at a new index? If so, update the state, otherwise\n    // there is nothing to do\n    if (\n      this.props.multiSelect ||\n      selectedIndices.length < 1 ||\n      (selectedIndices.length === 1 && selectedIndices[0] !== index)\n    ) {\n      const option: IComboBoxOption = { ...currentOptions[index] };\n      // if option doesn't existing, or option is disabled, we noop\n      if (!option || option.disabled) {\n        return;\n      }\n      if (this.props.multiSelect) {\n        // Setting the initial state of option.selected in Multi-select combobox by checking the\n        // selectedIndices array and overriding the undefined issue\n        option.selected = option.selected !== undefined ? !option.selected : selectedIndices.indexOf(index) < 0;\n        if (option.selected && selectedIndices.indexOf(index) < 0) {\n          selectedIndices.push(index);\n        } else if (!option.selected && selectedIndices.indexOf(index) >= 0) {\n          selectedIndices = selectedIndices.filter((value: number) => value !== index);\n        }\n      } else {\n        selectedIndices[0] = index;\n      }\n\n      submitPendingValueEvent.persist();\n\n      // Only setstate if combobox is uncontrolled.\n      if (this.props.selectedKey || this.props.selectedKey === null) {\n        // If ComboBox value is changed, revert preview first\n        if (this._hasPendingValue && onPendingValueChanged) {\n          onPendingValueChanged();\n          this._hasPendingValue = false;\n        }\n        if (onChange) {\n          onChange(submitPendingValueEvent, option, index, undefined);\n        }\n      } else {\n        // Update current options\n        const changedOptions = currentOptions.slice();\n        changedOptions[index] = option;\n\n        // Call onChange after state is updated\n        this.setState(\n          {\n            selectedIndices: selectedIndices,\n            currentOptions: changedOptions,\n          },\n          () => {\n            // If ComboBox value is changed, revert preview first\n            if (this._hasPendingValue && onPendingValueChanged) {\n              onPendingValueChanged();\n              this._hasPendingValue = false;\n            }\n\n            if (onChange) {\n              onChange(submitPendingValueEvent, option, index, undefined);\n            }\n          },\n        );\n      }\n    }\n    if (this.props.multiSelect && this.state.isOpen) {\n      return;\n    }\n    // clear all of the pending info\n    this._clearPendingInfo();\n  }\n\n  /**\n   * Focus (and select) the content of the input\n   * and set the focused state\n   */\n  private _onFocus = (): void => {\n    if (this._autofill.current && this._autofill.current.inputElement) {\n      this._autofill.current.inputElement.select();\n    }\n\n    if (!this._hasFocus()) {\n      this.setState({ focusState: 'focusing' });\n    }\n  };\n\n  /**\n   * Callback issued when the options should be resolved, if they have been updated or\n   * if they need to be passed in the first time. This only does work if an onResolveOptions\n   * callback was passed in\n   */\n  private _onResolveOptions = (): void => {\n    if (this.props.onResolveOptions) {\n      // get the options\n      const newOptions = this.props.onResolveOptions([...this.state.currentOptions]);\n\n      // Check to see if the returned value is an array, if it is update the state\n      // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n      // If it is then resolve it asynchronously.\n      if (Array.isArray(newOptions)) {\n        this.setState({\n          currentOptions: newOptions,\n        });\n      } else if (newOptions && newOptions.then) {\n        // Ensure that the promise will only use the callback if it was the most recent one\n        // and update the state when the promise returns\n        const promise: PromiseLike<IComboBoxOption[]> = (this._currentPromise = newOptions);\n        promise.then((newOptionsFromPromise: IComboBoxOption[]) => {\n          if (promise === this._currentPromise) {\n            this.setState({\n              currentOptions: newOptionsFromPromise,\n            });\n          }\n        });\n      }\n    }\n  };\n\n  /**\n   * OnBlur handler. Set the focused state to false\n   * and submit any pending value\n   */\n  // eslint-disable-next-line deprecation/deprecation\n  private _onBlur = (event: React.FocusEvent<HTMLElement | Autofill | BaseButton | Button>): void => {\n    // Do nothing if the blur is coming from something\n    // inside the comboBox root or the comboBox menu since\n    // it we are not really bluring from the whole comboBox\n    let relatedTarget = event.relatedTarget;\n    if (event.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the ComboBox\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = document.activeElement as Element;\n    }\n    if (\n      relatedTarget &&\n      // when event coming from withing the comboBox title\n      ((this._root.current && this._root.current.contains(relatedTarget as HTMLElement)) ||\n        // when event coming from within the comboBox list menu\n        (this._comboBoxMenu.current &&\n          (this._comboBoxMenu.current.contains(relatedTarget as HTMLElement) ||\n            // when event coming from the callout containing the comboBox list menu (ex: when scrollBar of the\n            // Callout is clicked) checks if the relatedTarget is a parent of _comboBoxMenu\n            findElementRecursive(this._comboBoxMenu.current, element => element === relatedTarget))))\n    ) {\n      event.preventDefault();\n      event.stopPropagation();\n      return;\n    }\n\n    if (this._hasFocus()) {\n      this.setState({ focusState: 'none' });\n      if (!this.props.multiSelect || this.props.allowFreeform) {\n        this._submitPendingValue(event);\n      }\n    }\n  };\n\n  /**\n   * Submit a pending value if there is one\n   */\n  private _submitPendingValue(submitPendingValueEvent: any): void {\n    const { onChange, allowFreeform, autoComplete } = this.props;\n    const {\n      currentPendingValue,\n      currentPendingValueValidIndex,\n      currentOptions,\n      currentPendingValueValidIndexOnHover,\n    } = this.state;\n    let { selectedIndices } = this.state;\n\n    // Do not submit any pending value if we\n    // have already initiated clearing the pending info\n    if (this._processingClearPendingInfo) {\n      return;\n    }\n\n    // If we allow freeform we need to handle that\n    if (allowFreeform) {\n      // if currentPendingValue is null or undefined the user did not submit anything\n      // (not even empty because we would have stored that as the pending value)\n      if (currentPendingValue === null || currentPendingValue === undefined) {\n        // if a user did not type anything they may just hovered over an item\n        if (currentPendingValueValidIndexOnHover >= 0) {\n          this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n          this._clearPendingInfo();\n        }\n\n        return;\n      }\n\n      // Check to see if the user typed an exact match\n      if (this._indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\n        const pendingOptionText: string = this._getPreviewText(\n          currentOptions[currentPendingValueValidIndex],\n        ).toLocaleLowerCase();\n\n        // By exact match, that means: our pending value is the same as the pending option text OR\n        // the pending option starts with the pending value and we have an \"autoComplete\" selection\n        // where the total length is equal to pending option length OR\n        // the live value in the underlying input matches the pending option; update the state\n        if (\n          currentPendingValue.toLocaleLowerCase() === pendingOptionText ||\n          (autoComplete &&\n            pendingOptionText.indexOf(currentPendingValue.toLocaleLowerCase()) === 0 &&\n            this._autofill.current &&\n            this._autofill.current.isValueSelected &&\n            currentPendingValue.length +\n              (this._autofill.current.selectionEnd! - this._autofill.current.selectionStart!) ===\n              pendingOptionText.length) ||\n          (this._autofill.current &&\n            this._autofill.current.inputElement &&\n            this._autofill.current.inputElement.value.toLocaleLowerCase() === pendingOptionText)\n        ) {\n          this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n          if (this.props.multiSelect && this.state.isOpen) {\n            return;\n          }\n          this._clearPendingInfo();\n          return;\n        }\n      }\n\n      if (onChange) {\n        if (onChange) {\n          // trigger onChange to clear value\n          onChange(submitPendingValueEvent, undefined, undefined, currentPendingValue);\n        }\n      } else {\n        // If we are not controlled, create a new selected option\n        const newOption: IComboBoxOption = {\n          key: currentPendingValue || getId(),\n          text: this._normalizeToString(currentPendingValue),\n        };\n        // If it's multiselect, set selected state to true\n        if (this.props.multiSelect) {\n          newOption.selected = true;\n        }\n        const newOptions: IComboBoxOption[] = currentOptions.concat([newOption]);\n        if (selectedIndices) {\n          if (!this.props.multiSelect) {\n            selectedIndices = [];\n          }\n          selectedIndices.push(newOptions.length - 1);\n        }\n        this.setState({\n          currentOptions: newOptions,\n          selectedIndices: selectedIndices,\n        });\n      }\n    } else if (currentPendingValueValidIndex >= 0) {\n      // Since we are not allowing freeform, we must have a matching\n      // to be able to update state\n      this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\n    } else if (currentPendingValueValidIndexOnHover >= 0) {\n      // If all else failed and we were hovering over an item, select it\n      this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\n    }\n\n    // Finally, clear the pending info\n    this._clearPendingInfo();\n  }\n\n  // Render Callout container and pass in list\n  private _onRenderContainer = (props: IComboBoxProps): JSX.Element => {\n    const {\n      onRenderList,\n      calloutProps,\n      dropdownWidth,\n      dropdownMaxWidth,\n      onRenderUpperContent = this._onRenderUpperContent,\n      onRenderLowerContent = this._onRenderLowerContent,\n      useComboBoxAsMenuWidth,\n      persistMenu,\n      shouldRestoreFocus = true,\n    } = props;\n\n    const { isOpen } = this.state;\n\n    const comboBoxMenuWidth =\n      useComboBoxAsMenuWidth && this._comboBoxWrapper.current\n        ? this._comboBoxWrapper.current.clientWidth + 2\n        : undefined;\n\n    return (\n      <Callout\n        isBeakVisible={false}\n        gapSpace={0}\n        doNotLayer={false}\n        directionalHint={DirectionalHint.bottomLeftEdge}\n        directionalHintFixed={false}\n        {...calloutProps}\n        onLayerMounted={this._onLayerMounted}\n        className={css(this._classNames.callout, calloutProps ? calloutProps.className : undefined)}\n        target={this._comboBoxWrapper.current}\n        onDismiss={this._onDismiss}\n        onMouseDown={this._onCalloutMouseDown}\n        onScroll={this._onScroll}\n        setInitialFocus={false}\n        calloutWidth={\n          useComboBoxAsMenuWidth && this._comboBoxWrapper.current\n            ? comboBoxMenuWidth && comboBoxMenuWidth\n            : dropdownWidth\n        }\n        calloutMaxWidth={dropdownMaxWidth ? dropdownMaxWidth : comboBoxMenuWidth}\n        hidden={persistMenu ? !isOpen : undefined}\n        shouldRestoreFocus={shouldRestoreFocus}\n      >\n        {onRenderUpperContent(this.props, this._onRenderUpperContent)}\n        <div className={this._classNames.optionsContainerWrapper} ref={this._comboBoxMenu}>\n          {(onRenderList as any)({ ...props }, this._onRenderList)}\n        </div>\n        {onRenderLowerContent(this.props, this._onRenderLowerContent)}\n      </Callout>\n    );\n  };\n\n  private _onCalloutLayerMounted() {\n    // In persistMenu mode _onLayerMounted is only called once for the lifetime\n    // of the component. Any functionality required for callout \"on mount\" can\n    // go here so that we can also call it again during callout dismissal to reset\n    // object state.\n    this._gotMouseMove = false;\n  }\n\n  private _onLayerMounted = () => {\n    this._onCalloutLayerMounted();\n\n    if (this.props.calloutProps && this.props.calloutProps.onLayerMounted) {\n      this.props.calloutProps.onLayerMounted();\n    }\n  };\n\n  private _onRenderLabel = (onRenderLabelProps: IOnRenderComboBoxLabelProps): JSX.Element | null => {\n    const { label, disabled, required } = onRenderLabelProps.props;\n\n    if (label) {\n      return (\n        <Label id={this._id + '-label'} disabled={disabled} required={required} className={this._classNames.label}>\n          {label}\n          {onRenderLabelProps.multiselectAccessibleText && (\n            <span className={this._classNames.screenReaderText}>{onRenderLabelProps.multiselectAccessibleText}</span>\n          )}\n        </Label>\n      );\n    }\n\n    return null;\n  };\n\n  // Render List of items\n  private _onRenderList = (props: IComboBoxProps): JSX.Element => {\n    const { onRenderItem, options } = props;\n\n    const id = this._id;\n    return (\n      <div\n        id={id + '-list'}\n        className={this._classNames.optionsContainer}\n        aria-labelledby={id + '-label'}\n        role=\"listbox\"\n      >\n        {options.map(item => (onRenderItem as any)(item, this._onRenderItem))}\n      </div>\n    );\n  };\n\n  // Render items\n  private _onRenderItem = (item: IComboBoxOption): JSX.Element | null => {\n    switch (item.itemType) {\n      case SelectableOptionMenuItemType.Divider:\n        return this._renderSeparator(item);\n      case SelectableOptionMenuItemType.Header:\n        return this._renderHeader(item);\n      default:\n        return this._renderOption(item);\n    }\n  };\n\n  // Default _onRenderLowerContent function returns nothing\n  private _onRenderLowerContent = (): null => {\n    return null;\n  };\n\n  // Default _onRenderUpperContent function returns nothing\n  private _onRenderUpperContent = (): null => {\n    return null;\n  };\n\n  // Render separator\n  private _renderSeparator(item: IComboBoxOption): JSX.Element | null {\n    const { index, key } = item;\n\n    if (index && index > 0) {\n      return <div role=\"separator\" key={key} className={this._classNames.divider} />;\n    }\n    return null;\n  }\n\n  private _renderHeader(item: IComboBoxOption): JSX.Element {\n    const { onRenderOption = this._onRenderOptionContent } = this.props;\n\n    return (\n      <div key={item.key} className={this._classNames.header}>\n        {onRenderOption(item, this._onRenderOptionContent)}\n      </div>\n    );\n  }\n\n  private _renderOption = (item: IComboBoxOption): JSX.Element => {\n    const { onRenderOption = this._onRenderOptionContent } = this.props;\n    const id = this._id;\n    const isSelected: boolean = this._isOptionSelected(item.index);\n    const isChecked: boolean = this._isOptionChecked(item.index);\n    const optionStyles = this._getCurrentOptionStyles(item);\n    const optionClassNames = getComboBoxOptionClassNames(this._getCurrentOptionStyles(item));\n    const title = this._getPreviewText(item);\n\n    const onRenderCheckboxLabel = () => onRenderOption(item, this._onRenderOptionContent);\n\n    const getOptionComponent = () => {\n      return !this.props.multiSelect ? (\n        <CommandButton\n          id={id + '-list' + item.index}\n          key={item.key}\n          data-index={item.index}\n          styles={optionStyles}\n          checked={isSelected}\n          className={'ms-ComboBox-option'}\n          onClick={this._onItemClick(item)}\n          // eslint-disable-next-line react/jsx-no-bind\n          onMouseEnter={this._onOptionMouseEnter.bind(this, item.index)}\n          // eslint-disable-next-line react/jsx-no-bind\n          onMouseMove={this._onOptionMouseMove.bind(this, item.index)}\n          onMouseLeave={this._onOptionMouseLeave}\n          role=\"option\"\n          aria-selected={isSelected ? 'true' : 'false'}\n          ariaLabel={this._getPreviewText(item)}\n          disabled={item.disabled}\n          title={title}\n        >\n          {\n            <span className={optionClassNames.optionTextWrapper} ref={isSelected ? this._selectedElement : undefined}>\n              {onRenderOption(item, this._onRenderOptionContent)}\n            </span>\n          }\n        </CommandButton>\n      ) : (\n        <Checkbox\n          id={id + '-list' + item.index}\n          ariaLabel={this._getPreviewText(item)}\n          key={item.key}\n          data-index={item.index}\n          styles={optionStyles}\n          className={'ms-ComboBox-option'}\n          data-is-focusable={true}\n          onChange={this._onItemClick(item)}\n          label={item.text}\n          role=\"option\"\n          checked={isChecked}\n          title={title}\n          disabled={item.disabled}\n          // eslint-disable-next-line react/jsx-no-bind\n          onRenderLabel={onRenderCheckboxLabel}\n          inputProps={{\n            'aria-selected': isSelected ? 'true' : 'false',\n          }}\n        />\n      );\n    };\n\n    return (\n      <ComboBoxOptionWrapper\n        key={item.key}\n        index={item.index}\n        disabled={item.disabled}\n        isSelected={isSelected}\n        isChecked={isChecked}\n        text={item.text}\n        // eslint-disable-next-line react/jsx-no-bind\n        render={getOptionComponent}\n        data={item.data}\n      />\n    );\n  };\n\n  /**\n   * If we are coming from a mouseOut:\n   * there is no visible selected option.\n   *\n   * Else if We are hovering over an item:\n   * that gets the selected look.\n   *\n   * Else:\n   * Use the current valid pending index if it exists OR\n   * we do not have a valid index and we currently have a pending input value,\n   * otherwise use the selected index\n   * */\n  private _isOptionSelected(index: number | undefined): boolean {\n    const { currentPendingValueValidIndexOnHover } = this.state;\n\n    // If the hover state is set to clearAll, don't show a selected index.\n    // Note, this happens when the user moused out of the menu items\n    if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n      return false;\n    }\n\n    return this._getPendingSelectedIndex(true /* includePendingValue */) === index ? true : false;\n  }\n\n  private _isOptionChecked(index: number | undefined): boolean {\n    if (this.props.multiSelect && index !== undefined && this.state.selectedIndices) {\n      let idxOfSelectedIndex = -1;\n\n      idxOfSelectedIndex = this.state.selectedIndices.indexOf(index);\n      return idxOfSelectedIndex >= 0;\n    }\n    return false;\n  }\n\n  /**\n   * Gets the pending selected index taking into account hover, valueValidIndex, and selectedIndex\n   * @param includeCurrentPendingValue - Should we include the currentPendingValue when\n   * finding the index\n   */\n  private _getPendingSelectedIndex(includeCurrentPendingValue: boolean): number {\n    const { currentPendingValueValidIndexOnHover, currentPendingValueValidIndex, currentPendingValue } = this.state;\n\n    return currentPendingValueValidIndexOnHover >= 0\n      ? currentPendingValueValidIndexOnHover\n      : currentPendingValueValidIndex >= 0 ||\n        (includeCurrentPendingValue && currentPendingValue !== null && currentPendingValue !== undefined)\n      ? currentPendingValueValidIndex\n      : this.props.multiSelect\n      ? 0\n      : this._getFirstSelectedIndex();\n  }\n\n  /**\n   * Mouse clicks to headers, dividers and scrollbar should not make input lose focus\n   */\n  private _onCalloutMouseDown: ICalloutProps['onMouseDown'] = ev => {\n    ev.preventDefault();\n  };\n\n  /**\n   * Scroll handler for the callout to make sure the mouse events\n   * for updating focus are not interacting during scroll\n   */\n  private _onScroll = () => {\n    if (!this._isScrollIdle && this._scrollIdleTimeoutId !== undefined) {\n      this._async.clearTimeout(this._scrollIdleTimeoutId);\n      this._scrollIdleTimeoutId = undefined;\n    } else {\n      this._isScrollIdle = false;\n    }\n\n    this._scrollIdleTimeoutId = this._async.setTimeout(() => {\n      this._isScrollIdle = true;\n    }, ScrollIdleDelay);\n  };\n\n  /**\n   * Scroll the selected element into view\n   */\n  private _scrollIntoView(): void {\n    const { onScrollToItem, scrollSelectedToTop } = this.props;\n\n    const { currentPendingValueValidIndex, currentPendingValue } = this.state;\n\n    if (onScrollToItem) {\n      // Use the custom scroll handler\n      onScrollToItem(\n        currentPendingValueValidIndex >= 0 || currentPendingValue !== ''\n          ? currentPendingValueValidIndex\n          : this._getFirstSelectedIndex(),\n      );\n    } else if (this._selectedElement.current && this._selectedElement.current.offsetParent) {\n      // We are using refs, scroll the ref into view\n      if (scrollSelectedToTop) {\n        this._selectedElement.current.offsetParent.scrollIntoView(true);\n      } else {\n        let alignToTop = true;\n\n        if (this._comboBoxMenu.current && this._comboBoxMenu.current.offsetParent) {\n          const scrollableParentRect = this._comboBoxMenu.current.offsetParent.getBoundingClientRect();\n          const selectedElementRect = this._selectedElement.current.offsetParent.getBoundingClientRect();\n\n          // If we are completely in view then we do not need to scroll\n          if (\n            scrollableParentRect.top <= selectedElementRect.top &&\n            scrollableParentRect.top + scrollableParentRect.height >=\n              selectedElementRect.top + selectedElementRect.height\n          ) {\n            return;\n          }\n\n          // If we are lower than the scrollable parent viewport then we should align to the bottom\n          if (\n            scrollableParentRect.top + scrollableParentRect.height <=\n            selectedElementRect.top + selectedElementRect.height\n          ) {\n            alignToTop = false;\n          }\n        }\n\n        this._selectedElement.current.offsetParent.scrollIntoView(alignToTop);\n      }\n    }\n  }\n\n  private _onRenderOptionContent = (item: IComboBoxOption): JSX.Element => {\n    const optionClassNames = getComboBoxOptionClassNames(this._getCurrentOptionStyles(item));\n    return <span className={optionClassNames.optionText}>{item.text}</span>;\n  };\n\n  /**\n   * Click handler for the menu items\n   * to select the item and also close the menu\n   * @param index - the index of the item that was clicked\n   */\n  private _onItemClick(item: IComboBoxOption): (ev: any) => void {\n    const { onItemClick } = this.props;\n    const { index } = item;\n\n    return (ev: any): void => {\n      // only close the callout when it's in single-select mode\n      if (!this.props.multiSelect) {\n        // ensure that focus returns to the input, not the button\n        this._autofill.current && this._autofill.current.focus();\n        this.setState({\n          isOpen: false,\n        });\n      }\n\n      // Continue processing the click only after\n      // performing menu close / control focus(inner working)\n      onItemClick && onItemClick(ev, item, index);\n      this._setSelectedIndex(index as number, ev);\n    };\n  }\n\n  /**\n   * Handles dismissing (cancelling) the menu\n   */\n  private _onDismiss = (): void => {\n    const { onMenuDismiss } = this.props;\n    if (onMenuDismiss) {\n      onMenuDismiss();\n    }\n\n    // In persistMode we need to simulate callout layer mount\n    // since that only happens once. We do it on dismiss since\n    // it works either way.\n    if (this.props.persistMenu) {\n      this._onCalloutLayerMounted();\n    }\n\n    // close the menu\n    this._setOpenStateAndFocusOnClose(false /* isOpen */, false /* focusInputAfterClose */);\n\n    // reset the selected index\n    // to the last value state\n    this._resetSelectedIndex();\n  };\n\n  /**\n   * Get the indices of the options that are marked as selected\n   * @param options - the comboBox options\n   * @param selectedKeys - the known selected keys to find\n   * @returns - an array of the indices of the selected options, empty array if nothing is selected\n   */\n  private _getSelectedIndices(\n    options: IComboBoxOption[] | undefined,\n    selectedKeys: (string | number | undefined)[],\n  ): number[] {\n    if (!options || !selectedKeys) {\n      return [];\n    }\n\n    const selectedIndices: { [key: number]: boolean } = {};\n    options.forEach((option: IComboBoxOption, index: number) => {\n      if (option.selected) {\n        selectedIndices[index] = true;\n      }\n    });\n\n    for (const selectedKey of selectedKeys) {\n      const index = findIndex(options, option => option.key === selectedKey);\n      if (index > -1) {\n        selectedIndices[index] = true;\n      }\n    }\n\n    return Object.keys(selectedIndices)\n      .map(Number)\n      .sort();\n  }\n\n  /**\n   * Reset the selected index by clearing the\n   * input (of any pending text), clearing the pending state,\n   * and setting the suggested display value to the last\n   * selected state text\n   */\n  private _resetSelectedIndex(): void {\n    const { currentOptions } = this.state;\n    this._clearPendingInfo();\n\n    const selectedIndex: number = this._getFirstSelectedIndex();\n    if (selectedIndex > 0 && selectedIndex < currentOptions.length) {\n      this.setState({\n        suggestedDisplayValue: currentOptions[selectedIndex].text,\n      });\n    } else if (this.props.text) {\n      // If we had a value initially, restore it\n      this.setState({\n        suggestedDisplayValue: this.props.text,\n      });\n    }\n  }\n\n  /**\n   * Clears the pending info state\n   */\n  private _clearPendingInfo(): void {\n    this._processingClearPendingInfo = true;\n\n    this.setState(\n      {\n        currentPendingValue: undefined,\n        currentPendingValueValidIndex: -1,\n        suggestedDisplayValue: undefined,\n        currentPendingValueValidIndexOnHover: HoverStatus.default,\n      },\n      this._onAfterClearPendingInfo,\n    );\n  }\n\n  private _onAfterClearPendingInfo = () => {\n    this._processingClearPendingInfo = false;\n  };\n\n  /**\n   * Set the pending info\n   * @param currentPendingValue - new pending value to set\n   * @param currentPendingValueValidIndex - new pending value index to set\n   * @param suggestedDisplayValue - new suggest display value to set\n   */\n  private _setPendingInfo(\n    currentPendingValue?: string,\n    currentPendingValueValidIndex: number = -1,\n    suggestedDisplayValue?: string,\n  ): void {\n    if (this._processingClearPendingInfo) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValue: this._normalizeToString(currentPendingValue),\n      currentPendingValueValidIndex: currentPendingValueValidIndex,\n      suggestedDisplayValue: suggestedDisplayValue,\n      currentPendingValueValidIndexOnHover: HoverStatus.default,\n    });\n  }\n\n  /**\n   * Set the pending info from the given index\n   * @param index - the index to set the pending info from\n   */\n  private _setPendingInfoFromIndex(index: number): void {\n    const { currentOptions } = this.state;\n\n    if (index >= 0 && index < currentOptions.length) {\n      const option = currentOptions[index];\n      this._setPendingInfo(this._getPreviewText(option), index, this._getPreviewText(option));\n    } else {\n      this._clearPendingInfo();\n    }\n  }\n\n  /**\n   * Sets the pending info for the comboBox\n   * @param index - the index to search from\n   * @param searchDirection - the direction to search\n   */\n  private _setPendingInfoFromIndexAndDirection(index: number, searchDirection: SearchDirection): void {\n    const { currentOptions } = this.state;\n\n    // update index to allow content to wrap\n    if (searchDirection === SearchDirection.forward && index >= currentOptions.length - 1) {\n      index = -1;\n    } else if (searchDirection === SearchDirection.backward && index <= 0) {\n      index = currentOptions.length;\n    }\n\n    // get the next \"valid\" index\n    const indexUpdate = this._getNextSelectableIndex(index, searchDirection);\n\n    // if the two indicies are equal we didn't move and\n    // we should attempt to get  get the first/last \"valid\" index to use\n    // (Note, this takes care of the potential cases where the first/last\n    // item is not focusable), otherwise use the updated index\n    if (index === indexUpdate) {\n      if (searchDirection === SearchDirection.forward) {\n        index = this._getNextSelectableIndex(-1, searchDirection);\n      } else if (searchDirection === SearchDirection.backward) {\n        index = this._getNextSelectableIndex(currentOptions.length, searchDirection);\n      }\n    } else {\n      index = indexUpdate;\n    }\n\n    if (this._indexWithinBounds(currentOptions, index)) {\n      this._setPendingInfoFromIndex(index);\n    }\n  }\n\n  private _notifyPendingValueChanged(prevState: IComboBoxState): void {\n    const { onPendingValueChanged } = this.props;\n\n    if (!onPendingValueChanged) {\n      return;\n    }\n\n    const {\n      currentPendingValue,\n      currentOptions,\n      currentPendingValueValidIndex,\n      currentPendingValueValidIndexOnHover,\n    } = this.state;\n\n    let newPendingIndex: number | undefined = undefined;\n    let newPendingValue: string | undefined = undefined;\n\n    if (\n      currentPendingValueValidIndexOnHover !== prevState.currentPendingValueValidIndexOnHover &&\n      this._indexWithinBounds(currentOptions, currentPendingValueValidIndexOnHover)\n    ) {\n      // Set new pending index if hover index was changed\n      newPendingIndex = currentPendingValueValidIndexOnHover;\n    } else if (\n      currentPendingValueValidIndex !== prevState.currentPendingValueValidIndex &&\n      this._indexWithinBounds(currentOptions, currentPendingValueValidIndex)\n    ) {\n      // Set new pending index if currentPendingValueValidIndex was changed\n      newPendingIndex = currentPendingValueValidIndex;\n    } else if (currentPendingValue !== prevState.currentPendingValue) {\n      // Set pendingValue in the case it was changed and no index was changed\n      newPendingValue = currentPendingValue;\n    }\n\n    // Notify when there is a new pending index/value. Also, if there is a pending value, it needs to send undefined.\n    if (newPendingIndex !== undefined || newPendingValue !== undefined || this._hasPendingValue) {\n      onPendingValueChanged(\n        newPendingIndex !== undefined ? currentOptions[newPendingIndex] : undefined,\n        newPendingIndex,\n        newPendingValue,\n      );\n      this._hasPendingValue = newPendingIndex !== undefined || newPendingValue !== undefined;\n    }\n  }\n\n  /**\n   * Sets the isOpen state and updates focusInputAfterClose\n   */\n  private _setOpenStateAndFocusOnClose(isOpen: boolean, focusInputAfterClose: boolean): void {\n    this._focusInputAfterClose = focusInputAfterClose;\n    this.setState({\n      isOpen: isOpen,\n    });\n  }\n\n  /**\n   * Handle keydown on the input\n   * @param ev - The keyboard event that was fired\n   */\n  private _onInputKeyDown = (ev: React.KeyboardEvent<HTMLElement | Autofill>): void => {\n    const { disabled, allowFreeform, autoComplete } = this.props;\n    const { isOpen, currentOptions, currentPendingValueValidIndexOnHover } = this.state;\n\n    // Take note if we are processing an alt (option) or meta (command) keydown.\n    // See comment in _onInputKeyUp for reasoning.\n    this._lastKeyDownWasAltOrMeta = this._isAltOrMeta(ev);\n\n    if (disabled) {\n      this._handleInputWhenDisabled(ev);\n      return;\n    }\n\n    let index = this._getPendingSelectedIndex(false /* includeCurrentPendingValue */);\n\n    switch (ev.which) {\n      case KeyCodes.enter:\n        if (this._autofill.current && this._autofill.current.inputElement) {\n          this._autofill.current.inputElement.select();\n        }\n\n        this._submitPendingValue(ev);\n        if (this.props.multiSelect && isOpen) {\n          this.setState({\n            currentPendingValueValidIndex: index,\n          });\n        } else {\n          // On enter submit the pending value\n          if (\n            isOpen ||\n            ((!allowFreeform ||\n              this.state.currentPendingValue === undefined ||\n              this.state.currentPendingValue === null ||\n              this.state.currentPendingValue.length <= 0) &&\n              this.state.currentPendingValueValidIndex < 0)\n          ) {\n            // if we are open or\n            // if we are not allowing freeform or\n            // our we have no pending value\n            // and no valid pending index\n            // flip the open state\n            this.setState({\n              isOpen: !isOpen,\n            });\n          }\n        }\n        break;\n\n      case KeyCodes.tab:\n        // On enter submit the pending value\n        if (!this.props.multiSelect) {\n          this._submitPendingValue(ev);\n        }\n\n        // If we are not allowing freeform\n        // or the comboBox is open, flip the open state\n        if (isOpen) {\n          this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);\n        }\n\n        // Allow TAB to propigate\n        return;\n\n      case KeyCodes.escape:\n        // reset the selected index\n        this._resetSelectedIndex();\n\n        // Close the menu if opened\n        if (isOpen) {\n          this.setState({\n            isOpen: false,\n          });\n        } else {\n          return;\n        }\n        break;\n\n      case KeyCodes.up:\n        // if we are in clearAll state (e.g. the user as hovering\n        // and has since mousedOut of the menu items),\n        // go to the last index\n        if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n          index = this.state.currentOptions.length;\n        }\n\n        if (ev.altKey || ev.metaKey) {\n          // Close the menu if it is open and break so\n          // that the event get stopPropagation and prevent default.\n          // Otherwise, we need to let the event continue to propagate\n          if (isOpen) {\n            this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);\n            break;\n          }\n\n          return;\n        }\n\n        // Go to the previous option\n        this._setPendingInfoFromIndexAndDirection(index, SearchDirection.backward);\n        break;\n\n      case KeyCodes.down:\n        // Expand the comboBox on ALT + DownArrow\n        if (ev.altKey || ev.metaKey) {\n          this._setOpenStateAndFocusOnClose(true /* isOpen */, true /* focusInputAfterClose */);\n        } else {\n          // if we are in clearAll state (e.g. the user as hovering\n          // and has since mousedOut of the menu items),\n          // go to the first index\n          if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\n            index = -1;\n          }\n\n          // Got to the next option\n          this._setPendingInfoFromIndexAndDirection(index, SearchDirection.forward);\n        }\n        break;\n\n      case KeyCodes.home:\n      case KeyCodes.end:\n        if (allowFreeform) {\n          return;\n        }\n\n        // Set the initial values to respond to HOME\n        // which goes to the first selectable option\n        index = -1;\n        let directionToSearch = SearchDirection.forward;\n\n        // If end, update the values to respond to END\n        // which goes to the last selectable option\n        if (ev.which === KeyCodes.end) {\n          index = currentOptions.length;\n          directionToSearch = SearchDirection.backward;\n        }\n\n        this._setPendingInfoFromIndexAndDirection(index, directionToSearch);\n        break;\n\n      /* eslint-disable no-fallthrough */\n      case KeyCodes.space:\n        // event handled in _onComboBoxKeyUp\n        if (!allowFreeform && autoComplete === 'off') {\n          break;\n        }\n\n      default:\n        /* eslint-enable no-fallthrough */\n        // are we processing a function key? if so bail out\n        if (ev.which >= 112 /* F1 */ && ev.which <= 123 /* F12 */) {\n          return;\n        }\n\n        // If we get here and we got either and ALT key\n        // or meta key, let the event propagate\n        if (ev.keyCode === KeyCodes.alt || ev.key === 'Meta' /* && isOpen */) {\n          return;\n        }\n\n        // If we are not allowing freeform and\n        // allowing autoComplete, handle the input here\n        // since we have marked the input as readonly\n        if (!allowFreeform && autoComplete === 'on') {\n          this._onInputChange(ev.key);\n          break;\n        }\n\n        // allow the key to propagate by default\n        return;\n    }\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  /**\n   * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n   */\n  private _isAltOrMeta(ev: React.KeyboardEvent<HTMLElement | Autofill>): boolean {\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\n  }\n\n  /**\n   * Handle keyup on the input\n   * @param ev - the keyboard event that was fired\n   */\n  private _onInputKeyUp = (ev: React.KeyboardEvent<HTMLElement | Autofill>): void => {\n    const { disabled, allowFreeform, autoComplete } = this.props;\n    const isOpen = this.state.isOpen;\n\n    // We close the menu on key up only if ALL of the following are true:\n    // - Most recent key down was alt or meta (command)\n    // - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n    //   expand/collapse the menu)\n    // - We're not on a Mac (or iOS)\n    // This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n    // closing any open context menus. There is not a similar behavior on Macs.\n    const keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && this._isAltOrMeta(ev);\n    this._lastKeyDownWasAltOrMeta = false;\n    const shouldHandleKey = keyPressIsAltOrMetaAlone && !(isMac() || isIOS());\n\n    if (disabled) {\n      this._handleInputWhenDisabled(ev);\n      return;\n    }\n\n    switch (ev.which) {\n      case KeyCodes.space:\n        // If we are not allowing freeform and are not autoComplete\n        // make space expand/collapse the comboBox\n        // and allow the event to propagate\n        if (!allowFreeform && autoComplete === 'off') {\n          this._setOpenStateAndFocusOnClose(!isOpen, !!isOpen);\n        }\n        return;\n      default:\n        if (shouldHandleKey && isOpen) {\n          this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);\n        } else {\n          if (this.state.focusState === 'focusing' && this.props.openOnKeyboardFocus) {\n            this.setState({ isOpen: true });\n          }\n          if (this.state.focusState !== 'focused') {\n            this.setState({ focusState: 'focused' });\n          }\n        }\n        return;\n    }\n  };\n\n  private _onOptionMouseEnter(index: number): void {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: index,\n    });\n  }\n\n  private _onOptionMouseMove(index: number): void {\n    this._gotMouseMove = true;\n\n    if (!this._isScrollIdle || this.state.currentPendingValueValidIndexOnHover === index) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: index,\n    });\n  }\n\n  private _onOptionMouseLeave = () => {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    // Ignore the event in persistMenu mode if the callout has\n    // closed. This is to avoid clearing the visuals on item click.\n    if (this.props.persistMenu && !this.state.isOpen) {\n      return;\n    }\n\n    this.setState({\n      currentPendingValueValidIndexOnHover: HoverStatus.clearAll,\n    });\n  };\n\n  private _shouldIgnoreMouseEvent(): boolean {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  }\n\n  /**\n   * Handle dismissing the menu and\n   * eating the required key event when disabled\n   * @param ev - the keyboard event that was fired\n   */\n  private _handleInputWhenDisabled(ev: React.KeyboardEvent<HTMLElement | Autofill> | null): void {\n    // If we are disabled, close the menu (if needed)\n    // and eat all keystokes other than TAB or ESC\n    if (this.props.disabled) {\n      if (this.state.isOpen) {\n        this.setState({ isOpen: false });\n      }\n\n      // When disabled stop propagation and prevent default\n      // of the event unless we have a tab, escape, or function key\n      if (\n        ev !== null &&\n        ev.which !== KeyCodes.tab &&\n        ev.which !== KeyCodes.escape &&\n        (ev.which < 112 /* F1 */ || ev.which > 123) /* F12 */\n      ) {\n        ev.stopPropagation();\n        ev.preventDefault();\n      }\n    }\n  }\n\n  /**\n   * Click handler for the button of the comboBox\n   * and the input when not allowing freeform. This\n   * toggles the expand/collapse state of the comboBox (if enbled)\n   */\n  private _onComboBoxClick = (): void => {\n    const { disabled } = this.props;\n    const { isOpen } = this.state;\n\n    if (!disabled) {\n      this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);\n      this.setState({ focusState: 'focused' });\n    }\n  };\n\n  /**\n   * Click handler for the autofill.\n   */\n  private _onAutofillClick = (): void => {\n    const { disabled, allowFreeform } = this.props;\n\n    if (allowFreeform && !disabled) {\n      this.focus(this.state.isOpen || this._processingTouch);\n    } else {\n      this._onComboBoxClick();\n    }\n  };\n\n  private _onTouchStart: () => void = () => {\n    if (this._comboBoxWrapper.current && !('onpointerdown' in this._comboBoxWrapper)) {\n      this._handleTouchAndPointerEvent();\n    }\n  };\n\n  private _onPointerDown = (ev: PointerEvent): void => {\n    if (ev.pointerType === 'touch') {\n      this._handleTouchAndPointerEvent();\n\n      ev.preventDefault();\n      ev.stopImmediatePropagation();\n    }\n  };\n\n  private _handleTouchAndPointerEvent() {\n    // If we already have an existing timeeout from a previous touch and pointer event\n    // cancel that timeout so we can set a nwe one.\n    if (this._lastTouchTimeoutId !== undefined) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n      this._lastTouchTimeoutId = undefined;\n    }\n    this._processingTouch = true;\n\n    this._lastTouchTimeoutId = this._async.setTimeout(() => {\n      this._processingTouch = false;\n      this._lastTouchTimeoutId = undefined;\n    }, TouchIdleDelay);\n  }\n\n  /**\n   * Get the styles for the current option.\n   * @param item - Item props for the current option\n   */\n  private _getCaretButtonStyles(): IButtonStyles {\n    const { caretDownButtonStyles: customCaretDownButtonStyles } = this.props;\n    return getCaretDownButtonStyles(this.props.theme!, customCaretDownButtonStyles);\n  }\n\n  /**\n   * Get the styles for the current option.\n   * @param item - Item props for the current option\n   */\n  private _getCurrentOptionStyles(item: IComboBoxOption): Partial<IComboBoxOptionStyles> {\n    const { comboBoxOptionStyles: customStylesForAllOptions } = this.props;\n    const { styles: customStylesForCurrentOption } = item;\n\n    return getOptionStyles(\n      this.props.theme!,\n      customStylesForAllOptions,\n      customStylesForCurrentOption,\n      this._isPendingOption(item),\n      item.hidden,\n    );\n  }\n\n  /**\n   * Get the aria-activedescendant value for the comboxbox.\n   * @returns the id of the current focused combo item, otherwise the id of the currently selected element,\n   * null otherwise\n   */\n  private _getAriaActiveDescendantValue(): string | undefined {\n    let descendantText =\n      this.state.isOpen && this.state.selectedIndices && this.state.selectedIndices.length > 0\n        ? this._id + '-list' + this.state.selectedIndices[0]\n        : undefined;\n    if (this.state.isOpen && this._hasFocus() && this.state.currentPendingValueValidIndex !== -1) {\n      descendantText = this._id + '-list' + this.state.currentPendingValueValidIndex;\n    }\n    return descendantText;\n  }\n\n  /**\n   * Get the aria autocomplete value for the Combobox\n   * @returns 'inline' if auto-complete automatically dynamic, 'both' if we have a list of possible values to pick from\n   * and can dynamically populate input, and 'none' if auto-complete is not enabled as we can't give user inputs.\n   */\n  private _getAriaAutoCompleteValue(): 'none' | 'inline' | 'list' | 'both' | undefined {\n    const autoComplete = !this.props.disabled && this.props.autoComplete === 'on';\n    return autoComplete ? (this.props.allowFreeform ? 'inline' : 'both') : 'none';\n  }\n\n  private _isPendingOption(item: IComboBoxOption): boolean {\n    return item && item.index === this.state.currentPendingValueValidIndex;\n  }\n\n  /**\n   * Given default selected key(s) and selected key(s), return the selected keys(s).\n   * When default selected key(s) are available, they take precedence and return them instead of selected key(s).\n   *\n   * @returns No matter what specific types the input parameters are, always return an array of\n   *  either strings or numbers instead of premitive type.  This normlization makes caller's logic easier.\n   */\n  private _buildDefaultSelectedKeys(\n    defaultSelectedKey: string | number | string[] | number[] | null | undefined,\n    selectedKey: string | number | string[] | number[] | null | undefined,\n  ): string[] | number[] {\n    const selectedKeys: string[] | number[] = this._buildSelectedKeys(defaultSelectedKey);\n    if (selectedKeys.length) {\n      return selectedKeys;\n    }\n    return this._buildSelectedKeys(selectedKey);\n  }\n\n  private _buildSelectedKeys(\n    selectedKey: string | number | string[] | number[] | null | undefined,\n  ): string[] | number[] {\n    if (selectedKey === undefined) {\n      return [];\n    }\n\n    // need to cast here so typescript does not complain\n    return (selectedKey instanceof Array ? selectedKey : [selectedKey]) as string[] | number[];\n  }\n\n  // For scenarios where the option's text prop contains embedded styles, we use the option's\n  // ariaLabel value as the text in the input and for autocomplete matching. We know to use this\n  // when the useAriaLabelAsText prop is set to true\n  private _getPreviewText(item: IComboBoxOption): string {\n    return item.useAriaLabelAsText && item.ariaLabel ? item.ariaLabel : item.text;\n  }\n\n  private _normalizeToString(value?: string): string {\n    return value || '';\n  }\n\n  /**\n   * Returns true if the component has some kind of focus. If it's either focusing or if it's focused\n   */\n  private _hasFocus() {\n    return this.state.focusState !== 'none';\n  }\n}\n"]}