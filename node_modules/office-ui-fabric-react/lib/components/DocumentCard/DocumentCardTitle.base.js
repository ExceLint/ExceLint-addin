import * as tslib_1 from "tslib";
import * as React from 'react';
import { BaseComponent, classNamesFunction } from '../../Utilities';
var getClassNames = classNamesFunction();
var TRUNCATION_SEPARATOR = '&hellip;';
var TRUNCATION_MINIMUM_LENGTH = 40; // This is the length we know can fit into the min width of DocumentCard.
var TRUNCATION_MAXIMUM_LENGTH = 90 - TRUNCATION_SEPARATOR.length;
// This is the length we know can fit into the min width 2 lines of DocumentCard.
var TRUNCATION_MINI_LENGTH_SECONDARY = 80;
var TRUNCATION_MAX_LENGTH_SECONDARY = 130 - TRUNCATION_SEPARATOR.length;
var TRUNCATION_FIRST_PIECE_LONGER_BY = 10;
var TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD = 5;
var DocumentCardTitleBase = /** @class */ (function (_super) {
    tslib_1.__extends(DocumentCardTitleBase, _super);
    function DocumentCardTitleBase(props) {
        var _this = _super.call(this, props) || this;
        _this._titleElement = React.createRef();
        _this._startTruncation = function (props) {
            var originalTitle = props.title;
            _this._isTruncated = false;
            var miniLength = props.showAsSecondaryTitle ? TRUNCATION_MINI_LENGTH_SECONDARY : TRUNCATION_MINIMUM_LENGTH;
            var maxLength = props.showAsSecondaryTitle ? TRUNCATION_MAX_LENGTH_SECONDARY : TRUNCATION_MAXIMUM_LENGTH;
            // If the title is really short, there's no need to truncate it
            if (originalTitle && originalTitle.length >= miniLength) {
                // Break the text into two pieces for assembly later
                if (originalTitle.length > maxLength) {
                    // The text is really long, so we can take a chunk out of the middle so the two pieces combine for the maximum length
                    _this._isTruncated = true;
                    _this.setState({
                        truncatedTitleFirstPiece: originalTitle.slice(0, maxLength / 2 + TRUNCATION_FIRST_PIECE_LONGER_BY),
                        truncatedTitleSecondPiece: originalTitle.slice(originalTitle.length - (maxLength / 2 - TRUNCATION_FIRST_PIECE_LONGER_BY))
                    });
                }
                else {
                    // The text is not so long, so we'll just break it into two pieces
                    _this.setState({
                        truncatedTitleFirstPiece: originalTitle.slice(0, Math.ceil(originalTitle.length / 2) + TRUNCATION_FIRST_PIECE_LONGER_BY),
                        truncatedTitleSecondPiece: originalTitle.slice(originalTitle.length - Math.floor(originalTitle.length / 2) + TRUNCATION_FIRST_PIECE_LONGER_BY)
                    });
                }
            }
            // Save the width we just started truncation at, so that later we will only update truncation if necessary
            if (_this._titleElement.current) {
                _this._truncatedTitleAtWidth = _this._titleElement.current.clientWidth;
            }
        };
        _this.state = {
            truncatedTitleFirstPiece: '',
            truncatedTitleSecondPiece: ''
        };
        return _this;
    }
    DocumentCardTitleBase.prototype.componentDidMount = function () {
        var _a = this.props, title = _a.title, shouldTruncate = _a.shouldTruncate, showAsSecondaryTitle = _a.showAsSecondaryTitle;
        var miniLength = showAsSecondaryTitle ? TRUNCATION_MINI_LENGTH_SECONDARY : TRUNCATION_MINIMUM_LENGTH;
        if (shouldTruncate && title && title.length > miniLength) {
            if (this._doesTitleOverflow()) {
                this._startTruncation(this.props);
            }
            this._events.on(window, 'resize', this._updateTruncation);
        }
    };
    DocumentCardTitleBase.prototype.componentWillReceiveProps = function (newProps) {
        this._events.off(window, 'resize');
        this._isTruncated = false;
        var miniLength = newProps.showAsSecondaryTitle ? TRUNCATION_MINI_LENGTH_SECONDARY : TRUNCATION_MINIMUM_LENGTH;
        if (newProps.shouldTruncate && newProps.title && newProps.title.length > miniLength) {
            this._startTruncation(newProps);
            this._events.on(window, 'resize', this._updateTruncation);
        }
    };
    DocumentCardTitleBase.prototype.componentDidUpdate = function () {
        // If we're truncating, make sure the title fits
        if (this.props.shouldTruncate) {
            this._shrinkTitle();
        }
    };
    DocumentCardTitleBase.prototype.render = function () {
        var _a = this.props, title = _a.title, shouldTruncate = _a.shouldTruncate, showAsSecondaryTitle = _a.showAsSecondaryTitle, styles = _a.styles, theme = _a.theme, className = _a.className;
        var _b = this.state, truncatedTitleFirstPiece = _b.truncatedTitleFirstPiece, truncatedTitleSecondPiece = _b.truncatedTitleSecondPiece;
        this._classNames = getClassNames(styles, {
            theme: theme,
            className: className,
            showAsSecondaryTitle: showAsSecondaryTitle
        });
        var documentCardTitle;
        if (shouldTruncate && this._isTruncated) {
            documentCardTitle = (React.createElement("div", { className: this._classNames.root, ref: this._titleElement, title: title },
                truncatedTitleFirstPiece,
                "\u2026",
                truncatedTitleSecondPiece));
        }
        else {
            documentCardTitle = (React.createElement("div", { className: this._classNames.root, ref: this._titleElement, title: title }, title));
        }
        return documentCardTitle;
    };
    DocumentCardTitleBase.prototype._shrinkTitle = function () {
        if (this._doesTitleOverflow()) {
            var _a = this.state, truncatedTitleFirstPiece = _a.truncatedTitleFirstPiece, truncatedTitleSecondPiece = _a.truncatedTitleSecondPiece;
            this._isTruncated = true;
            if (truncatedTitleFirstPiece || truncatedTitleSecondPiece) {
                this.setState({
                    truncatedTitleFirstPiece: truncatedTitleFirstPiece.slice(0, truncatedTitleFirstPiece.length - 1),
                    truncatedTitleSecondPiece: truncatedTitleSecondPiece.slice(1)
                });
            }
        }
    };
    DocumentCardTitleBase.prototype._doesTitleOverflow = function () {
        var titleElement = this._titleElement.current;
        if (!titleElement) {
            return false;
        }
        return (titleElement.scrollHeight > titleElement.clientHeight + TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD ||
            titleElement.scrollWidth > titleElement.clientWidth);
    };
    DocumentCardTitleBase.prototype._updateTruncation = function () {
        // Only update truncation if the title's size has changed since the last time we truncated
        if (this._titleElement.current && this._titleElement.current.clientWidth !== this._truncatedTitleAtWidth) {
            // Throttle truncation so that it doesn't happen during a window resize
            clearTimeout(this._scrollTimerId);
            this._scrollTimerId = this._async.setTimeout(this._startTruncation.bind(this, this.props), 250);
        }
    };
    return DocumentCardTitleBase;
}(BaseComponent));
export { DocumentCardTitleBase };
//# sourceMappingURL=DocumentCardTitle.base.js.map