{"version":3,"file":"PositioningContainer.types.js","sourceRoot":"../src/","sources":["components/Coachmark/PositioningContainer/PositioningContainer.types.ts"],"names":[],"mappings":"","sourcesContent":["import { DirectionalHint } from '../../../common/DirectionalHint';\r\nimport { IRefObject, IBaseProps, IPoint, IRectangle } from '../../../Utilities';\r\nimport { IPositionedData } from '../../../utilities/positioning';\r\n\r\nexport interface IPositioningContainer {}\r\n\r\nexport interface IPositioningContainerProps extends IBaseProps<IPositioningContainer> {\r\n  /**\r\n   * All props for your component are to be defined here.\r\n   */\r\n  componentRef?: IRefObject<IPositioningContainer>;\r\n  /**\r\n   * The target that the positioningContainer should try to position itself based on.\r\n   * It can be either an HTMLElement a querySelector string of a valid HTMLElement\r\n   * or a MouseEvent. If MouseEvent is given then the origin point of the event will be used.\r\n   */\r\n  target?: HTMLElement | string | MouseEvent | IPoint | null;\r\n\r\n  /**\r\n   * How the element should be positioned\r\n   * @defaultvalue DirectionalHint.BottomAutoEdge\r\n   */\r\n  directionalHint?: DirectionalHint;\r\n\r\n  /**\r\n   * How the element should be positioned in RTL layouts.\r\n   * If not specified, a mirror of `directionalHint` will be used instead\r\n   */\r\n  directionalHintForRTL?: DirectionalHint;\r\n\r\n  /**\r\n   * The gap between the positioningContainer and the target\r\n   * @defaultvalue 0\r\n   */\r\n  offsetFromTarget?: number;\r\n\r\n  /**\r\n   * Custom width for positioningContainer including borders. If value is 0, no width is applied.\r\n   * @defaultvalue 0\r\n   */\r\n  positioningContainerWidth?: number;\r\n\r\n  /**\r\n   * The background color of the positioningContainer in hex format ie. #ffffff.\r\n   * @defaultvalue $ms-color-white\r\n   */\r\n  backgroundColor?: string;\r\n\r\n  /**\r\n   * The bounding rectangle for which the contextual menu can appear in.\r\n   */\r\n  bounds?: IRectangle;\r\n\r\n  /**\r\n   * The minimum distance the positioningContainer will be away from the edge of the screen.\r\n   *  @defaultvalue 8\r\n   */\r\n  minPagePadding?: number;\r\n\r\n  /**\r\n   * If true use a point rather than rectangle to position the positioningContainer.\r\n   * For example it can be used to position based on a click.\r\n   * @deprecated Do not use.\r\n   */\r\n  useTargetPoint?: boolean;\r\n\r\n  /**\r\n   * Point used to position the positioningContainer.\r\n   * Deprecated, use `target` instead.\r\n   * @deprecated Use `target` instead.\r\n   */\r\n  targetPoint?: IPoint;\r\n\r\n  /**\r\n   * If true then the onClose will not not dismiss on scroll\r\n   * @defaultvalue false\r\n   */\r\n  preventDismissOnScroll?: boolean;\r\n\r\n  /**\r\n   * If true the position returned will have the menu element cover the target.\r\n   * If false then it will position next to the target;\r\n   * @defaultvalue false\r\n   */\r\n  coverTarget?: boolean;\r\n\r\n  /**\r\n   * Aria role assigned to the positioningContainer (Eg. dialog, alertdialog).\r\n   */\r\n  role?: string;\r\n\r\n  /**\r\n   * Accessible label text for positioningContainer.\r\n   */\r\n  ariaLabel?: string;\r\n\r\n  /**\r\n   *  Defines the element id referencing the element containing label text for positioningContainer.\r\n   */\r\n  ariaLabelledBy?: string;\r\n\r\n  /**\r\n   * Defines the element id referencing the element containing the description for the positioningContainer.\r\n   */\r\n  ariaDescribedBy?: string;\r\n\r\n  /**\r\n   * CSS class to apply to the positioningContainer.\r\n   * @defaultvalue null\r\n   */\r\n  className?: string;\r\n\r\n  /**\r\n   * Optional callback when the layer content has mounted.\r\n   */\r\n  onLayerMounted?: () => void;\r\n\r\n  /**\r\n   * Optional callback that is called once the positioningContainer has been correctly positioned.\r\n   * @param positions - gives the user information about how the container is positioned such\r\n   * as the element position, the target edge, and the alignment edge of the container.\r\n   */\r\n  onPositioned?: (positions?: IPositionedData) => void;\r\n\r\n  /**\r\n   * Callback when the positioningContainer tries to close.\r\n   */\r\n  // tslint:disable-next-line:no-any\r\n  onDismiss?: (ev?: any) => void;\r\n\r\n  /**\r\n   * If true do not render on a new layer. If false render on a new layer.\r\n   */\r\n  doNotLayer?: boolean;\r\n\r\n  /**\r\n   * If true the position will not change sides in an attempt to fit the positioningContainer within bounds.\r\n   * It will still attempt to align it to whatever bounds are given.\r\n   * @defaultvalue false\r\n   */\r\n  directionalHintFixed?: boolean;\r\n\r\n  /**\r\n   * Specify the final height of the content.\r\n   * To be used when expanding the content dynamically so that positioningContainer can adjust its position.\r\n   */\r\n  finalHeight?: number;\r\n\r\n  /**\r\n   * If true then the positioningContainer will attempt to focus the first focusable element that it contains.\r\n   * If it doesn't find an element, no focus will be set and the method will return false.\r\n   * This means that it's the contents responsibility to either set focus or have\r\n   * focusable items.\r\n   * @returns True if focus was set, false if it was not.\r\n   */\r\n  setInitialFocus?: boolean;\r\n\r\n  /**\r\n   * Set max height of positioningContainer\r\n   * When not set the positioningContainer will expand with contents up to the bottom of the screen\r\n   */\r\n  positioningContainerMaxHeight?: number;\r\n}\r\n\r\n/** @deprecated Use `IPositioningContainerProps` */\r\nexport type IPositioningContainerTypes = IPositioningContainerProps;\r\n"]}