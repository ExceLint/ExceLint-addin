{"version":3,"file":"ResizeGroup.base.js","sourceRoot":"../src/","sources":["components/ResizeGroup/ResizeGroup.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\r\nimport * as PropTypes from 'prop-types';\r\nimport { BaseComponent, divProperties, getNativeProps, provideContext } from '../../Utilities';\r\nimport { IResizeGroupProps } from './ResizeGroup.types';\r\n\r\nconst RESIZE_DELAY = 16;\r\n\r\nexport interface IResizeGroupState {\r\n  /**\r\n   * Final data used to render proper sized component\r\n   */\r\n  renderedData?: any;\r\n\r\n  /**\r\n   * Data to render in a hidden div for measurement\r\n   */\r\n  dataToMeasure?: any;\r\n\r\n  /**\r\n   * Set to true when the content container might have new dimensions and should\r\n   * be remeasured.\r\n   */\r\n  measureContainer?: boolean;\r\n\r\n  /**\r\n   * Are we resizing to accommodate having more or less available space?\r\n   * The 'grow' direction is when the container may have more room than the last render,\r\n   * such as when a window resize occurs. This means we will try to fit more content in the window.\r\n   * The 'shrink' direction is when the contents don't fit in the container and we need\r\n   * to find a transformation of the data that makes everything fit.\r\n   */\r\n  resizeDirection?: 'grow' | 'shrink';\r\n}\r\n\r\n/**\r\n * Returns a simple object is able to store measurements with a given key.\r\n */\r\nexport const getMeasurementCache = () => {\r\n  const measurementsCache: { [key: string]: number } = {};\r\n\r\n  return {\r\n    /**\r\n     * Checks if the provided data has a cacheKey. If it has a cacheKey and there is a\r\n     * corresponding entry in the measurementsCache, then it will return that value.\r\n     * Returns undefined otherwise.\r\n     */\r\n    getCachedMeasurement: (data: any): number | undefined => {\r\n      if (data && data.cacheKey && measurementsCache.hasOwnProperty(data.cacheKey)) {\r\n        return measurementsCache[data.cacheKey];\r\n      }\r\n\r\n      return undefined;\r\n    },\r\n    /**\r\n     * Should be called whenever there is a new measurement associated with a given data object.\r\n     * If the data has a cacheKey, store that measurement in the measurementsCache.\r\n     */\r\n    addMeasurementToCache: (data: any, measurement: number): void => {\r\n      if (data.cacheKey) {\r\n        measurementsCache[data.cacheKey] = measurement;\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Returns a function that is able to compute the next state for the ResizeGroup given the current\r\n * state and any measurement updates.\r\n */\r\nexport const getNextResizeGroupStateProvider = (measurementCache = getMeasurementCache()) => {\r\n  const _measurementCache = measurementCache;\r\n  let _containerWidth: number | undefined;\r\n\r\n  /**\r\n   * Gets the width of the data rendered in a hidden div.\r\n   * @param measuredData - The data corresponding to the measurement we wish to take.\r\n   * @param getElementToMeasureWidth - A function that returns the measurement of the rendered data. Only called when the measurement\r\n   * is not in the cache.\r\n   */\r\n  function _getMeasuredWidth(measuredData: any, getElementToMeasureWidth: () => number): number {\r\n    const cachedWidth = _measurementCache.getCachedMeasurement(measuredData);\r\n    if (cachedWidth !== undefined) {\r\n      return cachedWidth;\r\n    }\r\n\r\n    const measuredWidth = getElementToMeasureWidth();\r\n    _measurementCache.addMeasurementToCache(measuredData, measuredWidth);\r\n    return measuredWidth;\r\n  }\r\n\r\n  /**\r\n   * Will get the next IResizeGroupState based on the current data while trying to shrink contents\r\n   * to fit in the container.\r\n   * @param data - The initial data point to start measuring.\r\n   * @param onReduceData - Function that transforms the data into something that should render with less width.\r\n   * @param getElementToMeasureWidth - A function that returns the measurement of the rendered data. Only called when the measurement\r\n   * is not in the cache.\r\n   */\r\n  function _shrinkContentsUntilTheyFit(\r\n    data: any,\r\n    onReduceData: (prevData: any) => any,\r\n    getElementToMeasureWidth: () => number\r\n  ): IResizeGroupState {\r\n    let dataToMeasure = data;\r\n    let measuredWidth: number | undefined = _getMeasuredWidth(data, getElementToMeasureWidth);\r\n\r\n    while (measuredWidth > _containerWidth!) {\r\n      const nextMeasuredData = onReduceData(dataToMeasure);\r\n\r\n      // We don't want to get stuck in an infinite render loop when there are no more\r\n      // scaling steps, so implementations of onReduceData should return undefined when\r\n      // there are no more scaling states to apply.\r\n      if (nextMeasuredData === undefined) {\r\n        return {\r\n          renderedData: dataToMeasure,\r\n          resizeDirection: undefined,\r\n          dataToMeasure: undefined\r\n        };\r\n      }\r\n\r\n      measuredWidth = _measurementCache.getCachedMeasurement(nextMeasuredData);\r\n\r\n      // If the measurement isn't in the cache, we need to rerender with some data in a hidden div\r\n      if (measuredWidth === undefined) {\r\n        return {\r\n          dataToMeasure: nextMeasuredData,\r\n          resizeDirection: 'shrink'\r\n        };\r\n      }\r\n\r\n      dataToMeasure = nextMeasuredData;\r\n    }\r\n\r\n    return {\r\n      renderedData: dataToMeasure,\r\n      resizeDirection: undefined,\r\n      dataToMeasure: undefined\r\n    };\r\n  }\r\n\r\n  /**\r\n   * This function should be called when the state changes in a manner that might allow for more content to fit\r\n   * on the screen, such as the window width growing.\r\n   * @param data - The initial data point to start measuring.\r\n   * @param onGrowData - Function that transforms the data into something that may take up more space when rendering.\r\n   * @param getElementToMeasureWidth - A function that returns the measurement of the rendered data. Only called when the measurement\r\n   * is not in the cache.\r\n   */\r\n  function _growDataUntilItDoesNotFit(\r\n    data: any,\r\n    onGrowData: (prevData: any) => any,\r\n    getElementToMeasureWidth: () => number,\r\n    onReduceData: (prevData: any) => any\r\n  ): IResizeGroupState {\r\n    let dataToMeasure = data;\r\n    let measuredWidth: number | undefined = _getMeasuredWidth(data, getElementToMeasureWidth);\r\n\r\n    while (measuredWidth < _containerWidth!) {\r\n      const nextMeasuredData = onGrowData(dataToMeasure);\r\n\r\n      // We don't want to get stuck in an infinite render loop when there are no more\r\n      // scaling steps, so implementations of onGrowData should return undefined when\r\n      // there are no more scaling states to apply.\r\n      if (nextMeasuredData === undefined) {\r\n        return {\r\n          renderedData: dataToMeasure,\r\n          resizeDirection: undefined,\r\n          dataToMeasure: undefined\r\n        };\r\n      }\r\n\r\n      measuredWidth = _measurementCache.getCachedMeasurement(nextMeasuredData);\r\n      // If the measurement isn't in the cache, we need to rerender with some data in a hidden div\r\n      if (measuredWidth === undefined) {\r\n        return {\r\n          dataToMeasure: nextMeasuredData\r\n        };\r\n      }\r\n\r\n      dataToMeasure = nextMeasuredData;\r\n    }\r\n\r\n    // Once the loop is done, we should now shrink until the contents fit.\r\n    return {\r\n      resizeDirection: 'shrink',\r\n      ..._shrinkContentsUntilTheyFit(dataToMeasure, onReduceData, getElementToMeasureWidth)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Handles an update to the container width. Should only be called when we knew the previous container width.\r\n   * @param newWidth - The new width of the container.\r\n   * @param fullWidthData - The initial data passed in as a prop to resizeGroup.\r\n   * @param renderedData - The data that was rendered prior to the container size changing.\r\n   * @param onGrowData - Set to true if the Resize group has an onGrowData function.\r\n   */\r\n  function _updateContainerWidth(\r\n    newWidth: number,\r\n    fullWidthData: any,\r\n    renderedData: any,\r\n    onGrowData?: (prevData: any) => any\r\n  ): IResizeGroupState {\r\n    let nextState: IResizeGroupState;\r\n    if (newWidth > _containerWidth!) {\r\n      if (onGrowData) {\r\n        nextState = {\r\n          resizeDirection: 'grow',\r\n          dataToMeasure: onGrowData(renderedData)\r\n        };\r\n      } else {\r\n        nextState = {\r\n          resizeDirection: 'shrink',\r\n          dataToMeasure: fullWidthData\r\n        };\r\n      }\r\n    } else {\r\n      nextState = {\r\n        resizeDirection: 'shrink',\r\n        dataToMeasure: renderedData\r\n      };\r\n    }\r\n    _containerWidth = newWidth;\r\n    return { ...nextState, measureContainer: false };\r\n  }\r\n\r\n  function getNextState(\r\n    props: IResizeGroupProps,\r\n    currentState: IResizeGroupState,\r\n    getElementToMeasureWidth: () => number,\r\n    newContainerWidth?: number\r\n  ): IResizeGroupState | undefined {\r\n    // If there is no new container width or data to measure, there is no need for a new state update\r\n    if (newContainerWidth === undefined && currentState.dataToMeasure === undefined) {\r\n      return undefined;\r\n    }\r\n\r\n    if (newContainerWidth) {\r\n      // If we know what the last container size was and we rendered data at that width, we can do an optimized render\r\n      if (_containerWidth && currentState.renderedData && !currentState.dataToMeasure) {\r\n        return {\r\n          ...currentState,\r\n          ..._updateContainerWidth(newContainerWidth, props.data, currentState.renderedData, props.onGrowData)\r\n        };\r\n      }\r\n\r\n      // If we are just setting the container width for the first time, we can't do any optimizations\r\n      _containerWidth = newContainerWidth;\r\n    }\r\n\r\n    let nextState: IResizeGroupState = {\r\n      ...currentState,\r\n      measureContainer: false\r\n    };\r\n\r\n    if (currentState.dataToMeasure) {\r\n      if (currentState.resizeDirection === 'grow' && props.onGrowData) {\r\n        nextState = {\r\n          ...nextState,\r\n          ..._growDataUntilItDoesNotFit(currentState.dataToMeasure, props.onGrowData, getElementToMeasureWidth, props.onReduceData)\r\n        };\r\n      } else {\r\n        nextState = {\r\n          ...nextState,\r\n          ..._shrinkContentsUntilTheyFit(currentState.dataToMeasure, props.onReduceData, getElementToMeasureWidth)\r\n        };\r\n      }\r\n    }\r\n\r\n    return nextState;\r\n  }\r\n\r\n  /** Function that determines if we need to render content for measurement based on the measurement cache contents. */\r\n  function shouldRenderDataForMeasurement(dataToMeasure: any | undefined): boolean {\r\n    if (!dataToMeasure || _measurementCache.getCachedMeasurement(dataToMeasure) !== undefined) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function getInitialResizeGroupState(data: any): IResizeGroupState {\r\n    return {\r\n      dataToMeasure: { ...data },\r\n      resizeDirection: 'grow',\r\n      measureContainer: true\r\n    };\r\n  }\r\n\r\n  return {\r\n    getNextState,\r\n    shouldRenderDataForMeasurement,\r\n    getInitialResizeGroupState\r\n  };\r\n};\r\n\r\n// Provides a context property that (if true) tells any child components that\r\n// they are only being used for measurement purposes and will not be visible.\r\nconst MeasuredContext = provideContext(\r\n  {\r\n    isMeasured: PropTypes.bool\r\n  },\r\n  () => {\r\n    return { isMeasured: true };\r\n  }\r\n);\r\n\r\n// Styles for the hidden div used for measurement\r\nconst hiddenDivStyles: React.CSSProperties = { position: 'fixed', visibility: 'hidden' };\r\nconst hiddenParentStyles: React.CSSProperties = { position: 'relative' };\r\n\r\nexport class ResizeGroupBase extends BaseComponent<IResizeGroupProps, IResizeGroupState> {\r\n  private _nextResizeGroupStateProvider = getNextResizeGroupStateProvider();\r\n  // The root div which is the container inside of which we are trying to fit content.\r\n  private _root = React.createRef<HTMLDivElement>();\r\n  // A div that can be used for the initial measurement so that we can avoid mounting a second instance\r\n  // of the component being measured for the initial render.\r\n  private _initialHiddenDiv = React.createRef<HTMLDivElement>();\r\n  // A hidden div that is used for mounting a new instance of the component for measurement in a hidden\r\n  // div without unmounting the currently visible content.\r\n  private _updateHiddenDiv = React.createRef<HTMLDivElement>();\r\n  // Tracks if any content has been rendered to the user. This enables us to do some performance optimizations\r\n  // for the initial render.\r\n  private _hasRenderedContent = false;\r\n\r\n  constructor(props: IResizeGroupProps) {\r\n    super(props);\r\n    this.state = this._nextResizeGroupStateProvider.getInitialResizeGroupState(this.props.data);\r\n\r\n    this._warnDeprecations({\r\n      styles: 'className'\r\n    });\r\n  }\r\n\r\n  public render(): JSX.Element {\r\n    const { className, onRenderData } = this.props;\r\n    const { dataToMeasure, renderedData } = this.state;\r\n    const divProps = getNativeProps(this.props, divProperties, ['data']);\r\n\r\n    const dataNeedsMeasuring = this._nextResizeGroupStateProvider.shouldRenderDataForMeasurement(dataToMeasure);\r\n\r\n    const isInitialMeasure = !this._hasRenderedContent && dataNeedsMeasuring;\r\n\r\n    // We only ever render the final content to the user. All measurements are done in a hidden div.\r\n    // For the initial render, we want this to be as fast as possible, so we need to make sure that we only mount one version of the\r\n    // component for measurement and the final render. For renders that update what is on screen, we want to make sure that\r\n    // there are no jarring effects such as the screen flashing as we apply scaling steps for meassurement. In the update case,\r\n    // we mount a second version of the component just for measurement purposes and leave the rendered content untouched until we know the\r\n    // next state sto show to the user.\r\n    return (\r\n      <div {...divProps} className={className} ref={this._root}>\r\n        <div style={hiddenParentStyles}>\r\n          {dataNeedsMeasuring && !isInitialMeasure && (\r\n            <div style={hiddenDivStyles} ref={this._updateHiddenDiv}>\r\n              <MeasuredContext>{onRenderData(dataToMeasure)}</MeasuredContext>\r\n            </div>\r\n          )}\r\n\r\n          <div ref={this._initialHiddenDiv} style={isInitialMeasure ? hiddenDivStyles : undefined} data-automation-id=\"visibleContent\">\r\n            {isInitialMeasure ? onRenderData(dataToMeasure) : renderedData && onRenderData(renderedData)}\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  public componentDidMount(): void {\r\n    this._afterComponentRendered();\r\n    this._events.on(window, 'resize', this._async.debounce(this._onResize, RESIZE_DELAY, { leading: true }));\r\n  }\r\n\r\n  public componentWillReceiveProps(nextProps: IResizeGroupProps): void {\r\n    this.setState({\r\n      dataToMeasure: { ...nextProps.data },\r\n      resizeDirection: 'grow',\r\n      measureContainer: true // Receiving new props means the parent might rerender and the root width might change\r\n    });\r\n  }\r\n\r\n  public componentDidUpdate(prevProps: IResizeGroupProps) {\r\n    if (this.state.renderedData) {\r\n      this._hasRenderedContent = true;\r\n      if (this.props.dataDidRender) {\r\n        this.props.dataDidRender(this.state.renderedData);\r\n      }\r\n    }\r\n    this._afterComponentRendered();\r\n  }\r\n\r\n  public remeasure(): void {\r\n    if (this._root.current) {\r\n      this.setState({ measureContainer: true });\r\n    }\r\n  }\r\n\r\n  private _afterComponentRendered(): void {\r\n    this._async.requestAnimationFrame(() => {\r\n      let containerWidth = undefined;\r\n      if (this.state.measureContainer && this._root.current) {\r\n        containerWidth = this._root.current.getBoundingClientRect().width;\r\n      }\r\n      const nextState = this._nextResizeGroupStateProvider.getNextState(\r\n        this.props,\r\n        this.state,\r\n        () => {\r\n          const refToMeasure = !this._hasRenderedContent ? this._initialHiddenDiv : this._updateHiddenDiv;\r\n          return refToMeasure.current ? refToMeasure.current.scrollWidth : 0;\r\n        },\r\n        containerWidth\r\n      );\r\n\r\n      if (nextState) {\r\n        this.setState(nextState);\r\n      }\r\n    });\r\n  }\r\n\r\n  private _onResize(): void {\r\n    if (this._root.current) {\r\n      this.setState({ measureContainer: true });\r\n    }\r\n  }\r\n}\r\n"]}