{"version":3,"file":"ResizeGroup.base.js","sourceRoot":"../src/","sources":["components/ResizeGroup/ResizeGroup.base.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAE,KAAK,EAAE,UAAU,EAAE,aAAa,EAAE,cAAc,EAAE,gBAAgB,EAAE,MAAM,iBAAiB,CAAC;AACrG,OAAO,EAAqB,oBAAoB,EAAE,MAAM,qBAAqB,CAAC;AAC9E,OAAO,EAAE,sBAAsB,EAAE,MAAM,qBAAqB,CAAC;AAE7D,IAAM,YAAY,GAAG,EAAE,CAAC;AA6BxB;;GAEG;AACH,MAAM,CAAC,IAAM,mBAAmB,GAAG;IACjC,IAAM,iBAAiB,GAA8B,EAAE,CAAC;IAExD,OAAO;QACL;;;;WAIG;QACH,oBAAoB,EAAE,UAAC,IAAS;YAC9B,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,IAAI,iBAAiB,CAAC,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;gBAC5E,OAAO,iBAAiB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;aACzC;YAED,OAAO,SAAS,CAAC;QACnB,CAAC;QACD;;;WAGG;QACH,qBAAqB,EAAE,UAAC,IAAS,EAAE,WAAmB;YACpD,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACjB,iBAAiB,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,WAAW,CAAC;aAChD;QACH,CAAC;KACF,CAAC;AACJ,CAAC,CAAC;AAEF;;;GAGG;AACH,MAAM,CAAC,IAAM,+BAA+B,GAAG,UAAC,gBAAwC;IAAxC,iCAAA,EAAA,mBAAmB,mBAAmB,EAAE;IACtF,IAAM,iBAAiB,GAAG,gBAAgB,CAAC;IAC3C,IAAI,mBAAuC,CAAC;IAE5C;;;;;OAKG;IACH,SAAS,qBAAqB,CAAC,YAAiB,EAAE,4BAA0C;QAC1F,IAAM,eAAe,GAAG,iBAAiB,CAAC,oBAAoB,CAAC,YAAY,CAAC,CAAC;QAC7E,IAAI,eAAe,KAAK,SAAS,EAAE;YACjC,OAAO,eAAe,CAAC;SACxB;QAED,IAAM,iBAAiB,GAAG,4BAA4B,EAAE,CAAC;QACzD,iBAAiB,CAAC,qBAAqB,CAAC,YAAY,EAAE,iBAAiB,CAAC,CAAC;QACzE,OAAO,iBAAiB,CAAC;IAC3B,CAAC;IAED;;;;;;;OAOG;IACH,SAAS,2BAA2B,CAClC,IAAS,EACT,YAAoC,EACpC,4BAA0C;QAE1C,IAAI,aAAa,GAAG,IAAI,CAAC;QACzB,IAAI,iBAAiB,GAAuB,qBAAqB,CAAC,IAAI,EAAE,4BAA4B,CAAC,CAAC;QAEtG,OAAO,iBAAiB,GAAG,mBAAoB,EAAE;YAC/C,IAAM,gBAAgB,GAAG,YAAY,CAAC,aAAa,CAAC,CAAC;YAErD,+EAA+E;YAC/E,iFAAiF;YACjF,6CAA6C;YAC7C,IAAI,gBAAgB,KAAK,SAAS,EAAE;gBAClC,OAAO;oBACL,YAAY,EAAE,aAAa;oBAC3B,eAAe,EAAE,SAAS;oBAC1B,aAAa,EAAE,SAAS;iBACzB,CAAC;aACH;YAED,iBAAiB,GAAG,iBAAiB,CAAC,oBAAoB,CAAC,gBAAgB,CAAC,CAAC;YAE7E,4FAA4F;YAC5F,IAAI,iBAAiB,KAAK,SAAS,EAAE;gBACnC,OAAO;oBACL,aAAa,EAAE,gBAAgB;oBAC/B,eAAe,EAAE,QAAQ;iBAC1B,CAAC;aACH;YAED,aAAa,GAAG,gBAAgB,CAAC;SAClC;QAED,OAAO;YACL,YAAY,EAAE,aAAa;YAC3B,eAAe,EAAE,SAAS;YAC1B,aAAa,EAAE,SAAS;SACzB,CAAC;IACJ,CAAC;IAED;;;;;;;OAOG;IACH,SAAS,0BAA0B,CACjC,IAAS,EACT,UAAkC,EAClC,4BAA0C,EAC1C,YAAoC;QAEpC,IAAI,aAAa,GAAG,IAAI,CAAC;QACzB,IAAI,iBAAiB,GAAuB,qBAAqB,CAAC,IAAI,EAAE,4BAA4B,CAAC,CAAC;QAEtG,OAAO,iBAAiB,GAAG,mBAAoB,EAAE;YAC/C,IAAM,gBAAgB,GAAG,UAAU,CAAC,aAAa,CAAC,CAAC;YAEnD,+EAA+E;YAC/E,+EAA+E;YAC/E,6CAA6C;YAC7C,IAAI,gBAAgB,KAAK,SAAS,EAAE;gBAClC,OAAO;oBACL,YAAY,EAAE,aAAa;oBAC3B,eAAe,EAAE,SAAS;oBAC1B,aAAa,EAAE,SAAS;iBACzB,CAAC;aACH;YAED,iBAAiB,GAAG,iBAAiB,CAAC,oBAAoB,CAAC,gBAAgB,CAAC,CAAC;YAC7E,4FAA4F;YAC5F,IAAI,iBAAiB,KAAK,SAAS,EAAE;gBACnC,OAAO;oBACL,aAAa,EAAE,gBAAgB;iBAChC,CAAC;aACH;YAED,aAAa,GAAG,gBAAgB,CAAC;SAClC;QAED,sEAAsE;QACtE,kBACE,eAAe,EAAE,QAAQ,IACtB,2BAA2B,CAAC,aAAa,EAAE,YAAY,EAAE,4BAA4B,CAAC,EACzF;IACJ,CAAC;IAED;;;;;;;OAOG;IACH,SAAS,yBAAyB,CAChC,YAAoB,EACpB,iBAAsB,EACtB,YAAiB,EACjB,UAAmC;QAEnC,IAAI,SAA4B,CAAC;QACjC,IAAI,YAAY,GAAG,mBAAoB,EAAE;YACvC,IAAI,UAAU,EAAE;gBACd,SAAS,GAAG;oBACV,eAAe,EAAE,MAAM;oBACvB,aAAa,EAAE,UAAU,CAAC,YAAY,CAAC;iBACxC,CAAC;aACH;iBAAM;gBACL,SAAS,GAAG;oBACV,eAAe,EAAE,QAAQ;oBACzB,aAAa,EAAE,iBAAiB;iBACjC,CAAC;aACH;SACF;aAAM;YACL,SAAS,GAAG;gBACV,eAAe,EAAE,QAAQ;gBACzB,aAAa,EAAE,YAAY;aAC5B,CAAC;SACH;QACD,mBAAmB,GAAG,YAAY,CAAC;QACnC,6BAAY,SAAS,KAAE,gBAAgB,EAAE,KAAK,IAAG;IACnD,CAAC;IAED,SAAS,YAAY,CACnB,KAAwB,EACxB,YAA+B,EAC/B,4BAA0C,EAC1C,qBAA8B;QAE9B,wGAAwG;QACxG,IAAI,qBAAqB,KAAK,SAAS,IAAI,YAAY,CAAC,aAAa,KAAK,SAAS,EAAE;YACnF,OAAO,SAAS,CAAC;SAClB;QAED,IAAI,qBAAqB,EAAE;YACzB,8GAA8G;YAC9G,IAAI,mBAAmB,IAAI,YAAY,CAAC,YAAY,IAAI,CAAC,YAAY,CAAC,aAAa,EAAE;gBACnF,6BACK,YAAY,GACZ,yBAAyB,CAAC,qBAAqB,EAAE,KAAK,CAAC,IAAI,EAAE,YAAY,CAAC,YAAY,EAAE,KAAK,CAAC,UAAU,CAAC,EAC5G;aACH;YAED,sGAAsG;YACtG,mBAAmB,GAAG,qBAAqB,CAAC;SAC7C;QAED,IAAI,SAAS,yBACR,YAAY,KACf,gBAAgB,EAAE,KAAK,GACxB,CAAC;QAEF,IAAI,YAAY,CAAC,aAAa,EAAE;YAC9B,IAAI,YAAY,CAAC,eAAe,KAAK,MAAM,IAAI,KAAK,CAAC,UAAU,EAAE;gBAC/D,SAAS,yBACJ,SAAS,GACT,0BAA0B,CAC3B,YAAY,CAAC,aAAa,EAC1B,KAAK,CAAC,UAAU,EAChB,4BAA4B,EAC5B,KAAK,CAAC,YAAY,CACnB,CACF,CAAC;aACH;iBAAM;gBACL,SAAS,yBACJ,SAAS,GACT,2BAA2B,CAAC,YAAY,CAAC,aAAa,EAAE,KAAK,CAAC,YAAY,EAAE,4BAA4B,CAAC,CAC7G,CAAC;aACH;SACF;QAED,OAAO,SAAS,CAAC;IACnB,CAAC;IAED,qHAAqH;IACrH,SAAS,8BAA8B,CAAC,aAA8B;QACpE,IAAI,CAAC,aAAa,IAAI,iBAAiB,CAAC,oBAAoB,CAAC,aAAa,CAAC,KAAK,SAAS,EAAE;YACzF,OAAO,KAAK,CAAC;SACd;QAED,OAAO,IAAI,CAAC;IACd,CAAC;IAED,SAAS,0BAA0B,CAAC,IAAS;QAC3C,OAAO;YACL,aAAa,eAAO,IAAI,CAAE;YAC1B,eAAe,EAAE,MAAM;YACvB,gBAAgB,EAAE,IAAI;SACvB,CAAC;IACJ,CAAC;IAED,OAAO;QACL,YAAY,cAAA;QACZ,8BAA8B,gCAAA;QAC9B,0BAA0B,4BAAA;KAC3B,CAAC;AACJ,CAAC,CAAC;AAEF,6EAA6E;AAC7E,6EAA6E;AAC7E,MAAM,CAAC,IAAM,eAAe,GAAG,KAAK,CAAC,aAAa,CAAC,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,CAAC;AAE1E,iDAAiD;AACjD,IAAM,eAAe,GAAwB,EAAE,QAAQ,EAAE,OAAO,EAAE,UAAU,EAAE,QAAQ,EAAE,CAAC;AACzF,IAAM,kBAAkB,GAAwB,EAAE,QAAQ,EAAE,UAAU,EAAE,CAAC;AACzE,IAAM,cAAc,GAAG,aAAa,CAAC;AAErC;IAAqC,mCAAqD;IAiBxF,yBAAY,KAAwB;QAApC,YACE,kBAAM,KAAK,CAAC,SAUb;QA3BO,mCAA6B,GAAG,+BAA+B,EAAE,CAAC;QAC1E,oFAAoF;QAC5E,WAAK,GAAG,KAAK,CAAC,SAAS,EAAkB,CAAC;QAClD,qGAAqG;QACrG,0DAA0D;QAClD,uBAAiB,GAAG,KAAK,CAAC,SAAS,EAAkB,CAAC;QAC9D,qGAAqG;QACrG,wDAAwD;QAChD,sBAAgB,GAAG,KAAK,CAAC,SAAS,EAAkB,CAAC;QAC7D,4GAA4G;QAC5G,0BAA0B;QAClB,yBAAmB,GAAG,KAAK,CAAC;QAOlC,KAAI,CAAC,KAAK,GAAG,KAAI,CAAC,6BAA6B,CAAC,0BAA0B,CAAC,KAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAE5F,sBAAsB,CAAC,KAAI,CAAC,CAAC;QAC7B,KAAI,CAAC,MAAM,GAAG,IAAI,KAAK,CAAC,KAAI,CAAC,CAAC;QAC9B,KAAI,CAAC,OAAO,GAAG,IAAI,UAAU,CAAC,KAAI,CAAC,CAAC;QAEpC,gBAAgB,CAAC,cAAc,EAAE,KAAK,EAAE;YACtC,MAAM,EAAE,WAAW;SACpB,CAAC,CAAC;;IACL,CAAC;IAEM,gCAAM,GAAb;QACQ,IAAA,eAAwC,EAAtC,wBAAS,EAAE,8BAA2B,CAAC;QACzC,IAAA,eAA4C,EAA1C,gCAAa,EAAE,8BAA2B,CAAC;QACnD,IAAM,QAAQ,GAAG,cAAc,CAAuC,IAAI,CAAC,KAAK,EAAE,aAAa,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;QAE3G,IAAM,kBAAkB,GAAG,IAAI,CAAC,6BAA6B,CAAC,8BAA8B,CAAC,aAAa,CAAC,CAAC;QAE5G,IAAM,gBAAgB,GAAG,CAAC,IAAI,CAAC,mBAAmB,IAAI,kBAAkB,CAAC;QAEzE,gGAAgG;QAChG,iHAAiH;QACjH,+GAA+G;QAC/G,gHAAgH;QAChH,gHAAgH;QAChH,yFAAyF;QACzF,OAAO,CACL,wCAAS,QAAQ,IAAE,SAAS,EAAE,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,KAAK;YACtD,6BAAK,KAAK,EAAE,kBAAkB;gBAC3B,kBAAkB,IAAI,CAAC,gBAAgB,IAAI,CAC1C,6BAAK,KAAK,EAAE,eAAe,EAAE,GAAG,EAAE,IAAI,CAAC,gBAAgB;oBACrD,oBAAC,eAAe,CAAC,QAAQ,IAAC,KAAK,EAAE,EAAE,UAAU,EAAE,IAAI,EAAE,IAClD,YAAY,CAAC,aAAa,CAAC,CACH,CACvB,CACP;gBAED,6BACE,GAAG,EAAE,IAAI,CAAC,iBAAiB,EAC3B,KAAK,EAAE,gBAAgB,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,SAAS,wBAClC,gBAAgB,IAElC,gBAAgB,CAAC,CAAC,CAAC,YAAY,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,YAAY,IAAI,YAAY,CAAC,YAAY,CAAC,CACxF,CACF,CACF,CACP,CAAC;IACJ,CAAC;IAEM,2CAAiB,GAAxB;QACE,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACnD,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE,YAAY,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;IAC3G,CAAC;IAEM,0DAAgC,GAAvC,UAAwC,SAA4B;QAClE,IAAI,CAAC,QAAQ,CAAC;YACZ,aAAa,eAAO,SAAS,CAAC,IAAI,CAAE;YACpC,eAAe,EAAE,MAAM;YACvB,6FAA6F;YAC7F,gBAAgB,EAAE,IAAI;SACvB,CAAC,CAAC;IACL,CAAC;IAEM,4CAAkB,GAAzB,UAA0B,SAA4B;QACpD,IAAI,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE;YAC3B,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;YAChC,IAAI,IAAI,CAAC,KAAK,CAAC,aAAa,EAAE;gBAC5B,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;aACnD;SACF;QACD,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IACrD,CAAC;IAEM,8CAAoB,GAA3B;QACE,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;QACtB,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;IACzB,CAAC;IAEM,mCAAS,GAAhB;QACE,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;YACtB,IAAI,CAAC,QAAQ,CAAC,EAAE,gBAAgB,EAAE,IAAI,EAAE,CAAC,CAAC;SAC3C;IACH,CAAC;IAEO,iDAAuB,GAA/B,UAAgC,SAAgC;QAAhE,iBA2BC;QA1BC,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC;YAChC,IAAI,kBAAkB,GAAG,SAAS,CAAC;YACnC,IAAI,KAAI,CAAC,KAAK,CAAC,gBAAgB,IAAI,KAAI,CAAC,KAAK,CAAC,OAAO,EAAE;gBACrD,IAAM,YAAY,GAAG,KAAI,CAAC,KAAK,CAAC,OAAO,CAAC,qBAAqB,EAAE,CAAC;gBAChE,kBAAkB;oBAChB,SAAS,IAAI,SAAS,KAAK,oBAAoB,CAAC,QAAQ,CAAC,CAAC,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,YAAY,CAAC,KAAK,CAAC;aACvG;YACD,IAAM,SAAS,GAAG,KAAI,CAAC,6BAA6B,CAAC,YAAY,CAC/D,KAAI,CAAC,KAAK,EACV,KAAI,CAAC,KAAK,EACV;gBACE,IAAM,YAAY,GAAG,CAAC,KAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC,KAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,KAAI,CAAC,gBAAgB,CAAC;gBAChG,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE;oBACzB,OAAO,CAAC,CAAC;iBACV;gBACD,OAAO,SAAS,IAAI,SAAS,KAAK,oBAAoB,CAAC,QAAQ;oBAC7D,CAAC,CAAC,YAAY,CAAC,OAAO,CAAC,YAAY;oBACnC,CAAC,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,CAAC;YACvC,CAAC,EACD,kBAAkB,CACnB,CAAC;YAEF,IAAI,SAAS,EAAE;gBACb,KAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;aAC1B;QACH,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;IACzB,CAAC;IAEO,mCAAS,GAAjB;QACE,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;YACtB,IAAI,CAAC,QAAQ,CAAC,EAAE,gBAAgB,EAAE,IAAI,EAAE,CAAC,CAAC;SAC3C;IACH,CAAC;IACH,sBAAC;AAAD,CAAC,AAzID,CAAqC,KAAK,CAAC,SAAS,GAyInD","sourcesContent":["import * as React from 'react';\nimport { Async, EventGroup, divProperties, getNativeProps, warnDeprecations } from '../../Utilities';\nimport { IResizeGroupProps, ResizeGroupDirection } from './ResizeGroup.types';\nimport { initializeComponentRef } from '@uifabric/utilities';\n\nconst RESIZE_DELAY = 16;\n\nexport interface IResizeGroupState {\n  /**\n   * Final data used to render proper sized component\n   */\n  renderedData?: any;\n\n  /**\n   * Data to render in a hidden div for measurement\n   */\n  dataToMeasure?: any;\n\n  /**\n   * Set to true when the content container might have new dimensions and should\n   * be remeasured.\n   */\n  measureContainer?: boolean;\n\n  /**\n   * Are we resizing to accommodate having more or less available space?\n   * The 'grow' direction is when the container may have more room than the last render,\n   * such as when a window resize occurs. This means we will try to fit more content in the window.\n   * The 'shrink' direction is when the contents don't fit in the container and we need\n   * to find a transformation of the data that makes everything fit.\n   */\n  resizeDirection?: 'grow' | 'shrink';\n}\n\n/**\n * Returns a simple object is able to store measurements with a given key.\n */\nexport const getMeasurementCache = () => {\n  const measurementsCache: { [key: string]: number } = {};\n\n  return {\n    /**\n     * Checks if the provided data has a cacheKey. If it has a cacheKey and there is a\n     * corresponding entry in the measurementsCache, then it will return that value.\n     * Returns undefined otherwise.\n     */\n    getCachedMeasurement: (data: any): number | undefined => {\n      if (data && data.cacheKey && measurementsCache.hasOwnProperty(data.cacheKey)) {\n        return measurementsCache[data.cacheKey];\n      }\n\n      return undefined;\n    },\n    /**\n     * Should be called whenever there is a new measurement associated with a given data object.\n     * If the data has a cacheKey, store that measurement in the measurementsCache.\n     */\n    addMeasurementToCache: (data: any, measurement: number): void => {\n      if (data.cacheKey) {\n        measurementsCache[data.cacheKey] = measurement;\n      }\n    },\n  };\n};\n\n/**\n * Returns a function that is able to compute the next state for the ResizeGroup given the current\n * state and any measurement updates.\n */\nexport const getNextResizeGroupStateProvider = (measurementCache = getMeasurementCache()) => {\n  const _measurementCache = measurementCache;\n  let _containerDimension: number | undefined;\n\n  /**\n   * Gets the width/height of the data rendered in a hidden div.\n   * @param measuredData - The data corresponding to the measurement we wish to take.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _getMeasuredDimension(measuredData: any, getElementToMeasureDimension: () => number): number {\n    const cachedDimension = _measurementCache.getCachedMeasurement(measuredData);\n    if (cachedDimension !== undefined) {\n      return cachedDimension;\n    }\n\n    const measuredDimension = getElementToMeasureDimension();\n    _measurementCache.addMeasurementToCache(measuredData, measuredDimension);\n    return measuredDimension;\n  }\n\n  /**\n   * Will get the next IResizeGroupState based on the current data while trying to shrink contents\n   * to fit in the container.\n   * @param data - The initial data point to start measuring.\n   * @param onReduceData - Function that transforms the data into something that should render with less width/height.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _shrinkContentsUntilTheyFit(\n    data: any,\n    onReduceData: (prevData: any) => any,\n    getElementToMeasureDimension: () => number,\n  ): IResizeGroupState {\n    let dataToMeasure = data;\n    let measuredDimension: number | undefined = _getMeasuredDimension(data, getElementToMeasureDimension);\n\n    while (measuredDimension > _containerDimension!) {\n      const nextMeasuredData = onReduceData(dataToMeasure);\n\n      // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onReduceData should return undefined when\n      // there are no more scaling states to apply.\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined,\n        };\n      }\n\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);\n\n      // If the measurement isn't in the cache, we need to rerender with some data in a hidden div\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData,\n          resizeDirection: 'shrink',\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    }\n\n    return {\n      renderedData: dataToMeasure,\n      resizeDirection: undefined,\n      dataToMeasure: undefined,\n    };\n  }\n\n  /**\n   * This function should be called when the state changes in a manner that might allow for more content to fit\n   * on the screen, such as the window width/height growing.\n   * @param data - The initial data point to start measuring.\n   * @param onGrowData - Function that transforms the data into something that may take up more space when rendering.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _growDataUntilItDoesNotFit(\n    data: any,\n    onGrowData: (prevData: any) => any,\n    getElementToMeasureDimension: () => number,\n    onReduceData: (prevData: any) => any,\n  ): IResizeGroupState {\n    let dataToMeasure = data;\n    let measuredDimension: number | undefined = _getMeasuredDimension(data, getElementToMeasureDimension);\n\n    while (measuredDimension < _containerDimension!) {\n      const nextMeasuredData = onGrowData(dataToMeasure);\n\n      // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onGrowData should return undefined when\n      // there are no more scaling states to apply.\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined,\n        };\n      }\n\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);\n      // If the measurement isn't in the cache, we need to rerender with some data in a hidden div\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData,\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    }\n\n    // Once the loop is done, we should now shrink until the contents fit.\n    return {\n      resizeDirection: 'shrink',\n      ..._shrinkContentsUntilTheyFit(dataToMeasure, onReduceData, getElementToMeasureDimension),\n    };\n  }\n\n  /**\n   * Handles an update to the container width/height.\n   * Should only be called when we knew the previous container width/height.\n   * @param newDimension - The new width/height of the container.\n   * @param fullDimensionData - The initial data passed in as a prop to resizeGroup.\n   * @param renderedData - The data that was rendered prior to the container size changing.\n   * @param onGrowData - Set to true if the Resize group has an onGrowData function.\n   */\n  function _updateContainerDimension(\n    newDimension: number,\n    fullDimensionData: any,\n    renderedData: any,\n    onGrowData?: (prevData: any) => any,\n  ): IResizeGroupState {\n    let nextState: IResizeGroupState;\n    if (newDimension > _containerDimension!) {\n      if (onGrowData) {\n        nextState = {\n          resizeDirection: 'grow',\n          dataToMeasure: onGrowData(renderedData),\n        };\n      } else {\n        nextState = {\n          resizeDirection: 'shrink',\n          dataToMeasure: fullDimensionData,\n        };\n      }\n    } else {\n      nextState = {\n        resizeDirection: 'shrink',\n        dataToMeasure: renderedData,\n      };\n    }\n    _containerDimension = newDimension;\n    return { ...nextState, measureContainer: false };\n  }\n\n  function getNextState(\n    props: IResizeGroupProps,\n    currentState: IResizeGroupState,\n    getElementToMeasureDimension: () => number,\n    newContainerDimension?: number,\n  ): IResizeGroupState | undefined {\n    // If there is no new container width/height or data to measure, there is no need for a new state update\n    if (newContainerDimension === undefined && currentState.dataToMeasure === undefined) {\n      return undefined;\n    }\n\n    if (newContainerDimension) {\n      // If we know the last container size and we rendered data at that width/height, we can do an optimized render\n      if (_containerDimension && currentState.renderedData && !currentState.dataToMeasure) {\n        return {\n          ...currentState,\n          ..._updateContainerDimension(newContainerDimension, props.data, currentState.renderedData, props.onGrowData),\n        };\n      }\n\n      // If we are just setting the container width/height for the first time, we can't do any optimizations\n      _containerDimension = newContainerDimension;\n    }\n\n    let nextState: IResizeGroupState = {\n      ...currentState,\n      measureContainer: false,\n    };\n\n    if (currentState.dataToMeasure) {\n      if (currentState.resizeDirection === 'grow' && props.onGrowData) {\n        nextState = {\n          ...nextState,\n          ..._growDataUntilItDoesNotFit(\n            currentState.dataToMeasure,\n            props.onGrowData,\n            getElementToMeasureDimension,\n            props.onReduceData,\n          ),\n        };\n      } else {\n        nextState = {\n          ...nextState,\n          ..._shrinkContentsUntilTheyFit(currentState.dataToMeasure, props.onReduceData, getElementToMeasureDimension),\n        };\n      }\n    }\n\n    return nextState;\n  }\n\n  /** Function that determines if we need to render content for measurement based on the measurement cache contents. */\n  function shouldRenderDataForMeasurement(dataToMeasure: any | undefined): boolean {\n    if (!dataToMeasure || _measurementCache.getCachedMeasurement(dataToMeasure) !== undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function getInitialResizeGroupState(data: any): IResizeGroupState {\n    return {\n      dataToMeasure: { ...data },\n      resizeDirection: 'grow',\n      measureContainer: true,\n    };\n  }\n\n  return {\n    getNextState,\n    shouldRenderDataForMeasurement,\n    getInitialResizeGroupState,\n  };\n};\n\n// Provides a context property that (if true) tells any child components that\n// they are only being used for measurement purposes and will not be visible.\nexport const MeasuredContext = React.createContext({ isMeasured: false });\n\n// Styles for the hidden div used for measurement\nconst hiddenDivStyles: React.CSSProperties = { position: 'fixed', visibility: 'hidden' };\nconst hiddenParentStyles: React.CSSProperties = { position: 'relative' };\nconst COMPONENT_NAME = 'ResizeGroup';\n\nexport class ResizeGroupBase extends React.Component<IResizeGroupProps, IResizeGroupState> {\n  private _nextResizeGroupStateProvider = getNextResizeGroupStateProvider();\n  // The root div which is the container inside of which we are trying to fit content.\n  private _root = React.createRef<HTMLDivElement>();\n  // A div that can be used for the initial measurement so that we can avoid mounting a second instance\n  // of the component being measured for the initial render.\n  private _initialHiddenDiv = React.createRef<HTMLDivElement>();\n  // A hidden div that is used for mounting a new instance of the component for measurement in a hidden\n  // div without unmounting the currently visible content.\n  private _updateHiddenDiv = React.createRef<HTMLDivElement>();\n  // Tracks if any content has been rendered to the user. This enables us to do some performance optimizations\n  // for the initial render.\n  private _hasRenderedContent = false;\n\n  private _async: Async;\n  private _events: EventGroup;\n\n  constructor(props: IResizeGroupProps) {\n    super(props);\n    this.state = this._nextResizeGroupStateProvider.getInitialResizeGroupState(this.props.data);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    warnDeprecations(COMPONENT_NAME, props, {\n      styles: 'className',\n    });\n  }\n\n  public render(): JSX.Element {\n    const { className, onRenderData } = this.props;\n    const { dataToMeasure, renderedData } = this.state;\n    const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties, ['data']);\n\n    const dataNeedsMeasuring = this._nextResizeGroupStateProvider.shouldRenderDataForMeasurement(dataToMeasure);\n\n    const isInitialMeasure = !this._hasRenderedContent && dataNeedsMeasuring;\n\n    // We only ever render the final content to the user. All measurements are done in a hidden div.\n    // For the initial render, we want this to be as fast as possible, so we need to make sure that we only mount one\n    // version of the component for measurement and the final render. For renders that update what is on screen, we\n    // want to make sure that there are no jarring effects such as the screen flashing as we apply scaling steps for\n    // measurement. In the update case, we mount a second version of the component just for measurement purposes and\n    // leave the rendered content untouched until we know the next state to show to the user.\n    return (\n      <div {...divProps} className={className} ref={this._root}>\n        <div style={hiddenParentStyles}>\n          {dataNeedsMeasuring && !isInitialMeasure && (\n            <div style={hiddenDivStyles} ref={this._updateHiddenDiv}>\n              <MeasuredContext.Provider value={{ isMeasured: true }}>\n                {onRenderData(dataToMeasure)}\n              </MeasuredContext.Provider>\n            </div>\n          )}\n\n          <div\n            ref={this._initialHiddenDiv}\n            style={isInitialMeasure ? hiddenDivStyles : undefined}\n            data-automation-id=\"visibleContent\"\n          >\n            {isInitialMeasure ? onRenderData(dataToMeasure) : renderedData && onRenderData(renderedData)}\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  public componentDidMount(): void {\n    this._afterComponentRendered(this.props.direction);\n    this._events.on(window, 'resize', this._async.debounce(this._onResize, RESIZE_DELAY, { leading: true }));\n  }\n\n  public UNSAFE_componentWillReceiveProps(nextProps: IResizeGroupProps): void {\n    this.setState({\n      dataToMeasure: { ...nextProps.data },\n      resizeDirection: 'grow',\n      // Receiving new props means the parent might rerender and the root width/height might change\n      measureContainer: true,\n    });\n  }\n\n  public componentDidUpdate(prevProps: IResizeGroupProps) {\n    if (this.state.renderedData) {\n      this._hasRenderedContent = true;\n      if (this.props.dataDidRender) {\n        this.props.dataDidRender(this.state.renderedData);\n      }\n    }\n    this._afterComponentRendered(this.props.direction);\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  public remeasure(): void {\n    if (this._root.current) {\n      this.setState({ measureContainer: true });\n    }\n  }\n\n  private _afterComponentRendered(direction?: ResizeGroupDirection): void {\n    this._async.requestAnimationFrame(() => {\n      let containerDimension = undefined;\n      if (this.state.measureContainer && this._root.current) {\n        const boundingRect = this._root.current.getBoundingClientRect();\n        containerDimension =\n          direction && direction === ResizeGroupDirection.vertical ? boundingRect.height : boundingRect.width;\n      }\n      const nextState = this._nextResizeGroupStateProvider.getNextState(\n        this.props,\n        this.state,\n        () => {\n          const refToMeasure = !this._hasRenderedContent ? this._initialHiddenDiv : this._updateHiddenDiv;\n          if (!refToMeasure.current) {\n            return 0;\n          }\n          return direction && direction === ResizeGroupDirection.vertical\n            ? refToMeasure.current.scrollHeight\n            : refToMeasure.current.scrollWidth;\n        },\n        containerDimension,\n      );\n\n      if (nextState) {\n        this.setState(nextState);\n      }\n    }, this._root.current);\n  }\n\n  private _onResize(): void {\n    if (this._root.current) {\n      this.setState({ measureContainer: true });\n    }\n  }\n}\n"]}