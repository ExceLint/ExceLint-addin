import * as tslib_1 from "tslib";
import * as React from 'react';
import { Announced } from '../Announced';
import { Link } from 'office-ui-fabric-react/lib/Link';
import { DetailsList, Selection } from 'office-ui-fabric-react/lib/DetailsList';
import { MarqueeSelection } from 'office-ui-fabric-react/lib/MarqueeSelection';
import { Text } from 'office-ui-fabric-react/lib/Text';
import { Stack } from 'office-ui-fabric-react/lib/Stack';
import { mergeStyles, getTheme } from 'office-ui-fabric-react/lib/Styling';
import './Announced.Example.scss';
var _items = [];
var theme = getTheme();
var dragEnterClass = mergeStyles({
    backgroundColor: theme.palette.neutralLight
});
var _columns = [
    {
        key: 'name',
        name: 'Name',
        fieldName: 'name',
        minWidth: 100,
        maxWidth: 200,
        isResizable: true,
        ariaLabel: 'Operations for name'
    },
    {
        key: 'modified',
        name: 'Modified',
        fieldName: 'modified',
        minWidth: 100,
        maxWidth: 200,
        isResizable: true,
        ariaLabel: 'Operations for modified'
    },
    {
        key: 'modifiedby',
        name: 'Modified By',
        fieldName: 'modifiedby',
        minWidth: 100,
        maxWidth: 200,
        isResizable: true,
        ariaLabel: 'Operations for modifiedby'
    },
    {
        key: 'filesize',
        name: 'File Size',
        fieldName: 'filesize',
        minWidth: 100,
        maxWidth: 200,
        isResizable: true,
        ariaLabel: 'Operations for filesize'
    }
];
var _names = [
    'Annie Lindqvist',
    'Aaron Reid',
    'Alex Lundberg',
    'Roko Kolar',
    'Christian Bergqvist',
    'Valentina Lovric',
    'Makenzie Sharett'
];
function generateRandomDate() {
    return new Date(new Date(2010, 0, 1).getTime() + Math.random() * (new Date().getTime() - new Date(2010, 0, 1).getTime())).toDateString();
}
var AnnouncedBulkOperationsExample = /** @class */ (function (_super) {
    tslib_1.__extends(AnnouncedBulkOperationsExample, _super);
    function AnnouncedBulkOperationsExample(props) {
        var _this = _super.call(this, props) || this;
        _this._selection = new Selection();
        _this._dragDropEvents = _this._getDragDropEvents();
        _this._draggedIndex = -1;
        _this._onRenderItemColumn = _this._onRenderItemColumn.bind(_this);
        _this._renderAnnounced = _this._renderAnnounced.bind(_this);
        if (_items.length === 0) {
            for (var i = 0; i < 20; i++) {
                _items.push({
                    key: 'item-' + i,
                    name: 'Item ' + i,
                    modified: generateRandomDate(),
                    modifiedby: _names[Math.floor(Math.random() * _names.length)],
                    filesize: Math.floor(Math.random() * 30).toString() + ' MB'
                });
            }
        }
        _this.state = {
            items: _items,
            columns: _columns,
            numberOfItems: 0
        };
        return _this;
    }
    AnnouncedBulkOperationsExample.prototype.render = function () {
        var _a = this.state, items = _a.items, columns = _a.columns;
        return (React.createElement(Stack, { gap: 10 },
            React.createElement(Text, null, "Turn on Narrator and drag and drop the items."),
            React.createElement(Text, null, "Note: This example is to showcase the concept of copying, uploading, or moving many items and not fully illustrative of the real world scenario."),
            this._renderAnnounced(),
            React.createElement(MarqueeSelection, { selection: this._selection },
                React.createElement(DetailsList, { setKey: 'items', items: items, columns: columns, selection: this._selection, selectionPreservedOnEmptyClick: true, onItemInvoked: this._onItemInvoked, onRenderItemColumn: this._onRenderItemColumn, dragDropEvents: this._dragDropEvents, ariaLabelForSelectionColumn: "Toggle selection", ariaLabelForSelectAllCheckbox: "Toggle selection for all items" }))));
    };
    AnnouncedBulkOperationsExample.prototype._renderAnnounced = function () {
        var numberOfItems = this.state.numberOfItems;
        if (numberOfItems > 0) {
            return React.createElement(Announced, { message: numberOfItems === 1 ? numberOfItems + " item moved" : numberOfItems + " items moved" });
        }
        return;
    };
    AnnouncedBulkOperationsExample.prototype._getDragDropEvents = function () {
        var _this = this;
        return {
            canDrop: function (dropContext, dragContext) {
                return true;
            },
            canDrag: function (item) {
                return true;
            },
            onDragEnter: function (item, event) {
                // return string is the css classes that will be added to the entering element.
                return dragEnterClass;
            },
            onDragLeave: function (item, event) {
                return;
            },
            onDrop: function (item, event) {
                if (_this._draggedItem) {
                    _this._insertBeforeItem(item);
                }
            },
            onDragStart: function (item, itemIndex, selectedItems, event) {
                _this._draggedItem = item;
                _this._draggedIndex = itemIndex;
            },
            onDragEnd: function (item, event) {
                _this._draggedItem = undefined;
                _this._draggedIndex = -1;
            }
        };
    };
    AnnouncedBulkOperationsExample.prototype._onItemInvoked = function (item) {
        alert("Item invoked: " + item.name);
    };
    AnnouncedBulkOperationsExample.prototype._onRenderItemColumn = function (item, index, column) {
        if (column.key === 'name') {
            return React.createElement(Link, { "data-selection-invoke": true }, item[column.key]);
        }
        return item[column.key];
    };
    AnnouncedBulkOperationsExample.prototype._insertBeforeItem = function (item) {
        var draggedItems = this._selection.isIndexSelected(this._draggedIndex)
            ? this._selection.getSelection()
            : [this._draggedItem];
        var items = this.state.items.filter(function (currentItem) { return draggedItems.indexOf(currentItem) === -1; });
        var insertIndex = items.indexOf(item);
        // if dragging/dropping on itself, index will be 0.
        if (insertIndex === -1) {
            insertIndex = 0;
        }
        items.splice.apply(items, [insertIndex, 0].concat(draggedItems));
        this.setState({ items: items, numberOfItems: draggedItems.length });
    };
    return AnnouncedBulkOperationsExample;
}(React.Component));
export { AnnouncedBulkOperationsExample };
//# sourceMappingURL=Announced.BulkOperations.Example.js.map