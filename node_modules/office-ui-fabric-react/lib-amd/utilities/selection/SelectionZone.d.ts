/// <reference types="react" />
import * as React from 'react';
import { BaseComponent } from '../../Utilities';
import { ISelection, SelectionMode, IObjectWithKey } from './interfaces';
export interface ISelectionZone {
    ignoreNextFocus: () => void;
}
export interface ISelectionZoneProps extends React.ClassAttributes<SelectionZone> {
    componentRef?: () => void;
    selection: ISelection;
    /**
     * @deprecated No longer in use, focus is now managed by FocusZone
     */
    layout?: {};
    selectionMode?: SelectionMode;
    selectionPreservedOnEmptyClick?: boolean;
    disableAutoSelectOnInputElements?: boolean;
    enterModalOnTouch?: boolean;
    isSelectedOnFocus?: boolean;
    onItemInvoked?: (item?: IObjectWithKey, index?: number, ev?: Event) => void;
    onItemContextMenu?: (item?: any, index?: number, ev?: Event) => void | boolean;
}
export declare class SelectionZone extends BaseComponent<ISelectionZoneProps, {}> {
    static defaultProps: {
        isMultiSelectEnabled: boolean;
        isSelectedOnFocus: boolean;
        selectionMode: SelectionMode;
    };
    private _root;
    private _isCtrlPressed;
    private _isShiftPressed;
    private _isMetaPressed;
    private _isTabPressed;
    private _shouldHandleFocus;
    private _shouldHandleFocusTimeoutId;
    private _isTouch;
    private _isTouchTimeoutId;
    componentDidMount(): void;
    render(): JSX.Element;
    /**
     * In some cases, the consuming scenario requires to set focus on a row without having SelectionZone
     * react to the event. Note that focus events in IE \<= 11 will occur asynchronously after .focus() has
     * been called on an element, so we need a flag to store the idea that we will bypass the "next"
     * focus event that occurs. This method does that.
     */
    ignoreNextFocus: () => void;
    private _onMouseDownCapture;
    /**
     * When we focus an item, for single/multi select scenarios, we should try to select it immediately
     * as long as the focus did not originate from a mouse down/touch event. For those cases, we handle them
     * specially.
     */
    private _onFocus;
    private _onMouseDown;
    private _onTouchStartCapture;
    private _onClick;
    private _onContextMenu;
    private _isSelectionDisabled(target);
    /**
     * In multi selection, if you double click within an item's root (but not within the invoke element or input elements),
     * we should execute the invoke handler.
     */
    private _onDoubleClick;
    private _onKeyDownCapture;
    private _onKeyDown;
    private _onToggleAllClick(ev);
    private _onToggleClick(ev, index);
    private _onInvokeClick(ev, index);
    private _onItemSurfaceClick(ev, index);
    private _onInvokeMouseDown(ev, index);
    /**
     * To avoid high startup cost of traversing the DOM on component mount,
     * defer finding the scrollable parent until a click interaction.
     *
     * The styles will probably already calculated since we're running in a click handler,
     * so this is less likely to cause layout thrashing then doing it in mount.
     */
    private _findScrollParentAndTryClearOnEmptyClick(ev);
    private _tryClearOnEmptyClick(ev);
    private _clearAndSelectIndex(index);
    /**
     * We need to track the modifier key states so that when focus events occur, which do not contain
     * modifier states in the Event object, we know how to behave.
     */
    private _updateModifiers(ev);
    private _findItemRoot(target);
    private _getItemIndex(itemRoot);
    private _shouldAutoSelect(element);
    private _hasAttribute(element, attributeName);
    private _isInputElement(element);
    private _isNonHandledClick(element);
    private _handleNextFocus(handleFocus);
    private _setIsTouch(isTouch);
    private _getSelectionMode();
}
