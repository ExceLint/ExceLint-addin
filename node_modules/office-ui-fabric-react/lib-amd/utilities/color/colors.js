define(["require", "exports", "tslib", "./colorValues"], function (require, exports, tslib_1, colorValues_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MAX_COLOR_SATURATION = 100;
    exports.MAX_COLOR_HUE = 359;
    exports.MAX_COLOR_VALUE = 100;
    exports.MAX_COLOR_RGB = 255;
    /** @deprecated Use MAX_COLOR_RGB (255) or MAX_COLOR_ALPHA (100) */
    exports.MAX_COLOR_RGBA = exports.MAX_COLOR_RGB;
    exports.MAX_COLOR_ALPHA = 100;
    /**
     * Converts a valid CSS color string to an RGB color.
     * Note that hex colors *must* be prefixed with # to be considered valid.
     * Alpha in returned color defaults to 100.
     */
    function cssColor(color) {
        if (!color) {
            return undefined;
        }
        return _named(color) || _hex3(color) || _hex6(color) || _rgba(color) || _hsla(color);
    }
    exports.cssColor = cssColor;
    /** Converts RGB components to a hex color string (without # prefix). */
    function rgb2hex(r, g, b) {
        return [_rgbToPaddedHex(r), _rgbToPaddedHex(g), _rgbToPaddedHex(b)].join('');
    }
    exports.rgb2hex = rgb2hex;
    /** Converts HSV components to a hex color string (without # prefix). */
    function hsv2hex(h, s, v) {
        var _a = hsv2rgb(h, s, v), r = _a.r, g = _a.g, b = _a.b;
        return rgb2hex(r, g, b);
    }
    exports.hsv2hex = hsv2hex;
    /** Converts RGB components to an HSV color. */
    function rgb2hsv(r, g, b) {
        var h = NaN;
        var s;
        var v;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var delta = max - min;
        // hue
        if (delta === 0) {
            h = 0;
        }
        else if (r === max) {
            h = ((g - b) / delta) % 6;
        }
        else if (g === max) {
            h = (b - r) / delta + 2;
        }
        else if (b === max) {
            h = (r - g) / delta + 4;
        }
        h = Math.round(h * 60);
        if (h < 0) {
            h += 360;
        }
        // saturation
        s = Math.round((max === 0 ? 0 : delta / max) * 100);
        // value
        v = Math.round((max / exports.MAX_COLOR_RGB) * 100);
        return { h: h, s: s, v: v };
    }
    exports.rgb2hsv = rgb2hsv;
    /** Converts HSL components to an HSV color. */
    function hsl2hsv(h, s, l) {
        s *= (l < 50 ? l : 100 - l) / 100;
        var v = l + s;
        return {
            h: h,
            s: v === 0 ? 0 : ((2 * s) / v) * 100,
            v: v
        };
    }
    exports.hsl2hsv = hsl2hsv;
    /** Converts HSV components to an HSL color. */
    function hsv2hsl(h, s, v) {
        s /= exports.MAX_COLOR_SATURATION;
        v /= exports.MAX_COLOR_VALUE;
        var l = (2 - s) * v;
        var sl = s * v;
        sl /= l <= 1 ? l : 2 - l;
        sl = sl || 0;
        l /= 2;
        return { h: h, s: sl * 100, l: l * 100 };
    }
    exports.hsv2hsl = hsv2hsl;
    /** Converts HSL components to an RGB color. Does not set the alpha value. */
    function hsl2rgb(h, s, l) {
        var hsv = hsl2hsv(h, s, l);
        return hsv2rgb(hsv.h, hsv.s, hsv.v);
    }
    exports.hsl2rgb = hsl2rgb;
    /** Converts HSV components to an RGB color. Does not set the alpha value. */
    function hsv2rgb(h, s, v) {
        s = s / 100;
        v = v / 100;
        var rgb = [];
        var c = v * s;
        var hh = h / 60;
        var x = c * (1 - Math.abs((hh % 2) - 1));
        var m = v - c;
        switch (Math.floor(hh)) {
            case 0:
                rgb = [c, x, 0];
                break;
            case 1:
                rgb = [x, c, 0];
                break;
            case 2:
                rgb = [0, c, x];
                break;
            case 3:
                rgb = [0, x, c];
                break;
            case 4:
                rgb = [x, 0, c];
                break;
            case 5:
                rgb = [c, 0, x];
                break;
        }
        return {
            r: Math.round(exports.MAX_COLOR_RGB * (rgb[0] + m)),
            g: Math.round(exports.MAX_COLOR_RGB * (rgb[1] + m)),
            b: Math.round(exports.MAX_COLOR_RGB * (rgb[2] + m))
        };
    }
    exports.hsv2rgb = hsv2rgb;
    /**
     * Converts a CSS color string to a color object.
     * Note that hex colors *must* be prefixed with # to be considered valid.
     *
     * `inputColor` will be used unmodified as the `str` property of the returned object.
     * Alpha defaults to 100 if not specified in `inputColor`.
     * Returns undefined if the color string is invalid/not recognized.
     */
    function getColorFromString(inputColor) {
        var color = cssColor(inputColor);
        if (!color) {
            return;
        }
        return tslib_1.__assign({}, getColorFromRGBA(color), { str: inputColor });
    }
    exports.getColorFromString = getColorFromString;
    /** Converts an RGBA color to a color object (alpha defaults to 100). */
    function getColorFromRGBA(rgba) {
        var _a = rgba.a, a = _a === void 0 ? exports.MAX_COLOR_ALPHA : _a, b = rgba.b, g = rgba.g, r = rgba.r;
        var _b = rgb2hsv(r, g, b), h = _b.h, s = _b.s, v = _b.v;
        var hex = rgb2hex(r, g, b);
        var str = _rgbaOrHexString(r, g, b, a, hex);
        return { a: a, b: b, g: g, h: h, hex: hex, r: r, s: s, str: str, v: v };
    }
    exports.getColorFromRGBA = getColorFromRGBA;
    /**
     * Converts an HSV color (and optional alpha value) to a color object.
     * If `a` is not given, a default of 100 is used.
     * Hex in the returned value will *not* be prefixed with #.
     * If `a` is unspecified or 100, the result's `str` property will contain a hex value
     * (*not* prefixed with #)
     */
    function getColorFromHSV(hsv, a) {
        var h = hsv.h, s = hsv.s, v = hsv.v;
        a = typeof a === 'number' ? a : exports.MAX_COLOR_ALPHA;
        var _a = hsv2rgb(h, s, v), r = _a.r, g = _a.g, b = _a.b;
        var hex = hsv2hex(h, s, v);
        var str = _rgbaOrHexString(r, g, b, a, hex);
        return { a: a, b: b, g: g, h: h, hex: hex, r: r, s: s, str: str, v: v };
    }
    exports.getColorFromHSV = getColorFromHSV;
    /**
     * Converts a color hue to an HTML color string (with # prefix).
     * This implementation ignores all components of `color` except hue.
     */
    function getFullColorString(color) {
        return "#" + hsv2hex(color.h, exports.MAX_COLOR_SATURATION, exports.MAX_COLOR_VALUE);
    }
    exports.getFullColorString = getFullColorString;
    /**
     * Gets a color with the same hue as `color` and other components updated to match the given
     * saturation and value.
     *
     * Does not modify the original `color` and does not supply a default alpha value.
     */
    function updateSV(color, s, v) {
        var _a = hsv2rgb(color.h, s, v), r = _a.r, g = _a.g, b = _a.b;
        var hex = rgb2hex(r, g, b);
        return {
            a: color.a,
            b: b,
            g: g,
            h: color.h,
            hex: hex,
            r: r,
            s: s,
            str: _rgbaOrHexString(r, g, b, color.a, hex),
            v: v
        };
    }
    exports.updateSV = updateSV;
    /**
     * Gets a color with the same saturation and value as `color` and the other components updated
     * to match the given hue.
     *
     * Does not modify the original `color` and does not supply a default alpha value.
     */
    function updateH(color, h) {
        var _a = hsv2rgb(h, color.s, color.v), r = _a.r, g = _a.g, b = _a.b;
        var hex = rgb2hex(r, g, b);
        return {
            a: color.a,
            b: b,
            g: g,
            h: h,
            hex: hex,
            r: r,
            s: color.s,
            str: _rgbaOrHexString(r, g, b, color.a, hex),
            v: color.v
        };
    }
    exports.updateH = updateH;
    /**
     * Gets a color with a single RGBA component updated to a new value.
     * Does not modify the original `color`. Alpha defaults to 100 if not set.
     */
    function updateRGB(color, component, value) {
        return getColorFromRGBA((_a = {
                r: color.r,
                g: color.g,
                b: color.b,
                a: color.a
            },
            _a[component] = value,
            _a));
        var _a;
    }
    exports.updateRGB = updateRGB;
    /**
     * Gets a color with the given alpha value and the same other components as `color`.
     * Does not modify the original color.
     */
    function updateA(color, a) {
        return tslib_1.__assign({}, color, { a: a, str: _rgbaOrHexString(color.r, color.g, color.b, a, color.hex) });
    }
    exports.updateA = updateA;
    /** Corrects an RGB color to fall within the valid range.  */
    function correctRGB(color) {
        return {
            r: clamp(color.r, exports.MAX_COLOR_RGB),
            g: clamp(color.g, exports.MAX_COLOR_RGB),
            b: clamp(color.b, exports.MAX_COLOR_RGB),
            a: typeof color.a === 'number' ? clamp(color.a, exports.MAX_COLOR_ALPHA) : color.a
        };
    }
    exports.correctRGB = correctRGB;
    /** Corrects an HSV color to fall within the valid range. */
    function correctHSV(color) {
        return {
            h: clamp(color.h, exports.MAX_COLOR_HUE),
            s: clamp(color.s, exports.MAX_COLOR_SATURATION),
            v: clamp(color.v, exports.MAX_COLOR_VALUE)
        };
    }
    exports.correctHSV = correctHSV;
    /** Clamp a value to ensure it falls within a given range. */
    function clamp(value, max, min) {
        if (min === void 0) { min = 0; }
        return value < min ? min : value > max ? max : value;
    }
    exports.clamp = clamp;
    /** Converts an RGB component to a 0-padded hex component of length 2. */
    function _rgbToPaddedHex(num) {
        num = clamp(num, exports.MAX_COLOR_RGB);
        var hex = num.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }
    /**
     * If `str` is a valid HTML color name, returns an RGB color (with alpha 100).
     * Otherwise returns undefined.
     */
    function _named(str) {
        var c = colorValues_1.COLOR_VALUES[str.toLowerCase()];
        if (c) {
            return {
                r: c[0],
                g: c[1],
                b: c[2],
                a: exports.MAX_COLOR_ALPHA
            };
        }
    }
    /**
     * If `str` is in valid `rgb()` or `rgba()` format, returns an RGB color (alpha defaults to 100).
     * Otherwise returns undefined.
     */
    function _rgba(str) {
        var match = str.match(/^rgb(a?)\(([\d., ]+)\)$/);
        if (match) {
            var hasAlpha = !!match[1];
            var expectedPartCount = hasAlpha ? 4 : 3;
            var parts = match[2].split(/ *, */).map(Number);
            if (parts.length === expectedPartCount) {
                return {
                    r: parts[0],
                    g: parts[1],
                    b: parts[2],
                    a: hasAlpha ? parts[3] * 100 : exports.MAX_COLOR_ALPHA
                };
            }
        }
    }
    /**
     * If `str` is in valid 6-digit hex format *with* # prefix, returns an RGB color (with alpha 100).
     * Otherwise returns undefined.
     */
    function _hex6(str) {
        if ('#' === str[0] && 7 === str.length && /^#[\da-fA-F]{6}$/.test(str)) {
            return {
                r: parseInt(str.slice(1, 3), 16),
                g: parseInt(str.slice(3, 5), 16),
                b: parseInt(str.slice(5, 7), 16),
                a: exports.MAX_COLOR_ALPHA
            };
        }
    }
    /**
     * If `str` is in valid 3-digit hex format *with* # prefix, returns an RGB color (with alpha 100).
     * Otherwise returns undefined.
     */
    function _hex3(str) {
        if ('#' === str[0] && 4 === str.length && /^#[\da-fA-F]{3}$/.test(str)) {
            return {
                r: parseInt(str[1] + str[1], 16),
                g: parseInt(str[2] + str[2], 16),
                b: parseInt(str[3] + str[3], 16),
                a: exports.MAX_COLOR_ALPHA
            };
        }
    }
    /**
     * If `str` is in `hsl()` or `hsla()` format, returns an RGB color (alpha defaults to 100).
     * Otherwise returns undefined.
     */
    function _hsla(str) {
        var match = str.match(/^hsl(a?)\(([\d., ]+)\)$/);
        if (match) {
            var hasAlpha = !!match[1];
            var expectedPartCount = hasAlpha ? 4 : 3;
            var parts = match[2].split(/ *, */).map(Number);
            if (parts.length === expectedPartCount) {
                var rgba = hsl2rgb(parts[0], parts[1], parts[2]);
                rgba.a = hasAlpha ? parts[3] * 100 : exports.MAX_COLOR_ALPHA;
                return rgba;
            }
        }
    }
    /**
     * Get a CSS color string from some color components.
     * If `a` is specified and not 100, returns an `rgba()` string.
     * Otherwise returns `hex` prefixed with #.
     */
    function _rgbaOrHexString(r, g, b, a, hex) {
        return a === exports.MAX_COLOR_ALPHA || typeof a !== 'number' ? "#" + hex : "rgba(" + r + ", " + g + ", " + b + ", " + a / exports.MAX_COLOR_ALPHA + ")";
    }
});
//# sourceMappingURL=colors.js.map