{"version":3,"file":"positioning.js","sourceRoot":"../src/","sources":["utilities/positioning/positioning.ts"],"names":[],"mappings":"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","sourcesContent":["import { DirectionalHint } from '../../common/DirectionalHint';\r\nimport { getScrollbarWidth, getRTL, Rectangle as FullRectangle, IRectangle } from '../../Utilities';\r\nimport {\r\n  IPositionDirectionalHintData,\r\n  IPositionedData,\r\n  IPoint,\r\n  ICalloutPositionedInfo,\r\n  ICalloutBeakPositionedInfo,\r\n  IPositionProps,\r\n  ICalloutPositionProps,\r\n  RectangleEdge\r\n} from './positioning.types';\r\n\r\nexport class Rectangle extends FullRectangle {\r\n  [key: string]: number | boolean | any;\r\n}\r\n\r\nfunction _createPositionData(targetEdge: RectangleEdge, alignmentEdge?: RectangleEdge, isAuto?: boolean): IPositionDirectionalHintData {\r\n  return {\r\n    targetEdge: targetEdge,\r\n    alignmentEdge: alignmentEdge,\r\n    isAuto: isAuto\r\n  };\r\n}\r\n\r\n// Currently the beakPercent is set to 50 for all positions meaning that it should tend to the center of the target\r\nconst DirectionalDictionary: { [key: number]: IPositionDirectionalHintData } = {\r\n  [DirectionalHint.topLeftEdge]: _createPositionData(RectangleEdge.top, RectangleEdge.left),\r\n  [DirectionalHint.topCenter]: _createPositionData(RectangleEdge.top),\r\n  [DirectionalHint.topRightEdge]: _createPositionData(RectangleEdge.top, RectangleEdge.right),\r\n  [DirectionalHint.topAutoEdge]: _createPositionData(RectangleEdge.top, undefined, true),\r\n  [DirectionalHint.bottomLeftEdge]: _createPositionData(RectangleEdge.bottom, RectangleEdge.left),\r\n  [DirectionalHint.bottomCenter]: _createPositionData(RectangleEdge.bottom),\r\n  [DirectionalHint.bottomRightEdge]: _createPositionData(RectangleEdge.bottom, RectangleEdge.right),\r\n  [DirectionalHint.bottomAutoEdge]: _createPositionData(RectangleEdge.bottom, undefined, true),\r\n  [DirectionalHint.leftTopEdge]: _createPositionData(RectangleEdge.left, RectangleEdge.top),\r\n  [DirectionalHint.leftCenter]: _createPositionData(RectangleEdge.left),\r\n  [DirectionalHint.leftBottomEdge]: _createPositionData(RectangleEdge.left, RectangleEdge.bottom),\r\n  [DirectionalHint.rightTopEdge]: _createPositionData(RectangleEdge.right, RectangleEdge.top),\r\n  [DirectionalHint.rightCenter]: _createPositionData(RectangleEdge.right),\r\n  [DirectionalHint.rightBottomEdge]: _createPositionData(RectangleEdge.right, RectangleEdge.bottom)\r\n};\r\n\r\n/**\r\n * Do not call methods from this directly, use either positionCallout or positionElement or make another function that\r\n * utilizes them.\r\n * START Private functions and interfaces\r\n */\r\n\r\nexport interface IElementPosition {\r\n  elementRectangle: Rectangle;\r\n  targetEdge: RectangleEdge;\r\n  alignmentEdge: RectangleEdge | undefined;\r\n}\r\n\r\nexport interface IElementPositionInfo extends IElementPosition {\r\n  targetRectangle: Rectangle;\r\n}\r\n\r\ntype PartialIRectangle = Partial<IRectangle>;\r\n\r\ninterface IPartialIRectangle extends PartialIRectangle {\r\n  [key: string]: number | undefined;\r\n}\r\n\r\nfunction _isRectangleWithinBounds(rect: Rectangle, boundingRect: Rectangle): boolean {\r\n  if (rect.top < boundingRect.top) {\r\n    return false;\r\n  }\r\n  if (rect.bottom > boundingRect.bottom) {\r\n    return false;\r\n  }\r\n  if (rect.left < boundingRect.left) {\r\n    return false;\r\n  }\r\n  if (rect.right > boundingRect.right) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Gets all of the edges of a rectangle that are outside of the given bounds.\r\n * If there are no out of bounds edges it returns an empty array.\r\n */\r\nfunction _getOutOfBoundsEdges(rect: Rectangle, boundingRect: Rectangle): RectangleEdge[] {\r\n  const outOfBounds: RectangleEdge[] = new Array<RectangleEdge>();\r\n\r\n  if (rect.top < boundingRect.top) {\r\n    outOfBounds.push(RectangleEdge.top);\r\n  }\r\n  if (rect.bottom > boundingRect.bottom) {\r\n    outOfBounds.push(RectangleEdge.bottom);\r\n  }\r\n  if (rect.left < boundingRect.left) {\r\n    outOfBounds.push(RectangleEdge.left);\r\n  }\r\n  if (rect.right > boundingRect.right) {\r\n    outOfBounds.push(RectangleEdge.right);\r\n  }\r\n\r\n  return outOfBounds;\r\n}\r\n\r\nfunction _getEdgeValue(rect: Rectangle, edge: RectangleEdge): number {\r\n  return rect[RectangleEdge[edge]];\r\n}\r\n\r\nfunction _setEdgeValue(rect: Rectangle, edge: RectangleEdge, value: number) {\r\n  rect[RectangleEdge[edge]] = value;\r\n  return rect;\r\n}\r\n\r\n/**\r\n * Returns the middle value of an edge. Only returns 1 value rather than xy coordinates as\r\n * the itself already contains the other coordinate.\r\n * For instance, a bottom edge's current value is it's y coordinate, so the number returned is the x.\r\n *\r\n * @param {Rectangle} rect\r\n * @param {RectangleEdge} edge\r\n * @returns {number}\r\n */\r\nfunction _getCenterValue(rect: Rectangle, edge: RectangleEdge): number {\r\n  const edges = _getFlankingEdges(edge);\r\n  return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;\r\n}\r\n\r\n/**\r\n * Flips the value depending on the edge.\r\n * If the edge is a \"positive\" edge, Top or Left, then the value should stay as it is.\r\n * If the edge is a \"negative\" edge, Bottom or Right, then the value should be flipped.\r\n * This is to account for the fact that the coordinates are effectively reveserved in certain cases for the \"negative\" edges.\r\n * For example, when testing to see if a bottom edge 1 is within the bounds of another bottom edge 2.\r\n * If edge 1 is greater than edge 2 then it is out of bounds. This is reversed for top edge 1 and top edge 2.\r\n * If top edge 1 is less than edge 2 then it is out of bounds.\r\n *\r\n *\r\n * @param {RectangleEdge} edge\r\n * @param {number} value\r\n * @returns {number}\r\n */\r\nfunction _getRelativeEdgeValue(edge: RectangleEdge, value: number): number {\r\n  if (edge > 0) {\r\n    return value;\r\n  } else {\r\n    return value * -1;\r\n  }\r\n}\r\n\r\nfunction _getRelativeRectEdgeValue(edge: RectangleEdge, rect: Rectangle): number {\r\n  return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));\r\n}\r\n\r\nfunction _getRelativeEdgeDifference(rect: Rectangle, hostRect: Rectangle, edge: RectangleEdge): number {\r\n  const edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);\r\n  return _getRelativeEdgeValue(edge, edgeDifference);\r\n}\r\n\r\n/**\r\n * Moves the edge of a rectangle to the value given. It only moves the edge in a linear direction based on that edge.\r\n * For example, if it's a bottom edge it will only change y coordinates.\r\n *\r\n * @param {Rectangle} rect\r\n * @param {RectangleEdge} edge\r\n * @param {number} newValue\r\n * @returns {Rectangle}\r\n */\r\nfunction _moveEdge(rect: Rectangle, edge: RectangleEdge, newValue: number): Rectangle {\r\n  const difference = _getEdgeValue(rect, edge) - newValue;\r\n  rect = _setEdgeValue(rect, edge, newValue);\r\n  rect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);\r\n  return rect;\r\n}\r\n\r\n/**\r\n * Aligns the edge on the passed in rect to the target. If there is a gap then it will have that space between the two.\r\n *\r\n * @param {Rectangle} rect\r\n * @param {Rectangle} target\r\n * @param {RectangleEdge} edge\r\n * @param {number} [gap=0]\r\n * @returns {Rectangle}\r\n */\r\nfunction _alignEdges(rect: Rectangle, target: Rectangle, edge: RectangleEdge, gap: number = 0): Rectangle {\r\n  return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));\r\n}\r\n\r\n/**\r\n * Aligns the targetEdge on the passed in target to the rects corresponding opposite edge.\r\n * For instance if targetEdge is bottom, then the rects top will be moved to match it.\r\n *\r\n * @param {Rectangle} rect\r\n * @param {Rectangle} target\r\n * @param {RectangleEdge} targetEdge\r\n * @param {number} [gap=0]\r\n * @returns {Rectangle}\r\n */\r\nfunction _alignOppositeEdges(rect: Rectangle, target: Rectangle, targetEdge: RectangleEdge, gap: number = 0): Rectangle {\r\n  const oppositeEdge = targetEdge * -1;\r\n  const adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);\r\n  return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);\r\n}\r\n\r\n/**\r\n * Tests to see if the given edge is within the bounds of the given rectangle.\r\n *\r\n * @param {Rectangle} rect\r\n * @param {Rectangle} bounds\r\n * @param {RectangleEdge} edge\r\n * @returns {boolean}\r\n */\r\nfunction _isEdgeInBounds(rect: Rectangle, bounds: Rectangle, edge: RectangleEdge): boolean {\r\n  const adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);\r\n  return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);\r\n}\r\n\r\n/**\r\n * Attempts to move the rectangle through various sides of the target to find a place to fit.\r\n * If no fit is found, the original position should be returned.\r\n *\r\n * @param {Rectangle} rect\r\n * @param {Rectangle} target\r\n * @param {Rectangle} bounding\r\n * @param {IPositionDirectionalHintData} positionData\r\n * @param {number} [gap=0]\r\n * @returns {IElementPosition}\r\n */\r\nfunction _flipToFit(\r\n  rect: Rectangle,\r\n  target: Rectangle,\r\n  bounding: Rectangle,\r\n  positionData: IPositionDirectionalHintData,\r\n  gap: number = 0\r\n): IElementPosition {\r\n  const directions: RectangleEdge[] = [RectangleEdge.left, RectangleEdge.right, RectangleEdge.bottom, RectangleEdge.top];\r\n  let currentEstimate = rect;\r\n  let currentEdge = positionData.targetEdge;\r\n  let currentAlignment = positionData.alignmentEdge;\r\n  // Keep switching sides until one is found with enough space. If all sides don't fit then return the unmodified element.\r\n  for (let i = 0; i < 4; i++) {\r\n    if (!_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {\r\n      directions.splice(directions.indexOf(currentEdge), 1);\r\n      if (directions.indexOf(currentEdge * -1) > -1) {\r\n        currentEdge = currentEdge * -1;\r\n      } else {\r\n        currentAlignment = currentEdge;\r\n        currentEdge = directions.slice(-1)[0];\r\n      }\r\n      currentEstimate = _estimatePosition(rect, target, { targetEdge: currentEdge, alignmentEdge: currentAlignment }, gap);\r\n    } else {\r\n      return {\r\n        elementRectangle: currentEstimate,\r\n        targetEdge: currentEdge,\r\n        alignmentEdge: currentAlignment\r\n      };\r\n    }\r\n  }\r\n  return {\r\n    elementRectangle: rect,\r\n    targetEdge: positionData.targetEdge,\r\n    alignmentEdge: currentAlignment\r\n  };\r\n}\r\n\r\n/**\r\n * Flips only the alignment edge of an element rectangle. This is used instead of nudging the alignment edges into position,\r\n * when alignTargetEdge is specified.\r\n * @param elementEstimate\r\n * @param target\r\n * @param bounding\r\n * @param gap\r\n */\r\nfunction _flipAlignmentEdge(elementEstimate: IElementPosition, target: Rectangle, gap: number, coverTarget?: boolean): IElementPosition {\r\n  const { alignmentEdge, targetEdge, elementRectangle } = elementEstimate;\r\n  const oppositeEdge = alignmentEdge! * -1;\r\n  const newEstimate = _estimatePosition(\r\n    elementRectangle,\r\n    target,\r\n    { targetEdge: targetEdge, alignmentEdge: oppositeEdge },\r\n    gap,\r\n    coverTarget\r\n  );\r\n\r\n  return {\r\n    elementRectangle: newEstimate,\r\n    targetEdge: targetEdge,\r\n    alignmentEdge: oppositeEdge\r\n  };\r\n}\r\n\r\n/**\r\n * Adjusts a element rectangle to fit within the bounds given. If directionalHintFixed or covertarget is passed in\r\n * then the element will not flip sides on the target. They will, however, be nudged to fit within the bounds given.\r\n *\r\n * @param {Rectangle} element\r\n * @param {Rectangle} target\r\n * @param {Rectangle} bounding\r\n * @param {IPositionDirectionalHintData} positionData\r\n * @param {number} [gap=0]\r\n * @param {boolean} [directionalHintFixed]\r\n * @param {boolean} [coverTarget]\r\n * @returns {IElementPosition}\r\n */\r\nfunction _adjustFitWithinBounds(\r\n  element: Rectangle,\r\n  target: Rectangle,\r\n  bounding: Rectangle,\r\n  positionData: IPositionDirectionalHintData,\r\n  gap: number = 0,\r\n  directionalHintFixed?: boolean,\r\n  coverTarget?: boolean\r\n): IElementPosition {\r\n  const { alignmentEdge, alignTargetEdge } = positionData;\r\n  let elementEstimate: IElementPosition = {\r\n    elementRectangle: element,\r\n    targetEdge: positionData.targetEdge,\r\n    alignmentEdge: alignmentEdge\r\n  };\r\n\r\n  if (!directionalHintFixed && !coverTarget) {\r\n    elementEstimate = _flipToFit(element, target, bounding, positionData, gap);\r\n  }\r\n\r\n  const outOfBounds = _getOutOfBoundsEdges(element, bounding);\r\n\r\n  if (alignTargetEdge) {\r\n    // The edge opposite to the alignment edge might be out of bounds. Flip alignment to see if we can get it within bounds.\r\n    if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {\r\n      const flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);\r\n      if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {\r\n        return flippedElementEstimate;\r\n      }\r\n    }\r\n  } else {\r\n    for (const direction of outOfBounds) {\r\n      elementEstimate.elementRectangle = _alignEdges(elementEstimate.elementRectangle, bounding, direction);\r\n    }\r\n  }\r\n\r\n  return elementEstimate;\r\n}\r\n\r\n/**\r\n * Moves the middle point on an edge to the point given.\r\n * Only moves in one direction. For instance if a bottom edge is passed in, then\r\n * the bottom edge will be moved in the x axis to match the point.\r\n *\r\n * @param {Rectangle} rect\r\n * @param {RectangleEdge} edge\r\n * @param {number} point\r\n * @returns {Rectangle}\r\n */\r\nfunction _centerEdgeToPoint(rect: Rectangle, edge: RectangleEdge, point: number): Rectangle {\r\n  const { positiveEdge } = _getFlankingEdges(edge);\r\n  const elementMiddle = _getCenterValue(rect, edge);\r\n  const distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);\r\n  return _moveEdge(rect, positiveEdge, point - distanceToMiddle);\r\n}\r\n\r\n/**\r\n * Moves the element rectangle to be appropriately positioned relative to a given target.\r\n * Does not flip or adjust the element.\r\n *\r\n * @param {Rectangle} elementToPosition\r\n * @param {Rectangle} target\r\n * @param {IPositionDirectionalHintData} positionData\r\n * @param {number} [gap=0]\r\n * @param {boolean} [coverTarget]\r\n * @returns {Rectangle}\r\n */\r\nfunction _estimatePosition(\r\n  elementToPosition: Rectangle,\r\n  target: Rectangle,\r\n  positionData: IPositionDirectionalHintData,\r\n  gap: number = 0,\r\n  coverTarget?: boolean\r\n): Rectangle {\r\n  let estimatedElementPosition: Rectangle;\r\n  const { alignmentEdge, targetEdge } = positionData;\r\n  const elementEdge = coverTarget ? targetEdge : targetEdge * -1;\r\n  estimatedElementPosition = coverTarget\r\n    ? _alignEdges(elementToPosition, target, targetEdge, gap)\r\n    : _alignOppositeEdges(elementToPosition, target, targetEdge, gap);\r\n  // if no alignment edge is provided it's supposed to be centered.\r\n  if (!alignmentEdge) {\r\n    const targetMiddlePoint = _getCenterValue(target, targetEdge);\r\n    estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);\r\n  } else {\r\n    estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);\r\n  }\r\n\r\n  return estimatedElementPosition;\r\n}\r\n\r\n/**\r\n * Returns the non-opposite edges of the target edge.\r\n * For instance if bottom is passed in then left and right will be returned.\r\n *\r\n * @param {RectangleEdge} edge\r\n * @returns {{ firstEdge: RectangleEdge, secondEdge: RectangleEdge }}\r\n */\r\nfunction _getFlankingEdges(edge: RectangleEdge): { positiveEdge: RectangleEdge; negativeEdge: RectangleEdge } {\r\n  if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {\r\n    return {\r\n      positiveEdge: RectangleEdge.left,\r\n      negativeEdge: RectangleEdge.right\r\n    };\r\n  } else {\r\n    return {\r\n      positiveEdge: RectangleEdge.top,\r\n      negativeEdge: RectangleEdge.bottom\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Retrieve the final value for the return edge of elementRectangle.\r\n * If the elementRectangle is closer to one side of the bounds versus the other, the return edge is flipped to grow inward.\r\n *\r\n * @param elementRectangle\r\n * @param targetEdge\r\n * @param bounds\r\n */\r\nfunction _finalizeReturnEdge(elementRectangle: Rectangle, returnEdge: RectangleEdge, bounds?: Rectangle): RectangleEdge {\r\n  if (\r\n    bounds &&\r\n    Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) >\r\n      Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))\r\n  ) {\r\n    return returnEdge * -1;\r\n  }\r\n\r\n  return returnEdge;\r\n}\r\n\r\n/**\r\n * Finalizes the element positon based on the hostElement. Only returns the\r\n * rectangle values to position such that they are anchored to the target.\r\n * This helps prevent resizing from looking very strange.\r\n * For instance, if the target edge is top and aligned with the left side then\r\n * the bottom and left values are returned so as the callou shrinks it shrinks towards that corner.\r\n *\r\n * @param {Rectangle} elementRectangle\r\n * @param {HTMLElement} hostElement\r\n * @param {RectangleEdge} targetEdge\r\n * @param {RectangleEdge} bounds\r\n * @param {RectangleEdge} [alignmentEdge]\r\n * @param {boolean} coverTarget\r\n * @returns {IPartialIRectangle}\r\n */\r\nfunction _finalizeElementPosition(\r\n  elementRectangle: Rectangle,\r\n  hostElement: HTMLElement,\r\n  targetEdge: RectangleEdge,\r\n  bounds?: Rectangle,\r\n  alignmentEdge?: RectangleEdge,\r\n  coverTarget?: boolean\r\n): IPartialIRectangle {\r\n  const returnValue: IPartialIRectangle = {};\r\n\r\n  const hostRect: Rectangle = _getRectangleFromElement(hostElement);\r\n  const elementEdge = coverTarget ? targetEdge : targetEdge * -1;\r\n  const elementEdgeString = RectangleEdge[elementEdge];\r\n  const returnEdge = _finalizeReturnEdge(\r\n    elementRectangle,\r\n    alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge,\r\n    bounds\r\n  );\r\n\r\n  returnValue[elementEdgeString] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);\r\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);\r\n\r\n  return returnValue;\r\n}\r\n\r\n// Since the beak is rotated 45 degrees the actual height/width is the length of the diagonal.\r\n// We still want to position the beak based on it's midpoint which does not change. It will\r\n// be at (beakwidth / 2, beakwidth / 2)\r\nfunction _calculateActualBeakWidthInPixels(beakWidth: number): number {\r\n  return Math.sqrt(beakWidth * beakWidth * 2);\r\n}\r\n\r\n/**\r\n * Returns the appropriate IPositionData based on the props altered for RTL.\r\n * If directionalHintForRTL is passed in that is used if the page is RTL.\r\n * If a directionalHint is specified and no directionalHintForRTL is available and the page is RTL the hint will be flipped.\r\n * For instance bottomLeftEdge would become bottomRightEdge.\r\n * If there is no directionalHint passed in bottomAutoEdge is chosen automatically.\r\n *\r\n * @param {IPositionProps} props\r\n * @returns {IPositionDirectionalHintData}\r\n */\r\nfunction _getPositionData(\r\n  directionalHint: DirectionalHint = DirectionalHint.bottomAutoEdge,\r\n  directionalHintForRTL?: DirectionalHint,\r\n  previousPositions?: IPositionDirectionalHintData\r\n): IPositionDirectionalHintData {\r\n  if (previousPositions) {\r\n    return {\r\n      alignmentEdge: previousPositions.alignmentEdge,\r\n      isAuto: previousPositions.isAuto,\r\n      targetEdge: previousPositions.targetEdge\r\n    };\r\n  }\r\n  const positionInformation: IPositionDirectionalHintData = { ...DirectionalDictionary[directionalHint] };\r\n  if (getRTL()) {\r\n    // If alignment edge exists and that alignment edge is -2 or 2, right or left, then flip it.\r\n    if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {\r\n      positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;\r\n    }\r\n\r\n    return directionalHintForRTL !== undefined ? DirectionalDictionary[directionalHintForRTL] : positionInformation;\r\n  }\r\n  return positionInformation;\r\n}\r\n\r\n/**\r\n * Get's the alignment data for the given information. This only really matters if the positioning is Auto.\r\n * If it is auto then the alignmentEdge should be chosen based on the target edge's position relative to\r\n * the center of the page.\r\n *\r\n * @param {IPositionDirectionalHintData} positionData\r\n * @param {Rectangle} target\r\n * @param {Rectangle} boundingRect\r\n * @param {boolean} [coverTarget]\r\n * @returns {IPositionDirectionalHintData}\r\n */\r\nfunction _getAlignmentData(\r\n  positionData: IPositionDirectionalHintData,\r\n  target: Rectangle,\r\n  boundingRect: Rectangle,\r\n  coverTarget?: boolean,\r\n  alignTargetEdge?: boolean\r\n): IPositionDirectionalHintData {\r\n  if (positionData.isAuto) {\r\n    positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);\r\n  }\r\n\r\n  positionData.alignTargetEdge = alignTargetEdge;\r\n  return positionData;\r\n}\r\n\r\nfunction getClosestEdge(targetEdge: RectangleEdge, target: Rectangle, boundingRect: Rectangle): RectangleEdge {\r\n  const targetCenter: number = _getCenterValue(target, targetEdge);\r\n  const boundingCenter: number = _getCenterValue(boundingRect, targetEdge);\r\n  const { positiveEdge, negativeEdge } = _getFlankingEdges(targetEdge);\r\n  if (targetCenter <= boundingCenter) {\r\n    return positiveEdge;\r\n  } else {\r\n    return negativeEdge;\r\n  }\r\n}\r\n\r\nfunction _positionElementWithinBounds(\r\n  elementToPosition: Rectangle,\r\n  target: Rectangle,\r\n  bounding: Rectangle,\r\n  positionData: IPositionDirectionalHintData,\r\n  gap: number,\r\n  directionalHintFixed?: boolean,\r\n  coverTarget?: boolean\r\n): IElementPosition {\r\n  const estimatedElementPosition: Rectangle = _estimatePosition(elementToPosition, target, positionData, gap, coverTarget);\r\n  if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {\r\n    return {\r\n      elementRectangle: estimatedElementPosition,\r\n      targetEdge: positionData.targetEdge,\r\n      alignmentEdge: positionData.alignmentEdge\r\n    };\r\n  } else {\r\n    return _adjustFitWithinBounds(elementToPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget);\r\n  }\r\n}\r\n\r\nfunction _finalizeBeakPosition(\r\n  elementPosition: IElementPosition,\r\n  positionedBeak: Rectangle,\r\n  bounds?: Rectangle\r\n): ICalloutBeakPositionedInfo {\r\n  const targetEdge = elementPosition.targetEdge * -1;\r\n  // The \"host\" element that we will use to help position the beak.\r\n  const actualElement = new Rectangle(0, elementPosition.elementRectangle.width, 0, elementPosition.elementRectangle.height);\r\n  const returnValue: IPartialIRectangle = {};\r\n  const returnEdge = _finalizeReturnEdge(\r\n    elementPosition.elementRectangle,\r\n    elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge,\r\n    bounds\r\n  );\r\n\r\n  returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);\r\n  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);\r\n\r\n  return {\r\n    elementPosition: { ...returnValue },\r\n    closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),\r\n    targetEdge: targetEdge\r\n  };\r\n}\r\n\r\nfunction _positionBeak(beakWidth: number, elementPosition: IElementPositionInfo): Rectangle {\r\n  const target = elementPosition.targetRectangle;\r\n  /**\r\n   * Note about beak positioning: The actual beak width only matters for getting the gap between the callout and\r\n   * target, it does not impact the beak placement within the callout. For example example, if the beakWidth is 8,\r\n   * then the actual beakWidth is sqrroot(8^2 + 8^2) = 11.31x11.31. So the callout will need to be an extra 3 pixels\r\n   * away from its target. While the beak is being positioned in the callout it still acts as though it were 8x8.\r\n   * */\r\n  const { positiveEdge, negativeEdge } = _getFlankingEdges(elementPosition.targetEdge);\r\n  const beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);\r\n  const elementBounds = new Rectangle(\r\n    beakWidth / 2,\r\n    elementPosition.elementRectangle.width - beakWidth / 2,\r\n    beakWidth / 2,\r\n    elementPosition.elementRectangle.height - beakWidth / 2\r\n  );\r\n\r\n  let beakPositon: Rectangle = new Rectangle(0, beakWidth, 0, beakWidth);\r\n\r\n  beakPositon = _moveEdge(beakPositon, elementPosition.targetEdge * -1, -beakWidth / 2);\r\n\r\n  beakPositon = _centerEdgeToPoint(\r\n    beakPositon,\r\n    elementPosition.targetEdge * -1,\r\n    beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle)\r\n  );\r\n\r\n  if (!_isEdgeInBounds(beakPositon, elementBounds, positiveEdge)) {\r\n    beakPositon = _alignEdges(beakPositon, elementBounds, positiveEdge);\r\n  } else if (!_isEdgeInBounds(beakPositon, elementBounds, negativeEdge)) {\r\n    beakPositon = _alignEdges(beakPositon, elementBounds, negativeEdge);\r\n  }\r\n\r\n  return beakPositon;\r\n}\r\n\r\nfunction _getRectangleFromElement(element: Element): Rectangle {\r\n  const clientRect: ClientRect = element.getBoundingClientRect();\r\n\r\n  return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);\r\n}\r\n\r\nfunction _getRectangleFromIRect(rect: IRectangle): Rectangle {\r\n  return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);\r\n}\r\n\r\nfunction _getTargetRect(bounds: Rectangle, target: Element | MouseEvent | IPoint | undefined): Rectangle {\r\n  let targetRectangle: Rectangle;\r\n  if (target) {\r\n    if ((target as MouseEvent).preventDefault) {\r\n      const ev = target as MouseEvent;\r\n      targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);\r\n    } else if ((target as Element).getBoundingClientRect) {\r\n      targetRectangle = _getRectangleFromElement(target as Element);\r\n      // HTMLImgElements can have x and y values. The check for it being a point must go last.\r\n    } else {\r\n      const point: IPoint = target as IPoint;\r\n      targetRectangle = new Rectangle(point.x, point.x, point.y, point.y);\r\n    }\r\n\r\n    if (!_isRectangleWithinBounds(targetRectangle, bounds)) {\r\n      const outOfBounds: RectangleEdge[] = _getOutOfBoundsEdges(targetRectangle, bounds);\r\n\r\n      for (const direction of outOfBounds) {\r\n        (targetRectangle as any)[RectangleEdge[direction]] = (bounds as any)[RectangleEdge[direction]];\r\n      }\r\n    }\r\n  } else {\r\n    targetRectangle = new Rectangle(0, 0, 0, 0);\r\n  }\r\n\r\n  return targetRectangle;\r\n}\r\n\r\n/**\r\n * If max height is less than zero it returns the bounds height instead.\r\n */\r\nfunction _getMaxHeightFromTargetRectangle(\r\n  targetRectangle: Rectangle,\r\n  targetEdge: DirectionalHint,\r\n  gapSpace: number,\r\n  bounds: Rectangle,\r\n  coverTarget?: boolean\r\n) {\r\n  let maxHeight = 0;\r\n  const directionalHint = DirectionalDictionary[targetEdge];\r\n\r\n  // If cover target is set, then the max height should be calculated using the opposite of the target edge since\r\n  // that's the direction that the callout will expand in.\r\n  // For instance, if the directionalhint is bottomLeftEdge then the callout will position so it's bottom edge\r\n  // is aligned with the bottom of the target and expand up towards the top of the screen and the calculated max height\r\n  // is (bottom of target) - (top of screen) - gapSpace.\r\n  const target = coverTarget ? directionalHint.targetEdge * -1 : directionalHint.targetEdge;\r\n\r\n  if (target === RectangleEdge.top) {\r\n    maxHeight = _getEdgeValue(targetRectangle, directionalHint.targetEdge) - bounds.top - gapSpace;\r\n  } else if (target === RectangleEdge.bottom) {\r\n    maxHeight = bounds.bottom - _getEdgeValue(targetRectangle, directionalHint.targetEdge) - gapSpace;\r\n  } else {\r\n    maxHeight = bounds.bottom - targetRectangle.top - gapSpace;\r\n  }\r\n\r\n  return maxHeight > 0 ? maxHeight : bounds.height;\r\n}\r\n\r\nfunction _positionElementRelative(\r\n  props: IPositionProps,\r\n  elementToPosition: HTMLElement,\r\n  boundingRect: Rectangle,\r\n  previousPositions?: IPositionedData\r\n): IElementPositionInfo {\r\n  const gap: number = props.gapSpace ? props.gapSpace : 0;\r\n  const targetRect: Rectangle = _getTargetRect(boundingRect, props.target);\r\n  const positionData: IPositionDirectionalHintData = _getAlignmentData(\r\n    _getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions)!,\r\n    targetRect,\r\n    boundingRect,\r\n    props.coverTarget,\r\n    props.alignTargetEdge\r\n  );\r\n  const positionedElement: IElementPosition = _positionElementWithinBounds(\r\n    _getRectangleFromElement(elementToPosition),\r\n    targetRect,\r\n    boundingRect,\r\n    positionData,\r\n    gap,\r\n    props.directionalHintFixed,\r\n    props.coverTarget\r\n  );\r\n  return { ...positionedElement, targetRectangle: targetRect };\r\n}\r\n\r\nfunction _finalizePositionData(\r\n  positionedElement: IElementPosition,\r\n  hostElement: HTMLElement,\r\n  bounds?: Rectangle,\r\n  coverTarget?: boolean\r\n): IPositionedData {\r\n  const finalizedElement: IPartialIRectangle = _finalizeElementPosition(\r\n    positionedElement.elementRectangle,\r\n    hostElement,\r\n    positionedElement.targetEdge,\r\n    bounds,\r\n    positionedElement.alignmentEdge,\r\n    coverTarget\r\n  );\r\n  return {\r\n    elementPosition: finalizedElement,\r\n    targetEdge: positionedElement.targetEdge,\r\n    alignmentEdge: positionedElement.alignmentEdge\r\n  };\r\n}\r\n\r\nfunction _positionElement(\r\n  props: IPositionProps,\r\n  hostElement: HTMLElement,\r\n  elementToPosition: HTMLElement,\r\n  previousPositions?: IPositionedData\r\n): IPositionedData {\r\n  const boundingRect: Rectangle = props.bounds\r\n    ? _getRectangleFromIRect(props.bounds)\r\n    : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\r\n  const positionedElement: IElementPosition = _positionElementRelative(props, elementToPosition, boundingRect, previousPositions);\r\n  return _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget);\r\n}\r\n\r\nfunction _positionCallout(\r\n  props: ICalloutPositionProps,\r\n  hostElement: HTMLElement,\r\n  callout: HTMLElement,\r\n  previousPositions?: ICalloutPositionedInfo\r\n): ICalloutPositionedInfo {\r\n  const beakWidth: number = props.isBeakVisible ? props.beakWidth || 0 : 0;\r\n  const gap: number = _calculateActualBeakWidthInPixels(beakWidth) / 2 + (props.gapSpace ? props.gapSpace : 0);\r\n  const positionProps: IPositionProps = props;\r\n  positionProps.gapSpace = gap;\r\n  const boundingRect: Rectangle = props.bounds\r\n    ? _getRectangleFromIRect(props.bounds)\r\n    : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\r\n  const positionedElement: IElementPositionInfo = _positionElementRelative(positionProps, callout, boundingRect, previousPositions);\r\n  const beakPositioned: Rectangle = _positionBeak(beakWidth, positionedElement);\r\n  const finalizedBeakPosition: ICalloutBeakPositionedInfo = _finalizeBeakPosition(positionedElement, beakPositioned, boundingRect);\r\n  return {\r\n    ..._finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget),\r\n    beakPosition: finalizedBeakPosition\r\n  };\r\n}\r\n// END PRIVATE FUNCTIONS\r\n\r\n/* tslint:disable:variable-name */\r\nexport const __positioningTestPackage = {\r\n  _finalizePositionData,\r\n  _finalizeBeakPosition,\r\n  _calculateActualBeakWidthInPixels,\r\n  _positionElementWithinBounds,\r\n  _positionBeak,\r\n  _getPositionData,\r\n  _getMaxHeightFromTargetRectangle\r\n};\r\n/* tslint:enable:variable-name */\r\n\r\n/**\r\n * Used to position an element relative to the given positioning props.\r\n * If positioning has been completed before, previousPositioningData\r\n * can be passed to ensure that the positioning element repositions based on\r\n * its previous targets rather than starting with directionalhint.\r\n *\r\n * @export\r\n * @param {IPositionProps} props\r\n * @param {HTMLElement} hostElement\r\n * @param {HTMLElement} elementToPosition\r\n * @param {IPositionedData} previousPositions\r\n * @returns\r\n */\r\nexport function positionElement(\r\n  props: IPositionProps,\r\n  hostElement: HTMLElement,\r\n  elementToPosition: HTMLElement,\r\n  previousPositions?: IPositionedData\r\n): IPositionedData {\r\n  return _positionElement(props, hostElement, elementToPosition, previousPositions);\r\n}\r\n\r\nexport function positionCallout(\r\n  props: IPositionProps,\r\n  hostElement: HTMLElement,\r\n  elementToPosition: HTMLElement,\r\n  previousPositions?: ICalloutPositionedInfo\r\n): ICalloutPositionedInfo {\r\n  return _positionCallout(props, hostElement, elementToPosition, previousPositions);\r\n}\r\n\r\n/**\r\n * Get's the maximum height that a rectangle can have in order to fit below or above a target.\r\n * If the directional hint specifies a left or right edge (i.e. leftCenter) it will limit the height to the topBorder\r\n * of the target given.\r\n * If no bounds are provided then the window is treated as the bounds.\r\n */\r\nexport function getMaxHeight(\r\n  target: Element | MouseEvent | IPoint,\r\n  targetEdge: DirectionalHint,\r\n  gapSpace: number = 0,\r\n  bounds?: IRectangle,\r\n  coverTarget?: boolean\r\n): number {\r\n  const mouseTarget: MouseEvent = target as MouseEvent;\r\n  const elementTarget: Element = target as Element;\r\n  const pointTarget: IPoint = target as IPoint;\r\n  let targetRect: Rectangle;\r\n  const boundingRectangle = bounds\r\n    ? _getRectangleFromIRect(bounds)\r\n    : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);\r\n\r\n  if (mouseTarget.stopPropagation) {\r\n    targetRect = new Rectangle(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);\r\n  } else if (pointTarget.x !== undefined && pointTarget.y !== undefined) {\r\n    targetRect = new Rectangle(pointTarget.x, pointTarget.x, pointTarget.y, pointTarget.y);\r\n  } else {\r\n    targetRect = _getRectangleFromElement(elementTarget);\r\n  }\r\n\r\n  return _getMaxHeightFromTargetRectangle(targetRect, targetEdge, gapSpace, boundingRectangle, coverTarget);\r\n}\r\n\r\n/**\r\n * Returns the opposite edge of the given RectangleEdge.\r\n */\r\nexport function getOppositeEdge(edge: RectangleEdge): RectangleEdge {\r\n  return edge * -1;\r\n}\r\n"]}