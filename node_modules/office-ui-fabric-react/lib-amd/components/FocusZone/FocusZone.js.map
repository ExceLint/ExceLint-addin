{"version":3,"file":"FocusZone.js","sourceRoot":"../src/","sources":["components/FocusZone/FocusZone.tsx"],"names":[],"mappings":";;;IA0BA,IAAM,sBAAsB,GAAG,mBAAmB,CAAC;IACnD,IAAM,2BAA2B,GAAG,6BAA6B,CAAC;IAClE,IAAM,sBAAsB,GAAG,mBAAmB,CAAC;IACnD,IAAM,QAAQ,GAAG,UAAU,CAAC;IAC5B,IAAM,gBAAgB,GAAG,uBAAuB,CAAC;IACjD,IAAM,kBAAkB,GAAG,yBAAyB,CAAC;IACrD,IAAM,0BAA0B,GAAG,SAAS,CAAC;IAC7C,IAAM,mCAAmC,GAAG,CAAC,SAAS,CAAC;IAEvD,IAAM,aAAa,GAEf,EAAE,CAAC;IAMP,IAAM,mBAAmB,GAAG,CAAC,MAAM,EAAE,QAAQ,EAAE,UAAU,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;IAE5F,IAAM,sBAAsB,GAAG,KAAK,CAAC;IAErC;QAA+B,qCAAoC;QAiCjE,mBAAY,KAAsB;YAAlC,YACE,kBAAM,KAAK,CAAC,SAqBb;YAjDO,kBAAY,GAAe,EAAE,CAAC;YAC9B,WAAK,GAAG,KAAK,CAAC,SAAS,EAAe,CAAC;YA+NvC,cAAQ,GAAG,UAAC,EAAiC;gBAC7C,IAAA,gBAA6F,EAA3F,kDAAsB,EAAE,oEAA+B,EAAE,4CAAmB,CAAgB;gBACpG,IAAM,qBAAqB,GAAG,KAAI,CAAC,4BAA4B,CAAC,EAAE,CAAC,MAAqB,CAAC,CAAC;gBAC1F,IAAI,gBAAyC,CAAC;gBAE9C,IAAI,mBAAmB,EAAE;oBACvB,mBAAmB,EAAE,CAAC;iBACvB;gBAED,IAAI,qBAAqB,EAAE;oBACzB,gBAAgB,GAAG,EAAE,CAAC,MAAqB,CAAC;iBAC7C;qBAAM;oBACL,IAAI,aAAa,GAAG,EAAE,CAAC,MAAqB,CAAC;oBAE7C,OAAO,aAAa,IAAI,aAAa,KAAK,KAAI,CAAC,KAAK,CAAC,OAAO,EAAE;wBAC5D,IAAI,6BAAiB,CAAC,aAAa,CAAC,IAAI,KAAI,CAAC,4BAA4B,CAAC,aAAa,CAAC,EAAE;4BACxF,gBAAgB,GAAG,aAAa,CAAC;4BACjC,MAAM;yBACP;wBACD,aAAa,GAAG,qBAAS,CAAC,aAAa,EAAE,sBAAsB,CAAgB,CAAC;qBACjF;iBACF;gBAED,IAAI,gBAAgB,IAAI,gBAAgB,KAAK,KAAI,CAAC,cAAc,EAAE;oBAChE,KAAI,CAAC,cAAc,GAAG,gBAAgB,CAAC;oBAEvC,IAAI,qBAAqB,EAAE;wBACzB,KAAI,CAAC,kBAAkB,CAAC,KAAI,CAAC,cAAc,CAAC,CAAC;qBAC9C;iBACF;gBAED,IAAI,sBAAsB,EAAE;oBAC1B,sBAAsB,CAAC,KAAI,CAAC,cAA6B,EAAE,EAAE,CAAC,CAAC;iBAChE;gBAED,IAAI,+BAA+B,EAAE;oBACnC,EAAE,CAAC,eAAe,EAAE,CAAC;iBACtB;YACH,CAAC,CAAC;YAiCM,aAAO,GAAG;gBAChB,KAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;YAC9B,CAAC,CAAC;YAEF;;eAEG;YACK,uBAAiB,GAAG,UAAC,EAAiB;gBAC5C,IAAI,EAAE,CAAC,KAAK,KAAK,oBAAQ,CAAC,GAAG,EAAE;oBAC7B,KAAI,CAAC,iBAAiB,EAAE,CAAC;iBAC1B;YACH,CAAC,CAAC;YAEM,kBAAY,GAAG,UAAC,EAAiC;gBAC/C,IAAA,+BAAQ,CAAgB;gBAEhC,IAAI,QAAQ,EAAE;oBACZ,OAAO;iBACR;gBAED,IAAI,MAAM,GAAG,EAAE,CAAC,MAAqB,CAAC;gBACtC,IAAM,IAAI,GAAG,EAAE,CAAC;gBAEhB,OAAO,MAAM,IAAI,MAAM,KAAK,KAAI,CAAC,KAAK,CAAC,OAAO,EAAE;oBAC9C,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;oBAClB,MAAM,GAAG,qBAAS,CAAC,MAAM,EAAE,sBAAsB,CAAgB,CAAC;iBACnE;gBAED,OAAO,IAAI,CAAC,MAAM,EAAE;oBAClB,MAAM,GAAG,IAAI,CAAC,GAAG,EAAiB,CAAC;oBAEnC,IAAI,MAAM,IAAI,6BAAiB,CAAC,MAAM,CAAC,EAAE;wBACvC,KAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;qBACtC;oBAED,IAAI,8BAAkB,CAAC,MAAM,CAAC,EAAE;wBAC9B,qEAAqE;wBACrE,MAAM;qBACP;iBACF;YACH,CAAC,CAAC;YAwBF;;eAEG;YACK,gBAAU,GAAG,UAAC,EAAoC;gBAClD,IAAA,gBAA0D,EAAxD,wBAAS,EAAE,sBAAQ,EAAE,8CAAoB,CAAgB;gBAEjE,IAAI,QAAQ,EAAE;oBACZ,OAAO;iBACR;gBAED,IAAI,KAAI,CAAC,KAAK,CAAC,SAAS,EAAE;oBACxB,KAAI,CAAC,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;iBAC1B;gBAED,qEAAqE;gBACrE,IAAI,EAAE,CAAC,kBAAkB,EAAE,EAAE;oBAC3B,OAAO;iBACR;gBAED,IAAI,QAAQ,CAAC,aAAa,KAAK,KAAI,CAAC,KAAK,CAAC,OAAO,IAAI,KAAI,CAAC,YAAY,EAAE;oBACtE,iEAAiE;oBACjE,wBAAwB;oBACxB,OAAO;iBACR;gBAED,IAAI,oBAAoB,IAAI,oBAAoB,CAAC,EAAE,CAAC,IAAI,KAAI,CAAC,4BAA4B,CAAC,EAAE,CAAC,MAAqB,CAAC,EAAE;oBACnH,eAAe;oBACf,IAAM,SAAS,GAAG,KAAI,CAAC,kBAAkB,EAAE,CAAC;oBAE5C,IAAI,SAAS,EAAE;wBACb,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;4BAC1B,OAAO;yBACR;qBACF;yBAAM,IAAI,iCAAqB,CAAC,EAAE,CAAC,MAAqB,CAAC,EAAE;wBAC1D,IACE,CAAC,KAAI,CAAC,YAAY,CAAC,0BAAc,CAC/B,EAAE,CAAC,MAAqB,EACvB,EAAE,CAAC,MAAsB,CAAC,UAAyB,EACpD,IAAI,CACU,CAAC,EACjB;4BACA,OAAO;yBACR;qBACF;yBAAM;wBACL,OAAO;qBACR;iBACF;qBAAM,IAAI,EAAE,CAAC,MAAM,EAAE;oBACpB,OAAO;iBACR;qBAAM;oBACL,QAAQ,EAAE,CAAC,KAAK,EAAE;wBAChB,KAAK,oBAAQ,CAAC,KAAK;4BACjB,IAAI,KAAI,CAAC,2BAA2B,CAAC,EAAE,CAAC,MAAqB,CAAC,EAAE;gCAC9D,MAAM;6BACP;4BACD,OAAO;wBAET,KAAK,oBAAQ,CAAC,IAAI;4BAChB,IAAI,SAAS,KAAK,oCAAkB,CAAC,QAAQ,IAAI,KAAI,CAAC,cAAc,EAAE,EAAE;gCACtE,MAAM;6BACP;4BACD,OAAO;wBAET,KAAK,oBAAQ,CAAC,KAAK;4BACjB,IAAI,SAAS,KAAK,oCAAkB,CAAC,QAAQ,IAAI,KAAI,CAAC,eAAe,EAAE,EAAE;gCACvE,MAAM;6BACP;4BACD,OAAO;wBAET,KAAK,oBAAQ,CAAC,EAAE;4BACd,IAAI,SAAS,KAAK,oCAAkB,CAAC,UAAU,IAAI,KAAI,CAAC,YAAY,EAAE,EAAE;gCACtE,MAAM;6BACP;4BACD,OAAO;wBAET,KAAK,oBAAQ,CAAC,IAAI;4BAChB,IAAI,SAAS,KAAK,oCAAkB,CAAC,UAAU,IAAI,KAAI,CAAC,cAAc,EAAE,EAAE;gCACxE,MAAM;6BACP;4BACD,OAAO;wBAET,KAAK,oBAAQ,CAAC,GAAG;4BACf,IACE,KAAI,CAAC,KAAK,CAAC,WAAW;gCACtB,KAAI,CAAC,KAAK,CAAC,YAAY,KAAK,2CAAyB,CAAC,GAAG;gCACzD,CAAC,KAAI,CAAC,KAAK,CAAC,YAAY,KAAK,2CAAyB,CAAC,SAAS,IAAI,KAAI,CAAC,eAAe,CAAC,EAAE,CAAC,MAAqB,CAAC,CAAC,EACnH;gCACA,IAAI,YAAY,GAAG,KAAK,CAAC;gCACzB,KAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;gCAC9B,IACE,SAAS,KAAK,oCAAkB,CAAC,QAAQ;oCACzC,CAAC,KAAI,CAAC,gBAAgB,CAAC,KAAI,CAAC,cAA6B,EAAE,kBAAkB,CAAC,EAC9E;oCACA,YAAY,GAAG,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAI,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC,KAAI,CAAC,cAAc,EAAE,CAAC;iCAC1E;qCAAM,IAAI,SAAS,KAAK,oCAAkB,CAAC,UAAU,IAAI,SAAS,KAAK,oCAAkB,CAAC,aAAa,EAAE;oCACxG,IAAM,gBAAgB,GAAG,kBAAM,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,QAAQ,CAAC;oCAC/D,YAAY,GAAG,gBAAgB,CAAC,CAAC,CAAC,KAAI,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC,KAAI,CAAC,eAAe,EAAE,CAAC;iCAClF;gCACD,KAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;gCAC/B,IAAI,YAAY,EAAE;oCAChB,MAAM;iCACP;6BACF;4BACD,OAAO;wBAET,KAAK,oBAAQ,CAAC,IAAI;4BAChB,IAAI,KAAI,CAAC,eAAe,CAAC,EAAE,CAAC,MAAqB,CAAC,IAAI,CAAC,KAAI,CAAC,qBAAqB,CAAC,EAAE,CAAC,MAA0B,EAAE,KAAK,CAAC,EAAE;gCACvH,OAAO,KAAK,CAAC;6BACd;4BACD,IAAM,UAAU,GAAG,KAAI,CAAC,KAAK,CAAC,OAAO,IAAK,KAAI,CAAC,KAAK,CAAC,OAAO,CAAC,UAAiC,CAAC;4BAC/F,IAAI,KAAI,CAAC,KAAK,CAAC,OAAO,IAAI,UAAU,IAAI,KAAI,CAAC,YAAY,CAAC,0BAAc,CAAC,KAAI,CAAC,KAAK,CAAC,OAAO,EAAE,UAAU,EAAE,IAAI,CAAgB,CAAC,EAAE;gCAC9H,MAAM;6BACP;4BACD,OAAO;wBAET,KAAK,oBAAQ,CAAC,GAAG;4BACf,IAAI,KAAI,CAAC,eAAe,CAAC,EAAE,CAAC,MAAqB,CAAC,IAAI,CAAC,KAAI,CAAC,qBAAqB,CAAC,EAAE,CAAC,MAA0B,EAAE,IAAI,CAAC,EAAE;gCACtH,OAAO,KAAK,CAAC;6BACd;4BAED,IAAM,SAAS,GAAG,KAAI,CAAC,KAAK,CAAC,OAAO,IAAK,KAAI,CAAC,KAAK,CAAC,OAAO,CAAC,SAAgC,CAAC;4BAC7F,IAAI,KAAI,CAAC,KAAK,CAAC,OAAO,IAAI,KAAI,CAAC,YAAY,CAAC,8BAAkB,CAAC,KAAI,CAAC,KAAK,CAAC,OAAO,EAAE,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAgB,CAAC,EAAE;gCAC/H,MAAM;6BACP;4BACD,OAAO;wBAET,KAAK,oBAAQ,CAAC,KAAK;4BACjB,IAAI,KAAI,CAAC,2BAA2B,CAAC,EAAE,CAAC,MAAqB,CAAC,EAAE;gCAC9D,MAAM;6BACP;4BACD,OAAO;wBAET;4BACE,OAAO;qBACV;iBACF;gBAED,EAAE,CAAC,cAAc,EAAE,CAAC;gBACpB,EAAE,CAAC,eAAe,EAAE,CAAC;YACvB,CAAC,CAAC;YAndA,kCAAkC;YAClC,kCAAsB,CAAC,KAAI,CAAC,CAAC;YAE7B,IAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,YAAY,EAAE;gBACzC,4BAAgB,CAAC,WAAW,EAAE,KAAK,EAAE;oBACnC,SAAS,EAAE,SAAS;oBACpB,WAAW,EAAE,cAAc;oBAC3B,WAAW,EAAE,IAAI;iBAClB,CAAC,CAAC;aACJ;YAED,KAAI,CAAC,GAAG,GAAG,iBAAK,CAAC,WAAW,CAAC,CAAC;YAE9B,KAAI,CAAC,eAAe,GAAG;gBACrB,IAAI,EAAE,CAAC;gBACP,GAAG,EAAE,CAAC;aACP,CAAC;YAEF,KAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;;QACjC,CAAC;QAEM,qCAAiB,GAAxB;YACU,IAAA,yBAAa,CAAgB;YAErC,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;YAE/B,IAAI,IAAI,EAAE;gBACR,IAAM,aAAa,GAAG,IAAI,CAAC,aAAc,CAAC,WAAW,CAAC;gBAEtD,IAAI,aAAa,GAAG,qBAAS,CAAC,IAAI,EAAE,sBAAsB,CAAC,CAAC;gBAE5D,OAAO,aAAa,IAAI,aAAa,KAAK,QAAQ,CAAC,IAAI,IAAI,aAAa,CAAC,QAAQ,KAAK,CAAC,EAAE;oBACvF,IAAI,8BAAkB,CAAC,aAAa,CAAC,EAAE;wBACrC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;wBACzB,MAAM;qBACP;oBACD,aAAa,GAAG,qBAAS,CAAC,aAAa,EAAE,sBAAsB,CAAC,CAAC;iBAClE;gBAED,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;oBACtB,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,cAAE,CAAC,aAAa,EAAE,SAAS,EAAE,IAAI,CAAC,iBAAiB,EAAE,IAAI,CAAC,EAAE,cAAE,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC;iBAC1H;gBAED,8EAA8E;gBAC9E,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBAEzB,IAAI,IAAI,CAAC,KAAK,CAAC,oBAAoB,EAAE;oBACnC,IAAI,CAAC,cAAc,GAAG,uBAAW,EAAG,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAgB,CAAC;oBACnG,IAAI,CAAC,KAAK,EAAE,CAAC;iBACd;aACF;QACH,CAAC;QAEM,sCAAkB,GAAzB;YACU,IAAA,yBAAa,CAAgB;YACrC,IAAM,GAAG,GAAG,uBAAW,CAAC,IAAI,CAAC,CAAC;YAE9B,IAAI,GAAG,IAAI,IAAI,CAAC,cAAc,IAAI,CAAC,GAAG,CAAC,aAAa,KAAK,GAAG,CAAC,IAAI,IAAI,GAAG,CAAC,aAAa,KAAK,IAAI,CAAC,EAAE;gBAChG,2EAA2E;gBAC3E,IAAM,cAAc,GAAG,mCAAuB,CAAC,IAAmB,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;gBAEzF,IAAI,cAAc,EAAE;oBAClB,IAAI,CAAC,iBAAiB,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;oBAC7C,cAAc,CAAC,KAAK,EAAE,CAAC;oBACvB,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;iBAC7B;qBAAM;oBACL,gFAAgF;oBAChF,2CAA2C;oBAC3C,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;iBAC5B;aACF;QACH,CAAC;QAEM,wCAAoB,GAA3B;YACE,OAAO,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YAE/B,sBAAsB;YACtB,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,EAAE,EAAH,CAAG,CAAC,CAAC;QACtC,CAAC;QAEM,0BAAM,GAAb;YACQ,IAAA,eAAsE,EAApE,wBAAS,EAAE,oCAAe,EAAE,kCAAc,EAAE,wBAAS,CAAgB;YAC7E,IAAM,QAAQ,GAAG,0BAAc,CAAC,IAAI,CAAC,KAAK,EAAE,iCAAqB,CAAC,CAAC;YAEnE,IAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,IAAI,KAAK,CAAC;YAE7D,gFAAgF;YAChF,+EAA+E;YAC/E,gFAAgF;YAChF,iFAAiF;YACjF,oCAAoC;YACpC,IAAI,CAAC,0BAA0B,EAAE,CAAC;YAElC,OAAO,CACL,oBAAC,GAAG,qBACF,IAAI,EAAC,cAAc,IACf,QAAQ,EAKP,SAAgB,IAErB,SAAS,EAAE,eAAG,CAAC,cAAc,EAAE,SAAS,CAAC,EACzC,GAAG,EAAE,IAAI,CAAC,KAAK,uBACI,IAAI,CAAC,GAAG,qBACV,cAAc,sBACb,eAAe,EACjC,SAAS,EAAE,IAAI,CAAC,UAAU,EAC1B,OAAO,EAAE,IAAI,CAAC,QAAQ,EACtB,kBAAkB,EAAE,IAAI,CAAC,YAAY,KAEpC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAChB,CACP,CAAC;QACJ,CAAC;QAED;;;;;WAKG;QACI,yBAAK,GAAZ,UAAa,qBAAsC;YAAtC,sCAAA,EAAA,6BAAsC;YACjD,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;gBACtB,IAAI,CAAC,qBAAqB,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,sBAAsB,CAAC,KAAK,MAAM,IAAI,IAAI,CAAC,YAAY,EAAE;oBACrH,IAAM,gBAAgB,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAgB,CAAC;oBAE/E,IAAI,gBAAgB,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;wBAC3C,IAAM,SAAS,GAAG,aAAa,CAAC,gBAAgB,CAAC,YAAY,CAAC,sBAAsB,CAAW,CAAC,CAAC;wBAEjG,OAAO,CAAC,CAAC,SAAS,IAAI,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;qBAClE;oBAED,OAAO,KAAK,CAAC;iBACd;qBAAM,IACL,CAAC,qBAAqB;oBACtB,IAAI,CAAC,cAAc;oBACnB,2BAAe,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,cAAc,CAAC;oBACxD,6BAAiB,CAAC,IAAI,CAAC,cAAc,CAAC,EACtC;oBACA,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC;oBAC5B,OAAO,IAAI,CAAC;iBACb;qBAAM;oBACL,IAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,UAAyB,CAAC;oBAEhE,OAAO,IAAI,CAAC,YAAY,CAAC,0BAAc,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,UAAU,EAAE,IAAI,CAAgB,CAAC,CAAC;iBAC/F;aACF;YACD,OAAO,KAAK,CAAC;QACf,CAAC;QAED;;;;;;WAMG;QACI,gCAAY,GAAnB,UAAoB,OAAoB;YAC9B,IAAA,wCAAa,CAAgB;YAErC,IAAI,aAAa,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,EAAE;gBAC5C,OAAO,KAAK,CAAC;aACd;YAED,IAAI,OAAO,EAAE;gBACX,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;gBAChC,IAAI,IAAI,CAAC,cAAc,EAAE;oBACvB,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC;iBAC7B;gBAED,OAAO,IAAI,CAAC;aACb;YAED,OAAO,KAAK,CAAC;QACf,CAAC;QAEO,8CAA0B,GAAlC;YACU,IAAA,yBAAa,CAAgB;YACrC,IAAM,GAAG,GAAG,uBAAW,CAAC,IAAI,CAAC,CAAC;YAE9B,IAAI,GAAG,EAAE;gBACP,IAAM,cAAc,GAAG,GAAG,CAAC,aAA4B,CAAC;gBAExD,+DAA+D;gBAC/D,IAAI,cAAc,KAAK,IAAI,EAAE;oBAC3B,IAAM,kBAAkB,GAAG,2BAAe,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;oBAEjE,IAAI,CAAC,cAAc,GAAG,kBAAkB,CAAC,CAAC,CAAC,+BAAmB,CAAC,IAAmB,EAAE,GAAG,CAAC,aAA4B,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;iBACnI;aACF;QACH,CAAC;QA0CD;;;;;WAKG;QACK,mCAAe,GAAvB,UAAwB,QAAiB;YAC/B,IAAA,yBAAa,CAAgB;YAErC,IAAI,IAAI,IAAI,IAAI,CAAC,SAAS,KAAK,QAAQ,EAAE;gBACvC,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;gBAE1B,IAAI,QAAQ,EAAE;oBACZ,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE;wBAC9B,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;wBACrD,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;qBACrC;oBACD,IAAI,CAAC,KAAK,EAAE,CAAC;iBACd;qBAAM;oBACL,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE;wBAC9B,IAAI,IAAI,CAAC,eAAe,EAAE;4BACxB,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;4BACpD,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;yBAClC;6BAAM;4BACL,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,CAAC;yBAClC;qBACF;iBACF;aACF;QACH,CAAC;QA4CO,qCAAiB,GAAzB,UAA0B,OAAoB,EAAE,cAAwB;YACtE,IAAM,qBAAqB,GAAG,IAAI,CAAC,cAAc,CAAC;YAElD,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC;YAE9B,IAAI,qBAAqB,EAAE;gBACzB,IAAI,8BAAkB,CAAC,qBAAqB,CAAC,EAAE;oBAC7C,IAAI,CAAC,iBAAiB,CAAC,qBAAqB,CAAC,CAAC;iBAC/C;gBAED,qBAAqB,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC;aACrC;YAED,IAAI,IAAI,CAAC,cAAc,EAAE;gBACvB,IAAI,CAAC,IAAI,CAAC,eAAe,IAAI,cAAc,EAAE;oBAC3C,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;iBAC9C;gBAED,IAAI,CAAC,cAAc,CAAC,QAAQ,GAAG,CAAC,CAAC;aAClC;QACH,CAAC;QA8ID;;WAEG;QACK,+CAA2B,GAAnC,UAAoC,MAAmB;YACrD,IAAI,MAAM,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;gBACjC,OAAO,KAAK,CAAC;aACd;YAED,GAAG;gBACD,IAAI,MAAM,CAAC,OAAO,KAAK,QAAQ,IAAI,MAAM,CAAC,OAAO,KAAK,GAAG,IAAI,MAAM,CAAC,OAAO,KAAK,OAAO,IAAI,MAAM,CAAC,OAAO,KAAK,UAAU,EAAE;oBACxH,OAAO,KAAK,CAAC;iBACd;gBAED,IACE,IAAI,CAAC,4BAA4B,CAAC,MAAM,CAAC;oBACzC,MAAM,CAAC,YAAY,CAAC,sBAAsB,CAAC,KAAK,MAAM;oBACtD,MAAM,CAAC,YAAY,CAAC,2BAA2B,CAAC,KAAK,MAAM,EAC3D;oBACA,sBAAU,CAAC,MAAM,CAAC,CAAC;oBACnB,OAAO,IAAI,CAAC;iBACb;gBAED,MAAM,GAAG,qBAAS,CAAC,MAAM,EAAE,sBAAsB,CAAgB,CAAC;aACnE,QAAQ,MAAM,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;YAExC,OAAO,KAAK,CAAC;QACf,CAAC;QAED;;WAEG;QACK,sCAAkB,GAA1B,UAA2B,WAAgC;YACzD,WAAW,GAAG,WAAW,IAAI,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC;YAEvE,IAAI,CAAC,WAAW,EAAE;gBAChB,OAAO,IAAI,CAAC;aACb;YAED,IAAI,8BAAkB,CAAC,WAAW,CAAC,EAAE;gBACnC,OAAO,aAAa,CAAC,WAAW,CAAC,YAAY,CAAC,sBAAsB,CAAW,CAAC,CAAC;aAClF;YAED,IAAI,KAAK,GAAG,WAAW,CAAC,iBAAuC,CAAC;YAEhE,OAAO,KAAK,EAAE;gBACZ,IAAI,8BAAkB,CAAC,KAAK,CAAC,EAAE;oBAC7B,OAAO,aAAa,CAAC,KAAK,CAAC,YAAY,CAAC,sBAAsB,CAAW,CAAC,CAAC;iBAC5E;gBACD,IAAM,KAAK,GAAG,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;gBAE7C,IAAI,KAAK,EAAE;oBACT,OAAO,KAAK,CAAC;iBACd;gBAED,KAAK,GAAG,KAAK,CAAC,kBAAwC,CAAC;aACxD;YAED,OAAO,IAAI,CAAC;QACd,CAAC;QAEO,8BAAU,GAAlB,UACE,SAAkB,EAClB,qBAAiF,EACjF,EAAU,EACV,cAA8B;YAA9B,+BAAA,EAAA,qBAA8B;YAE9B,IAAI,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC;YAClC,IAAI,iBAAiB,GAAG,CAAC,CAAC,CAAC;YAC3B,IAAI,gBAAgB,GAA4B,SAAS,CAAC;YAC1D,IAAI,YAAY,GAAG,KAAK,CAAC;YACzB,IAAM,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,KAAK,oCAAkB,CAAC,aAAa,CAAC;YAElF,IAAI,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;gBACnC,OAAO,KAAK,CAAC;aACd;YAED,IAAI,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,EAAE;gBACjC,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC,OAA2B,EAAE,SAAS,CAAC,EAAE;oBACvE,OAAO,KAAK,CAAC;iBACd;aACF;YAED,IAAM,UAAU,GAAG,eAAe,CAAC,CAAC,CAAC,OAAO,CAAC,qBAAqB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;YAE5E,GAAG;gBACD,OAAO,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,0BAAc,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,8BAAkB,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,OAAO,CAAC,CAAgB,CAAC;gBAErI,IAAI,eAAe,EAAE;oBACnB,IAAI,OAAO,EAAE;wBACX,IAAM,UAAU,GAAG,OAAO,CAAC,qBAAqB,EAAE,CAAC;wBACnD,IAAM,eAAe,GAAG,qBAAqB,CAAC,UAAwB,EAAE,UAAU,CAAC,CAAC;wBAEpF,IAAI,eAAe,KAAK,CAAC,CAAC,IAAI,iBAAiB,KAAK,CAAC,CAAC,EAAE;4BACtD,gBAAgB,GAAG,OAAO,CAAC;4BAC3B,MAAM;yBACP;wBAED,IAAI,eAAe,GAAG,CAAC,CAAC,IAAI,CAAC,iBAAiB,KAAK,CAAC,CAAC,IAAI,eAAe,GAAG,iBAAiB,CAAC,EAAE;4BAC7F,iBAAiB,GAAG,eAAe,CAAC;4BACpC,gBAAgB,GAAG,OAAO,CAAC;yBAC5B;wBAED,IAAI,iBAAiB,IAAI,CAAC,IAAI,eAAe,GAAG,CAAC,EAAE;4BACjD,MAAM;yBACP;qBACF;iBACF;qBAAM;oBACL,gBAAgB,GAAG,OAAO,CAAC;oBAC3B,MAAM;iBACP;aACF,QAAQ,OAAO,EAAE;YAElB,8BAA8B;YAC9B,IAAI,gBAAgB,IAAI,gBAAgB,KAAK,IAAI,CAAC,cAAc,EAAE;gBAChE,YAAY,GAAG,IAAI,CAAC;gBACpB,IAAI,CAAC,YAAY,CAAC,gBAAgB,CAAC,CAAC;aACrC;iBAAM,IAAI,IAAI,CAAC,KAAK,CAAC,oBAAoB,IAAI,cAAc,EAAE;gBAC5D,IAAI,SAAS,EAAE;oBACb,OAAO,IAAI,CAAC,YAAY,CAAC,0BAAc,CACrC,IAAI,CAAC,KAAK,CAAC,OAAO,EAClB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,iBAAgC,EACnD,IAAI,CACU,CAAC,CAAC;iBACnB;qBAAM;oBACL,OAAO,IAAI,CAAC,YAAY,CAAC,8BAAkB,CACzC,IAAI,CAAC,KAAK,CAAC,OAAO,EAClB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,gBAA+B,EAClD,IAAI,EACJ,IAAI,EACJ,IAAI,CACU,CAAC,CAAC;iBACnB;aACF;YAED,OAAO,YAAY,CAAC;QACtB,CAAC;QAEO,kCAAc,GAAtB;YAAA,iBAuCC;YAtCC,IAAI,SAAS,GAAG,CAAC,CAAC,CAAC;YACnB,IAAM,aAAa,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC;YAEhD,IACE,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,UAAC,UAAsB,EAAE,UAAsB;gBACnE,IAAI,QAAQ,GAAG,CAAC,CAAC,CAAC;gBAClB,oFAAoF;gBACpF,mFAAmF;gBACnF,iGAAiG;gBACjG,2DAA2D;gBAC3D,IAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;gBACjD,IAAM,gBAAgB,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;gBAEvD,IAAI,aAAa,GAAG,gBAAgB,EAAE;oBACpC,IAAI,CAAC,KAAI,CAAC,gBAAgB,CAAC,KAAI,CAAC,cAA6B,EAAE,gBAAgB,CAAC,EAAE;wBAChF,OAAO,mCAAmC,CAAC;qBAC5C;oBAED,OAAO,0BAA0B,CAAC;iBACnC;gBAED,IAAI,CAAC,SAAS,KAAK,CAAC,CAAC,IAAI,aAAa,IAAI,gBAAgB,CAAC,IAAI,aAAa,KAAK,SAAS,EAAE;oBAC1F,SAAS,GAAG,aAAa,CAAC;oBAC1B,IAAI,aAAa,IAAI,UAAU,CAAC,IAAI,IAAI,aAAa,IAAI,UAAU,CAAC,IAAI,GAAG,UAAU,CAAC,KAAK,EAAE;wBAC3F,QAAQ,GAAG,CAAC,CAAC;qBACd;yBAAM;wBACL,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,GAAG,UAAU,CAAC,KAAK,GAAG,CAAC,GAAG,aAAa,CAAC,CAAC;qBAC7E;iBACF;gBAED,OAAO,QAAQ,CAAC;YAClB,CAAC,CAAC,EACF;gBACA,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,cAA6B,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;gBACzE,OAAO,IAAI,CAAC;aACb;YAED,OAAO,KAAK,CAAC;QACf,CAAC;QAEO,gCAAY,GAApB;YAAA,iBAuCC;YAtCC,IAAI,SAAS,GAAG,CAAC,CAAC,CAAC;YACnB,IAAM,aAAa,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC;YAEhD,IACE,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,UAAC,UAAsB,EAAE,UAAsB;gBACpE,IAAI,QAAQ,GAAG,CAAC,CAAC,CAAC;gBAClB,oFAAoF;gBACpF,mFAAmF;gBACnF,iGAAiG;gBACjG,2DAA2D;gBAC3D,IAAM,gBAAgB,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;gBACvD,IAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;gBACjD,IAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;gBAEjD,IAAI,gBAAgB,GAAG,aAAa,EAAE;oBACpC,IAAI,CAAC,KAAI,CAAC,gBAAgB,CAAC,KAAI,CAAC,cAA6B,EAAE,gBAAgB,CAAC,EAAE;wBAChF,OAAO,mCAAmC,CAAC;qBAC5C;oBACD,OAAO,0BAA0B,CAAC;iBACnC;gBAED,IAAI,CAAC,SAAS,KAAK,CAAC,CAAC,IAAI,gBAAgB,IAAI,aAAa,CAAC,IAAI,aAAa,KAAK,SAAS,EAAE;oBAC1F,SAAS,GAAG,aAAa,CAAC;oBAC1B,IAAI,aAAa,IAAI,UAAU,CAAC,IAAI,IAAI,aAAa,IAAI,UAAU,CAAC,IAAI,GAAG,UAAU,CAAC,KAAK,EAAE;wBAC3F,QAAQ,GAAG,CAAC,CAAC;qBACd;yBAAM;wBACL,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,GAAG,UAAU,CAAC,KAAK,GAAG,CAAC,GAAG,aAAa,CAAC,CAAC;qBAC7E;iBACF;gBAED,OAAO,QAAQ,CAAC;YAClB,CAAC,CAAC,EACF;gBACA,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,cAA6B,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;gBACzE,OAAO,IAAI,CAAC;aACb;YAED,OAAO,KAAK,CAAC;QACf,CAAC;QAEO,kCAAc,GAAtB;YAAA,iBAsCC;YArCC,IAAM,UAAU,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,cAA6B,EAAE,kBAAkB,CAAC,CAAC;YACjG,IACE,IAAI,CAAC,UAAU,CACb,kBAAM,EAAE,EACR,UAAC,UAAsB,EAAE,UAAsB;gBAC7C,IAAI,QAAQ,GAAG,CAAC,CAAC,CAAC;gBAClB,IAAI,mBAAmB,CAAC;gBAExB,IAAI,kBAAM,EAAE,EAAE;oBACZ,yFAAyF;oBACzF,2FAA2F;oBAC3F,gFAAgF;oBAChF,sCAAsC;oBACtC,mBAAmB,GAAG,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;iBAChF;qBAAM;oBACL,mBAAmB,GAAG,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;iBAChF;gBAED,IAAI,mBAAmB,IAAI,UAAU,CAAC,KAAK,IAAI,UAAU,CAAC,KAAK,IAAI,KAAI,CAAC,KAAK,CAAC,SAAS,KAAK,oCAAkB,CAAC,QAAQ,EAAE;oBACvH,QAAQ,GAAG,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC;iBAChD;qBAAM;oBACL,IAAI,CAAC,UAAU,EAAE;wBACf,QAAQ,GAAG,mCAAmC,CAAC;qBAChD;iBACF;gBAED,OAAO,QAAQ,CAAC;YAClB,CAAC,EACD,SAAS,CAAC,MAAM,EAChB,UAAU,CACX,EACD;gBACA,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,cAA6B,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;gBACzE,OAAO,IAAI,CAAC;aACb;YAED,OAAO,KAAK,CAAC;QACf,CAAC;QAEO,mCAAe,GAAvB;YAAA,iBAoCC;YAnCC,IAAM,UAAU,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,cAA6B,EAAE,kBAAkB,CAAC,CAAC;YACjG,IACE,IAAI,CAAC,UAAU,CACb,CAAC,kBAAM,EAAE,EACT,UAAC,UAAsB,EAAE,UAAsB;gBAC7C,IAAI,QAAQ,GAAG,CAAC,CAAC,CAAC;gBAClB,IAAI,mBAAmB,CAAC;gBAExB,IAAI,kBAAM,EAAE,EAAE;oBACZ,wFAAwF;oBACxF,6FAA6F;oBAC7F,mFAAmF;oBACnF,mCAAmC;oBACnC,mBAAmB,GAAG,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;iBAChF;qBAAM;oBACL,mBAAmB,GAAG,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;iBAChF;gBAED,IAAI,mBAAmB,IAAI,UAAU,CAAC,IAAI,IAAI,UAAU,CAAC,IAAI,IAAI,KAAI,CAAC,KAAK,CAAC,SAAS,KAAK,oCAAkB,CAAC,QAAQ,EAAE;oBACrH,QAAQ,GAAG,UAAU,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC;iBAC9C;qBAAM,IAAI,CAAC,UAAU,EAAE;oBACtB,QAAQ,GAAG,mCAAmC,CAAC;iBAChD;gBAED,OAAO,QAAQ,CAAC;YAClB,CAAC,EACD,SAAS,CAAC,MAAM,EAChB,UAAU,CACX,EACD;gBACA,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,cAA6B,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;gBACzE,OAAO,IAAI,CAAC;aACb;YAED,OAAO,KAAK,CAAC;QACf,CAAC;QAEO,sCAAkB,GAA1B,UAA2B,OAAoB,EAAE,YAAsB,EAAE,UAAoB;YAC3F,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,KAAK,oCAAkB,CAAC,aAAa,IAAI,CAAC,CAAC,IAAI,CAAC,eAAe,IAAI,YAAY,IAAI,UAAU,CAAC,EAAE;gBACtH,IAAM,IAAI,GAAG,OAAO,CAAC,qBAAqB,EAAE,CAAC;gBAC7C,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;gBACxC,IAAM,KAAG,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;gBAEvC,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;oBACzB,IAAI,CAAC,eAAe,GAAG,EAAE,IAAI,MAAA,EAAE,GAAG,OAAA,EAAE,CAAC;iBACtC;gBAED,IAAI,YAAY,EAAE;oBAChB,IAAI,CAAC,eAAe,CAAC,IAAI,GAAG,IAAI,CAAC;iBAClC;gBAED,IAAI,UAAU,EAAE;oBACd,IAAI,CAAC,eAAe,CAAC,GAAG,GAAG,KAAG,CAAC;iBAChC;aACF;QACH,CAAC;QAEO,gDAA4B,GAApC,UAAqC,OAAqB;YACxD,OAAO,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC;QAC5D,CAAC;QAEO,iCAAa,GAArB,UAAsB,OAAqB;YACzC,IAAI,aAAa,GAAG,qBAAS,CAAC,OAAsB,EAAE,sBAAsB,CAAC,CAAC;YAE9E,OAAO,aAAa,IAAI,aAAa,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,IAAI,aAAa,KAAK,QAAQ,CAAC,IAAI,EAAE;gBAC/F,IAAI,8BAAkB,CAAC,aAAa,CAAC,EAAE;oBACrC,OAAO,aAAa,CAAC;iBACtB;gBAED,aAAa,GAAG,qBAAS,CAAC,aAAa,EAAE,sBAAsB,CAAC,CAAC;aAClE;YAED,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC;QAC5B,CAAC;QAEO,qCAAiB,GAAzB,UAA0B,OAAqB;YAC7C,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;gBAClC,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC;gBACjC,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC;gBAC7B,IAAI,IAAI,CAAC,cAAc,IAAI,CAAC,2BAAe,CAAC,OAAO,EAAE,IAAI,CAAC,cAAc,CAAC,EAAE;oBACzE,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;iBAC5B;aACF;YAED,+DAA+D;YAC/D,6EAA6E;YAC7E,IAAI,IAAI,CAAC,cAAc,IAAI,CAAC,6BAAiB,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE;gBAClE,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;aAC5B;YAED,IAAM,UAAU,GAAG,OAAO,IAAI,OAAO,CAAC,QAAQ,CAAC;YAE/C,KAAK,IAAI,UAAU,GAAG,CAAC,EAAE,UAAU,IAAI,UAAU,GAAG,UAAU,CAAC,MAAM,EAAE,UAAU,EAAE,EAAE;gBACnF,IAAM,KAAK,GAAG,UAAU,CAAC,UAAU,CAAgB,CAAC;gBAEpD,IAAI,CAAC,8BAAkB,CAAC,KAAK,CAAC,EAAE;oBAC9B,yFAAyF;oBACzF,IAAI,KAAK,CAAC,YAAY,IAAI,KAAK,CAAC,YAAY,CAAC,sBAAsB,CAAC,KAAK,OAAO,EAAE;wBAChF,KAAK,CAAC,YAAY,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;qBACpC;oBAED,IAAI,6BAAiB,CAAC,KAAK,CAAC,EAAE;wBAC5B,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;4BACvB,KAAK,CAAC,YAAY,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;yBACpC;6BAAM,IAAI,CAAC,IAAI,CAAC,YAAY,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,IAAI,IAAI,CAAC,cAAc,KAAK,KAAK,CAAC,EAAE;4BACxH,IAAI,CAAC,oBAAoB,GAAG,KAAK,CAAC;4BAClC,IAAI,KAAK,CAAC,YAAY,CAAC,QAAQ,CAAC,KAAK,GAAG,EAAE;gCACxC,KAAK,CAAC,YAAY,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;6BACnC;yBACF;6BAAM,IAAI,KAAK,CAAC,YAAY,CAAC,QAAQ,CAAC,KAAK,IAAI,EAAE;4BAChD,KAAK,CAAC,YAAY,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;yBACpC;qBACF;yBAAM,IAAI,KAAK,CAAC,OAAO,KAAK,KAAK,IAAI,KAAK,CAAC,YAAY,CAAC,WAAW,CAAC,KAAK,OAAO,EAAE;wBACjF,gCAAgC;wBAChC,KAAK,CAAC,YAAY,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;qBAC1C;iBACF;qBAAM,IAAI,KAAK,CAAC,YAAY,CAAC,sBAAsB,CAAC,KAAK,MAAM,EAAE;oBAChE,IAAI,CAAC,IAAI,CAAC,YAAY,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,IAAI,IAAI,CAAC,cAAc,KAAK,KAAK,CAAC,EAAE;wBACjH,IAAI,CAAC,oBAAoB,GAAG,KAAK,CAAC;wBAClC,IAAI,KAAK,CAAC,YAAY,CAAC,QAAQ,CAAC,KAAK,GAAG,EAAE;4BACxC,KAAK,CAAC,YAAY,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;yBACnC;qBACF;yBAAM,IAAI,KAAK,CAAC,YAAY,CAAC,QAAQ,CAAC,KAAK,IAAI,EAAE;wBAChD,KAAK,CAAC,YAAY,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;qBACpC;iBACF;gBAED,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;aAC/B;QACH,CAAC;QAEO,mCAAe,GAAvB,UAAwB,OAAoB;YAC1C,IAAI,OAAO,IAAI,OAAO,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW,EAAE,KAAK,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,WAAW,EAAE,KAAK,UAAU,CAAC,EAAE;gBAC7H,OAAO,IAAI,CAAC;aACb;YACD,OAAO,KAAK,CAAC;QACf,CAAC;QAEO,yCAAqB,GAA7B,UAA8B,OAAyB,EAAE,SAAmB;YAC1E,2DAA2D;YAC3D,IAAI,CAAC,IAAI,CAAC,iBAAiB,IAAI,OAAO,IAAI,OAAO,CAAC,IAAI,IAAI,mBAAmB,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;gBACtH,IAAM,cAAc,GAAG,OAAO,CAAC,cAAc,CAAC;gBAC9C,IAAM,YAAY,GAAG,OAAO,CAAC,YAAY,CAAC;gBAC1C,IAAM,eAAe,GAAG,cAAc,KAAK,YAAY,CAAC;gBACxD,IAAM,UAAU,GAAG,OAAO,CAAC,KAAK,CAAC;gBAEjC,kDAAkD;gBAClD,8BAA8B;gBAC9B,+DAA+D;gBAC/D,sEAAsE;gBACtE,oHAAoH;gBACpH,kIAAkI;gBAClI,0CAA0C;gBAC1C,IACE,eAAe;oBACf,CAAC,cAAe,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC;oBACnC,CAAC,cAAc,KAAK,UAAU,CAAC,MAAM,IAAI,SAAS,CAAC;oBACnD,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,YAAY,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,8BAA8B,IAAI,IAAI,CAAC,KAAK,CAAC,8BAA8B,CAAC,OAAO,CAAC,CAAC,CAAC,EACjI;oBACA,OAAO,KAAK,CAAC;iBACd;aACF;YAED,OAAO,IAAI,CAAC;QACd,CAAC;QAEO,oCAAgB,GAAxB,UAAyB,OAAoB,EAAE,mBAAwE;YACrH,OAAO,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,2BAAe,CAAC,OAAO,EAAE,mBAAmB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAC5F,CAAC;QAp6Ba,sBAAY,GAAoB;YAC5C,oBAAoB,EAAE,KAAK;YAC3B,SAAS,EAAE,oCAAkB,CAAC,aAAa;SAC5C,CAAC;QAk6BJ,gBAAC;KAAA,AAt6BD,CAA+B,KAAK,CAAC,SAAS,GAs6B7C;IAt6BY,8BAAS","sourcesContent":["import * as React from 'react';\r\nimport { FocusZoneDirection, FocusZoneTabbableElements, IFocusZone, IFocusZoneProps } from './FocusZone.types';\r\nimport {\r\n  KeyCodes,\r\n  css,\r\n  elementContains,\r\n  getDocument,\r\n  getElementIndexPath,\r\n  getFocusableByIndexPath,\r\n  getId,\r\n  getNativeProps,\r\n  getNextElement,\r\n  getParent,\r\n  getPreviousElement,\r\n  getRTL,\r\n  htmlElementProperties,\r\n  initializeComponentRef,\r\n  isElementFocusSubZone,\r\n  isElementFocusZone,\r\n  isElementTabbable,\r\n  on,\r\n  raiseClick,\r\n  shouldWrapFocus,\r\n  warnDeprecations\r\n} from '../../Utilities';\r\n\r\nconst IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\r\nconst IS_ENTER_DISABLED_ATTRIBUTE = 'data-disable-click-on-enter';\r\nconst FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\r\nconst TABINDEX = 'tabindex';\r\nconst NO_VERTICAL_WRAP = 'data-no-vertical-wrap';\r\nconst NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';\r\nconst LARGE_DISTANCE_FROM_CENTER = 999999999;\r\nconst LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;\r\n\r\nconst _allInstances: {\r\n  [key: string]: FocusZone;\r\n} = {};\r\n\r\ninterface IPoint {\r\n  left: number;\r\n  top: number;\r\n}\r\nconst ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search'];\r\n\r\nconst ALLOW_VIRTUAL_ELEMENTS = false;\r\n\r\nexport class FocusZone extends React.Component<IFocusZoneProps, {}> implements IFocusZone {\r\n  public static defaultProps: IFocusZoneProps = {\r\n    isCircularNavigation: false,\r\n    direction: FocusZoneDirection.bidirectional\r\n  };\r\n\r\n  private _disposables: Function[] = [];\r\n  private _root = React.createRef<HTMLElement>();\r\n  private _id: string;\r\n\r\n  /** The most recently focused child element. */\r\n  private _activeElement: HTMLElement | null;\r\n\r\n  /**\r\n   * The index path to the last focused child element.\r\n   */\r\n  private _lastIndexPath: number[] | undefined;\r\n\r\n  /**\r\n   * Flag to define when we've intentionally parked focus on the root element to temporarily\r\n   * hold focus until items appear within the zone.\r\n   */\r\n  private _isParked: boolean;\r\n\r\n  /** The child element with tabindex=0. */\r\n  private _defaultFocusElement: HTMLElement | null;\r\n  private _focusAlignment: IPoint;\r\n  private _isInnerZone: boolean;\r\n  private _parkedTabIndex: string | null | undefined;\r\n\r\n  /** Used to allow us to move to next focusable element even when we're focusing on a input element when pressing tab */\r\n  private _processingTabKey: boolean;\r\n\r\n  constructor(props: IFocusZoneProps) {\r\n    super(props);\r\n\r\n    // Manage componentRef resolution.\r\n    initializeComponentRef(this);\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      warnDeprecations('FocusZone', props, {\r\n        rootProps: undefined,\r\n        allowTabKey: 'handleTabKey',\r\n        elementType: 'as'\r\n      });\r\n    }\r\n\r\n    this._id = getId('FocusZone');\r\n\r\n    this._focusAlignment = {\r\n      left: 0,\r\n      top: 0\r\n    };\r\n\r\n    this._processingTabKey = false;\r\n  }\r\n\r\n  public componentDidMount(): void {\r\n    const { current: root } = this._root;\r\n\r\n    _allInstances[this._id] = this;\r\n\r\n    if (root) {\r\n      const windowElement = root.ownerDocument!.defaultView;\r\n\r\n      let parentElement = getParent(root, ALLOW_VIRTUAL_ELEMENTS);\r\n\r\n      while (parentElement && parentElement !== document.body && parentElement.nodeType === 1) {\r\n        if (isElementFocusZone(parentElement)) {\r\n          this._isInnerZone = true;\r\n          break;\r\n        }\r\n        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\r\n      }\r\n\r\n      if (!this._isInnerZone) {\r\n        this._disposables.push(on(windowElement, 'keydown', this._onKeyDownCapture, true), on(root, 'blur', this._onBlur, true));\r\n      }\r\n\r\n      // Assign initial tab indexes so that we can set initial focus as appropriate.\r\n      this._updateTabIndexes();\r\n\r\n      if (this.props.defaultActiveElement) {\r\n        this._activeElement = getDocument()!.querySelector(this.props.defaultActiveElement) as HTMLElement;\r\n        this.focus();\r\n      }\r\n    }\r\n  }\r\n\r\n  public componentDidUpdate(): void {\r\n    const { current: root } = this._root;\r\n    const doc = getDocument(root);\r\n\r\n    if (doc && this._lastIndexPath && (doc.activeElement === doc.body || doc.activeElement === root)) {\r\n      // The element has been removed after the render, attempt to restore focus.\r\n      const elementToFocus = getFocusableByIndexPath(root as HTMLElement, this._lastIndexPath);\r\n\r\n      if (elementToFocus) {\r\n        this._setActiveElement(elementToFocus, true);\r\n        elementToFocus.focus();\r\n        this._setParkedFocus(false);\r\n      } else {\r\n        // We had a focus path to restore, but now that path is unresolvable. Park focus\r\n        // on the container until we can try again.\r\n        this._setParkedFocus(true);\r\n      }\r\n    }\r\n  }\r\n\r\n  public componentWillUnmount() {\r\n    delete _allInstances[this._id];\r\n\r\n    // Dispose all events.\r\n    this._disposables.forEach(d => d());\r\n  }\r\n\r\n  public render() {\r\n    const { rootProps, ariaDescribedBy, ariaLabelledBy, className } = this.props;\r\n    const divProps = getNativeProps(this.props, htmlElementProperties);\r\n\r\n    const Tag = this.props.as || this.props.elementType || 'div';\r\n\r\n    // Note, right before rendering/reconciling proceeds, we need to record if focus\r\n    // was in the zone before the update. This helper will track this and, if focus\r\n    // was actually in the zone, what the index path to the element is at this time.\r\n    // Then, later in componentDidUpdate, we can evaluate if we need to restore it in\r\n    // the case the element was removed.\r\n    this._evaluateFocusBeforeRender();\r\n\r\n    return (\r\n      <Tag\r\n        role=\"presentation\"\r\n        {...divProps}\r\n        {\r\n          // root props has been deprecated and should get removed.\r\n          // it needs to be marked as \"any\" since root props expects a div element, but really Tag can\r\n          // be any native element so typescript rightly flags this as a problem.\r\n          ...rootProps as any\r\n        }\r\n        className={css('ms-FocusZone', className)}\r\n        ref={this._root}\r\n        data-focuszone-id={this._id}\r\n        aria-labelledby={ariaLabelledBy}\r\n        aria-describedby={ariaDescribedBy}\r\n        onKeyDown={this._onKeyDown}\r\n        onFocus={this._onFocus}\r\n        onMouseDownCapture={this._onMouseDown}\r\n      >\r\n        {this.props.children}\r\n      </Tag>\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Sets focus to the first tabbable item in the zone.\r\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element, even\r\n   * if focus is already in the focus zone.\r\n   * @returns True if focus could be set to an active element, false if no operation was taken.\r\n   */\r\n  public focus(forceIntoFirstElement: boolean = false): boolean {\r\n    if (this._root.current) {\r\n      if (!forceIntoFirstElement && this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' && this._isInnerZone) {\r\n        const ownerZoneElement = this._getOwnerZone(this._root.current) as HTMLElement;\r\n\r\n        if (ownerZoneElement !== this._root.current) {\r\n          const ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\r\n\r\n          return !!ownerZone && ownerZone.focusElement(this._root.current);\r\n        }\r\n\r\n        return false;\r\n      } else if (\r\n        !forceIntoFirstElement &&\r\n        this._activeElement &&\r\n        elementContains(this._root.current, this._activeElement) &&\r\n        isElementTabbable(this._activeElement)\r\n      ) {\r\n        this._activeElement.focus();\r\n        return true;\r\n      } else {\r\n        const firstChild = this._root.current.firstChild as HTMLElement;\r\n\r\n        return this.focusElement(getNextElement(this._root.current, firstChild, true) as HTMLElement);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Sets focus to a specific child element within the zone. This can be used in conjunction with\r\n   * onBeforeFocus to created delayed focus scenarios (like animate the scroll position to the correct\r\n   * location and then focus.)\r\n   * @param element - The child element within the zone to focus.\r\n   * @returns True if focus could be set to an active element, false if no operation was taken.\r\n   */\r\n  public focusElement(element: HTMLElement): boolean {\r\n    const { onBeforeFocus } = this.props;\r\n\r\n    if (onBeforeFocus && !onBeforeFocus(element)) {\r\n      return false;\r\n    }\r\n\r\n    if (element) {\r\n      this._setActiveElement(element);\r\n      if (this._activeElement) {\r\n        this._activeElement.focus();\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private _evaluateFocusBeforeRender(): void {\r\n    const { current: root } = this._root;\r\n    const doc = getDocument(root);\r\n\r\n    if (doc) {\r\n      const focusedElement = doc.activeElement as HTMLElement;\r\n\r\n      // Only update the index path if we are not parked on the root.\r\n      if (focusedElement !== root) {\r\n        const shouldRestoreFocus = elementContains(root, focusedElement);\r\n\r\n        this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(root as HTMLElement, doc.activeElement as HTMLElement) : undefined;\r\n      }\r\n    }\r\n  }\r\n\r\n  private _onFocus = (ev: React.FocusEvent<HTMLElement>): void => {\r\n    const { onActiveElementChanged, doNotAllowFocusEventToPropagate, onFocusNotification } = this.props;\r\n    const isImmediateDescendant = this._isImmediateDescendantOfZone(ev.target as HTMLElement);\r\n    let newActiveElement: HTMLElement | undefined;\r\n\r\n    if (onFocusNotification) {\r\n      onFocusNotification();\r\n    }\r\n\r\n    if (isImmediateDescendant) {\r\n      newActiveElement = ev.target as HTMLElement;\r\n    } else {\r\n      let parentElement = ev.target as HTMLElement;\r\n\r\n      while (parentElement && parentElement !== this._root.current) {\r\n        if (isElementTabbable(parentElement) && this._isImmediateDescendantOfZone(parentElement)) {\r\n          newActiveElement = parentElement;\r\n          break;\r\n        }\r\n        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\r\n      }\r\n    }\r\n\r\n    if (newActiveElement && newActiveElement !== this._activeElement) {\r\n      this._activeElement = newActiveElement;\r\n\r\n      if (isImmediateDescendant) {\r\n        this._setFocusAlignment(this._activeElement);\r\n      }\r\n    }\r\n\r\n    if (onActiveElementChanged) {\r\n      onActiveElementChanged(this._activeElement as HTMLElement, ev);\r\n    }\r\n\r\n    if (doNotAllowFocusEventToPropagate) {\r\n      ev.stopPropagation();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * When focus is in the zone at render time but then all focusable elements are removed,\r\n   * we \"park\" focus temporarily on the root. Once we update with focusable children, we restore\r\n   * focus to the closest path from previous. If the user tabs away from the parked container,\r\n   * we restore focusability to the pre-parked state.\r\n   */\r\n  private _setParkedFocus(isParked: boolean): void {\r\n    const { current: root } = this._root;\r\n\r\n    if (root && this._isParked !== isParked) {\r\n      this._isParked = isParked;\r\n\r\n      if (isParked) {\r\n        if (!this.props.allowFocusRoot) {\r\n          this._parkedTabIndex = root.getAttribute('tabindex');\r\n          root.setAttribute('tabindex', '-1');\r\n        }\r\n        root.focus();\r\n      } else {\r\n        if (!this.props.allowFocusRoot) {\r\n          if (this._parkedTabIndex) {\r\n            root.setAttribute('tabindex', this._parkedTabIndex);\r\n            this._parkedTabIndex = undefined;\r\n          } else {\r\n            root.removeAttribute('tabindex');\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private _onBlur = (): void => {\r\n    this._setParkedFocus(false);\r\n  };\r\n\r\n  /**\r\n   * Handle global tab presses so that we can patch tabindexes on the fly.\r\n   */\r\n  private _onKeyDownCapture = (ev: KeyboardEvent): void => {\r\n    if (ev.which === KeyCodes.tab) {\r\n      this._updateTabIndexes();\r\n    }\r\n  };\r\n\r\n  private _onMouseDown = (ev: React.MouseEvent<HTMLElement>): void => {\r\n    const { disabled } = this.props;\r\n\r\n    if (disabled) {\r\n      return;\r\n    }\r\n\r\n    let target = ev.target as HTMLElement;\r\n    const path = [];\r\n\r\n    while (target && target !== this._root.current) {\r\n      path.push(target);\r\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\r\n    }\r\n\r\n    while (path.length) {\r\n      target = path.pop() as HTMLElement;\r\n\r\n      if (target && isElementTabbable(target)) {\r\n        this._setActiveElement(target, true);\r\n      }\r\n\r\n      if (isElementFocusZone(target)) {\r\n        // Stop here since the focus zone will take care of its own children.\r\n        break;\r\n      }\r\n    }\r\n  };\r\n\r\n  private _setActiveElement(element: HTMLElement, forceAlignemnt?: boolean): void {\r\n    const previousActiveElement = this._activeElement;\r\n\r\n    this._activeElement = element;\r\n\r\n    if (previousActiveElement) {\r\n      if (isElementFocusZone(previousActiveElement)) {\r\n        this._updateTabIndexes(previousActiveElement);\r\n      }\r\n\r\n      previousActiveElement.tabIndex = -1;\r\n    }\r\n\r\n    if (this._activeElement) {\r\n      if (!this._focusAlignment || forceAlignemnt) {\r\n        this._setFocusAlignment(element, true, true);\r\n      }\r\n\r\n      this._activeElement.tabIndex = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle the keystrokes.\r\n   */\r\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): boolean | undefined => {\r\n    const { direction, disabled, isInnerZoneKeystroke } = this.props;\r\n\r\n    if (disabled) {\r\n      return;\r\n    }\r\n\r\n    if (this.props.onKeyDown) {\r\n      this.props.onKeyDown(ev);\r\n    }\r\n\r\n    // If the default has been prevented, do not process keyboard events.\r\n    if (ev.isDefaultPrevented()) {\r\n      return;\r\n    }\r\n\r\n    if (document.activeElement === this._root.current && this._isInnerZone) {\r\n      // If this element has focus, it is being controlled by a parent.\r\n      // Ignore the keystroke.\r\n      return;\r\n    }\r\n\r\n    if (isInnerZoneKeystroke && isInnerZoneKeystroke(ev) && this._isImmediateDescendantOfZone(ev.target as HTMLElement)) {\r\n      // Try to focus\r\n      const innerZone = this._getFirstInnerZone();\r\n\r\n      if (innerZone) {\r\n        if (!innerZone.focus(true)) {\r\n          return;\r\n        }\r\n      } else if (isElementFocusSubZone(ev.target as HTMLElement)) {\r\n        if (\r\n          !this.focusElement(getNextElement(\r\n            ev.target as HTMLElement,\r\n            (ev.target as HTMLElement).firstChild as HTMLElement,\r\n            true\r\n          ) as HTMLElement)\r\n        ) {\r\n          return;\r\n        }\r\n      } else {\r\n        return;\r\n      }\r\n    } else if (ev.altKey) {\r\n      return;\r\n    } else {\r\n      switch (ev.which) {\r\n        case KeyCodes.space:\r\n          if (this._tryInvokeClickForFocusable(ev.target as HTMLElement)) {\r\n            break;\r\n          }\r\n          return;\r\n\r\n        case KeyCodes.left:\r\n          if (direction !== FocusZoneDirection.vertical && this._moveFocusLeft()) {\r\n            break;\r\n          }\r\n          return;\r\n\r\n        case KeyCodes.right:\r\n          if (direction !== FocusZoneDirection.vertical && this._moveFocusRight()) {\r\n            break;\r\n          }\r\n          return;\r\n\r\n        case KeyCodes.up:\r\n          if (direction !== FocusZoneDirection.horizontal && this._moveFocusUp()) {\r\n            break;\r\n          }\r\n          return;\r\n\r\n        case KeyCodes.down:\r\n          if (direction !== FocusZoneDirection.horizontal && this._moveFocusDown()) {\r\n            break;\r\n          }\r\n          return;\r\n\r\n        case KeyCodes.tab:\r\n          if (\r\n            this.props.allowTabKey ||\r\n            this.props.handleTabKey === FocusZoneTabbableElements.all ||\r\n            (this.props.handleTabKey === FocusZoneTabbableElements.inputOnly && this._isElementInput(ev.target as HTMLElement))\r\n          ) {\r\n            let focusChanged = false;\r\n            this._processingTabKey = true;\r\n            if (\r\n              direction === FocusZoneDirection.vertical ||\r\n              !this._shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP)\r\n            ) {\r\n              focusChanged = ev.shiftKey ? this._moveFocusUp() : this._moveFocusDown();\r\n            } else if (direction === FocusZoneDirection.horizontal || direction === FocusZoneDirection.bidirectional) {\r\n              const tabWithDirection = getRTL() ? !ev.shiftKey : ev.shiftKey;\r\n              focusChanged = tabWithDirection ? this._moveFocusLeft() : this._moveFocusRight();\r\n            }\r\n            this._processingTabKey = false;\r\n            if (focusChanged) {\r\n              break;\r\n            }\r\n          }\r\n          return;\r\n\r\n        case KeyCodes.home:\r\n          if (this._isElementInput(ev.target as HTMLElement) && !this._shouldInputLoseFocus(ev.target as HTMLInputElement, false)) {\r\n            return false;\r\n          }\r\n          const firstChild = this._root.current && (this._root.current.firstChild as HTMLElement | null);\r\n          if (this._root.current && firstChild && this.focusElement(getNextElement(this._root.current, firstChild, true) as HTMLElement)) {\r\n            break;\r\n          }\r\n          return;\r\n\r\n        case KeyCodes.end:\r\n          if (this._isElementInput(ev.target as HTMLElement) && !this._shouldInputLoseFocus(ev.target as HTMLInputElement, true)) {\r\n            return false;\r\n          }\r\n\r\n          const lastChild = this._root.current && (this._root.current.lastChild as HTMLElement | null);\r\n          if (this._root.current && this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true) as HTMLElement)) {\r\n            break;\r\n          }\r\n          return;\r\n\r\n        case KeyCodes.enter:\r\n          if (this._tryInvokeClickForFocusable(ev.target as HTMLElement)) {\r\n            break;\r\n          }\r\n          return;\r\n\r\n        default:\r\n          return;\r\n      }\r\n    }\r\n\r\n    ev.preventDefault();\r\n    ev.stopPropagation();\r\n  };\r\n\r\n  /**\r\n   * Walk up the dom try to find a focusable element.\r\n   */\r\n  private _tryInvokeClickForFocusable(target: HTMLElement): boolean {\r\n    if (target === this._root.current) {\r\n      return false;\r\n    }\r\n\r\n    do {\r\n      if (target.tagName === 'BUTTON' || target.tagName === 'A' || target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {\r\n        return false;\r\n      }\r\n\r\n      if (\r\n        this._isImmediateDescendantOfZone(target) &&\r\n        target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\r\n        target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true'\r\n      ) {\r\n        raiseClick(target);\r\n        return true;\r\n      }\r\n\r\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\r\n    } while (target !== this._root.current);\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Traverse to find first child zone.\r\n   */\r\n  private _getFirstInnerZone(rootElement?: HTMLElement | null): FocusZone | null {\r\n    rootElement = rootElement || this._activeElement || this._root.current;\r\n\r\n    if (!rootElement) {\r\n      return null;\r\n    }\r\n\r\n    if (isElementFocusZone(rootElement)) {\r\n      return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\r\n    }\r\n\r\n    let child = rootElement.firstElementChild as HTMLElement | null;\r\n\r\n    while (child) {\r\n      if (isElementFocusZone(child)) {\r\n        return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\r\n      }\r\n      const match = this._getFirstInnerZone(child);\r\n\r\n      if (match) {\r\n        return match;\r\n      }\r\n\r\n      child = child.nextElementSibling as HTMLElement | null;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  private _moveFocus(\r\n    isForward: boolean,\r\n    getDistanceFromCenter: (activeRect: ClientRect, targetRect: ClientRect) => number,\r\n    ev?: Event,\r\n    useDefaultWrap: boolean = true\r\n  ): boolean {\r\n    let element = this._activeElement;\r\n    let candidateDistance = -1;\r\n    let candidateElement: HTMLElement | undefined = undefined;\r\n    let changedFocus = false;\r\n    const isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;\r\n\r\n    if (!element || !this._root.current) {\r\n      return false;\r\n    }\r\n\r\n    if (this._isElementInput(element)) {\r\n      if (!this._shouldInputLoseFocus(element as HTMLInputElement, isForward)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    const activeRect = isBidirectional ? element.getBoundingClientRect() : null;\r\n\r\n    do {\r\n      element = (isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element)) as HTMLElement;\r\n\r\n      if (isBidirectional) {\r\n        if (element) {\r\n          const targetRect = element.getBoundingClientRect();\r\n          const elementDistance = getDistanceFromCenter(activeRect as ClientRect, targetRect);\r\n\r\n          if (elementDistance === -1 && candidateDistance === -1) {\r\n            candidateElement = element;\r\n            break;\r\n          }\r\n\r\n          if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {\r\n            candidateDistance = elementDistance;\r\n            candidateElement = element;\r\n          }\r\n\r\n          if (candidateDistance >= 0 && elementDistance < 0) {\r\n            break;\r\n          }\r\n        }\r\n      } else {\r\n        candidateElement = element;\r\n        break;\r\n      }\r\n    } while (element);\r\n\r\n    // Focus the closest candidate\r\n    if (candidateElement && candidateElement !== this._activeElement) {\r\n      changedFocus = true;\r\n      this.focusElement(candidateElement);\r\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\r\n      if (isForward) {\r\n        return this.focusElement(getNextElement(\r\n          this._root.current,\r\n          this._root.current.firstElementChild as HTMLElement,\r\n          true\r\n        ) as HTMLElement);\r\n      } else {\r\n        return this.focusElement(getPreviousElement(\r\n          this._root.current,\r\n          this._root.current.lastElementChild as HTMLElement,\r\n          true,\r\n          true,\r\n          true\r\n        ) as HTMLElement);\r\n      }\r\n    }\r\n\r\n    return changedFocus;\r\n  }\r\n\r\n  private _moveFocusDown(): boolean {\r\n    let targetTop = -1;\r\n    const leftAlignment = this._focusAlignment.left;\r\n\r\n    if (\r\n      this._moveFocus(true, (activeRect: ClientRect, targetRect: ClientRect) => {\r\n        let distance = -1;\r\n        // ClientRect values can be floats that differ by very small fractions of a decimal.\r\n        // If the difference between top and bottom are within a pixel then we should treat\r\n        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\r\n        // but without Math.Floor they will be handled incorrectly.\r\n        const targetRectTop = Math.floor(targetRect.top);\r\n        const activeRectBottom = Math.floor(activeRect.bottom);\r\n\r\n        if (targetRectTop < activeRectBottom) {\r\n          if (!this._shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\r\n            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\r\n          }\r\n\r\n          return LARGE_DISTANCE_FROM_CENTER;\r\n        }\r\n\r\n        if ((targetTop === -1 && targetRectTop >= activeRectBottom) || targetRectTop === targetTop) {\r\n          targetTop = targetRectTop;\r\n          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\r\n            distance = 0;\r\n          } else {\r\n            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\r\n          }\r\n        }\r\n\r\n        return distance;\r\n      })\r\n    ) {\r\n      this._setFocusAlignment(this._activeElement as HTMLElement, false, true);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private _moveFocusUp(): boolean {\r\n    let targetTop = -1;\r\n    const leftAlignment = this._focusAlignment.left;\r\n\r\n    if (\r\n      this._moveFocus(false, (activeRect: ClientRect, targetRect: ClientRect) => {\r\n        let distance = -1;\r\n        // ClientRect values can be floats that differ by very small fractions of a decimal.\r\n        // If the difference between top and bottom are within a pixel then we should treat\r\n        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\r\n        // but without Math.Floor they will be handled incorrectly.\r\n        const targetRectBottom = Math.floor(targetRect.bottom);\r\n        const targetRectTop = Math.floor(targetRect.top);\r\n        const activeRectTop = Math.floor(activeRect.top);\r\n\r\n        if (targetRectBottom > activeRectTop) {\r\n          if (!this._shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\r\n            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\r\n          }\r\n          return LARGE_DISTANCE_FROM_CENTER;\r\n        }\r\n\r\n        if ((targetTop === -1 && targetRectBottom <= activeRectTop) || targetRectTop === targetTop) {\r\n          targetTop = targetRectTop;\r\n          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\r\n            distance = 0;\r\n          } else {\r\n            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\r\n          }\r\n        }\r\n\r\n        return distance;\r\n      })\r\n    ) {\r\n      this._setFocusAlignment(this._activeElement as HTMLElement, false, true);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private _moveFocusLeft(): boolean {\r\n    const shouldWrap = this._shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP);\r\n    if (\r\n      this._moveFocus(\r\n        getRTL(),\r\n        (activeRect: ClientRect, targetRect: ClientRect) => {\r\n          let distance = -1;\r\n          let topBottomComparison;\r\n\r\n          if (getRTL()) {\r\n            // When in RTL, this comparison should be the same as the one in _moveFocusRight for LTR.\r\n            // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.\r\n            // This is important, because we want to be comparing the top of the target rect\r\n            // with the bottom of the active rect.\r\n            topBottomComparison = targetRect.top.toFixed(3) < activeRect.bottom.toFixed(3);\r\n          } else {\r\n            topBottomComparison = targetRect.bottom.toFixed(3) > activeRect.top.toFixed(3);\r\n          }\r\n\r\n          if (topBottomComparison && targetRect.right <= activeRect.right && this.props.direction !== FocusZoneDirection.vertical) {\r\n            distance = activeRect.right - targetRect.right;\r\n          } else {\r\n            if (!shouldWrap) {\r\n              distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\r\n            }\r\n          }\r\n\r\n          return distance;\r\n        },\r\n        undefined /*ev*/,\r\n        shouldWrap\r\n      )\r\n    ) {\r\n      this._setFocusAlignment(this._activeElement as HTMLElement, true, false);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private _moveFocusRight(): boolean {\r\n    const shouldWrap = this._shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP);\r\n    if (\r\n      this._moveFocus(\r\n        !getRTL(),\r\n        (activeRect: ClientRect, targetRect: ClientRect) => {\r\n          let distance = -1;\r\n          let topBottomComparison;\r\n\r\n          if (getRTL()) {\r\n            // When in RTL, this comparison should be the same as the one in _moveFocusLeft for LTR.\r\n            // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.\r\n            // This is important, because we want to be comparing the bottom of the target rect\r\n            // with the top of the active rect.\r\n            topBottomComparison = targetRect.bottom.toFixed(3) > activeRect.top.toFixed(3);\r\n          } else {\r\n            topBottomComparison = targetRect.top.toFixed(3) < activeRect.bottom.toFixed(3);\r\n          }\r\n\r\n          if (topBottomComparison && targetRect.left >= activeRect.left && this.props.direction !== FocusZoneDirection.vertical) {\r\n            distance = targetRect.left - activeRect.left;\r\n          } else if (!shouldWrap) {\r\n            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\r\n          }\r\n\r\n          return distance;\r\n        },\r\n        undefined /*ev*/,\r\n        shouldWrap\r\n      )\r\n    ) {\r\n      this._setFocusAlignment(this._activeElement as HTMLElement, true, false);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private _setFocusAlignment(element: HTMLElement, isHorizontal?: boolean, isVertical?: boolean) {\r\n    if (this.props.direction === FocusZoneDirection.bidirectional && (!this._focusAlignment || isHorizontal || isVertical)) {\r\n      const rect = element.getBoundingClientRect();\r\n      const left = rect.left + rect.width / 2;\r\n      const top = rect.top + rect.height / 2;\r\n\r\n      if (!this._focusAlignment) {\r\n        this._focusAlignment = { left, top };\r\n      }\r\n\r\n      if (isHorizontal) {\r\n        this._focusAlignment.left = left;\r\n      }\r\n\r\n      if (isVertical) {\r\n        this._focusAlignment.top = top;\r\n      }\r\n    }\r\n  }\r\n\r\n  private _isImmediateDescendantOfZone(element?: HTMLElement): boolean {\r\n    return this._getOwnerZone(element) === this._root.current;\r\n  }\r\n\r\n  private _getOwnerZone(element?: HTMLElement): HTMLElement | null {\r\n    let parentElement = getParent(element as HTMLElement, ALLOW_VIRTUAL_ELEMENTS);\r\n\r\n    while (parentElement && parentElement !== this._root.current && parentElement !== document.body) {\r\n      if (isElementFocusZone(parentElement)) {\r\n        return parentElement;\r\n      }\r\n\r\n      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\r\n    }\r\n\r\n    return this._root.current;\r\n  }\r\n\r\n  private _updateTabIndexes(element?: HTMLElement) {\r\n    if (!element && this._root.current) {\r\n      this._defaultFocusElement = null;\r\n      element = this._root.current;\r\n      if (this._activeElement && !elementContains(element, this._activeElement)) {\r\n        this._activeElement = null;\r\n      }\r\n    }\r\n\r\n    // If active element changes state to disabled, set it to null.\r\n    // Otherwise, we lose keyboard accessibility to other elements in focus zone.\r\n    if (this._activeElement && !isElementTabbable(this._activeElement)) {\r\n      this._activeElement = null;\r\n    }\r\n\r\n    const childNodes = element && element.children;\r\n\r\n    for (let childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {\r\n      const child = childNodes[childIndex] as HTMLElement;\r\n\r\n      if (!isElementFocusZone(child)) {\r\n        // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.\r\n        if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {\r\n          child.setAttribute(TABINDEX, '-1');\r\n        }\r\n\r\n        if (isElementTabbable(child)) {\r\n          if (this.props.disabled) {\r\n            child.setAttribute(TABINDEX, '-1');\r\n          } else if (!this._isInnerZone && ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)) {\r\n            this._defaultFocusElement = child;\r\n            if (child.getAttribute(TABINDEX) !== '0') {\r\n              child.setAttribute(TABINDEX, '0');\r\n            }\r\n          } else if (child.getAttribute(TABINDEX) !== '-1') {\r\n            child.setAttribute(TABINDEX, '-1');\r\n          }\r\n        } else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {\r\n          // Disgusting IE hack. Sad face.\r\n          child.setAttribute('focusable', 'false');\r\n        }\r\n      } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\r\n        if (!this._isInnerZone && ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)) {\r\n          this._defaultFocusElement = child;\r\n          if (child.getAttribute(TABINDEX) !== '0') {\r\n            child.setAttribute(TABINDEX, '0');\r\n          }\r\n        } else if (child.getAttribute(TABINDEX) !== '-1') {\r\n          child.setAttribute(TABINDEX, '-1');\r\n        }\r\n      }\r\n\r\n      this._updateTabIndexes(child);\r\n    }\r\n  }\r\n\r\n  private _isElementInput(element: HTMLElement): boolean {\r\n    if (element && element.tagName && (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private _shouldInputLoseFocus(element: HTMLInputElement, isForward?: boolean) {\r\n    // If a tab was used, we want to focus on the next element.\r\n    if (!this._processingTabKey && element && element.type && ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {\r\n      const selectionStart = element.selectionStart;\r\n      const selectionEnd = element.selectionEnd;\r\n      const isRangeSelected = selectionStart !== selectionEnd;\r\n      const inputValue = element.value;\r\n\r\n      // We shouldn't lose focus in the following cases:\r\n      // 1. There is range selected.\r\n      // 2. When selection start is larger than 0 and it is backward.\r\n      // 3. when selection start is not the end of length and it is forward.\r\n      // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit tab)\r\n      // and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is determined by calling the\r\n      // callback shouldInputLoseFocusOnArrowKey\r\n      if (\r\n        isRangeSelected ||\r\n        (selectionStart! > 0 && !isForward) ||\r\n        (selectionStart !== inputValue.length && isForward) ||\r\n        (!!this.props.handleTabKey && !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element)))\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private _shouldWrapFocus(element: HTMLElement, noWrapDataAttribute: 'data-no-vertical-wrap' | 'data-no-horizontal-wrap'): boolean {\r\n    return !!this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;\r\n  }\r\n}\r\n"]}