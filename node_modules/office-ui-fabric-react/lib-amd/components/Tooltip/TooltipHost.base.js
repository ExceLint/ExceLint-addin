define(["require", "exports", "tslib", "react", "../../Utilities", "./TooltipHost.types", "./Tooltip", "./Tooltip.types"], function (require, exports, tslib_1, React, Utilities_1, TooltipHost_types_1, Tooltip_1, Tooltip_types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var getClassNames = Utilities_1.classNamesFunction();
    var TooltipHostBase = /** @class */ (function (_super) {
        tslib_1.__extends(TooltipHostBase, _super);
        // Constructor
        function TooltipHostBase(props) {
            var _this = _super.call(this, props) || this;
            // The wrapping div that gets the hover events
            _this._tooltipHost = React.createRef();
            // The ID of the setTimeout that will eventually close the tooltip if the
            // the tooltip isn't hovered over.
            _this._closingTimer = -1;
            _this.show = function () {
                _this._toggleTooltip(true);
            };
            _this.dismiss = function () {
                _this._hideTooltip();
            };
            // Show Tooltip
            _this._onTooltipMouseEnter = function (ev) {
                var overflowMode = _this.props.overflowMode;
                if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip !== _this) {
                    TooltipHostBase._currentVisibleTooltip.dismiss();
                }
                TooltipHostBase._currentVisibleTooltip = _this;
                if (overflowMode !== undefined) {
                    var overflowElement = _this._getTargetElement();
                    if (overflowElement && !Utilities_1.hasOverflow(overflowElement)) {
                        return;
                    }
                }
                if (ev.target && Utilities_1.portalContainsElement(ev.target, _this._getTargetElement())) {
                    // Do not show tooltip when target is inside a portal relative to TooltipHost.
                    return;
                }
                _this._toggleTooltip(true);
                _this._clearDismissTimer();
            };
            // Hide Tooltip
            _this._onTooltipMouseLeave = function (ev) {
                if (_this.props.closeDelay) {
                    _this._clearDismissTimer();
                    _this._closingTimer = _this._async.setTimeout(function () {
                        _this._toggleTooltip(false);
                    }, _this.props.closeDelay);
                }
                else {
                    _this._toggleTooltip(false);
                }
                if (TooltipHostBase._currentVisibleTooltip === _this) {
                    TooltipHostBase._currentVisibleTooltip = undefined;
                }
            };
            _this._clearDismissTimer = function () {
                _this._async.clearTimeout(_this._closingTimer);
            };
            // Hide Tooltip
            _this._hideTooltip = function () {
                _this._toggleTooltip(false);
            };
            _this.state = {
                isTooltipVisible: false
            };
            return _this;
        }
        // Render
        TooltipHostBase.prototype.render = function () {
            var _a = this.props, calloutProps = _a.calloutProps, children = _a.children, content = _a.content, delay = _a.delay, directionalHint = _a.directionalHint, directionalHintForRTL = _a.directionalHintForRTL, className = _a.hostClassName, id = _a.id, _b = _a.setAriaDescribedBy, setAriaDescribedBy = _b === void 0 ? true : _b, tooltipProps = _a.tooltipProps, styles = _a.styles, theme = _a.theme;
            this._classNames = getClassNames(styles, {
                theme: theme,
                className: className
            });
            var isTooltipVisible = this.state.isTooltipVisible;
            var tooltipId = id || Utilities_1.getId('tooltip');
            var isContentPresent = !!(content || (tooltipProps && tooltipProps.onRenderContent && tooltipProps.onRenderContent()));
            var showTooltip = isTooltipVisible && isContentPresent;
            var ariaDescribedBy = setAriaDescribedBy && isTooltipVisible && isContentPresent ? tooltipId : undefined;
            return (React.createElement("div", tslib_1.__assign({ className: this._classNames.root, ref: this._tooltipHost }, { onFocusCapture: this._onTooltipMouseEnter }, { onBlurCapture: this._hideTooltip }, { onMouseEnter: this._onTooltipMouseEnter, onMouseLeave: this._onTooltipMouseLeave, "aria-describedby": ariaDescribedBy }),
                children,
                showTooltip && (React.createElement(Tooltip_1.Tooltip, tslib_1.__assign({ id: tooltipId, delay: delay, content: content, targetElement: this._getTargetElement(), directionalHint: directionalHint, directionalHintForRTL: directionalHintForRTL, calloutProps: Utilities_1.assign({}, calloutProps, {
                        onMouseEnter: this._onTooltipMouseEnter,
                        onMouseLeave: this._onTooltipMouseLeave
                    }), onMouseEnter: this._onTooltipMouseEnter, onMouseLeave: this._onTooltipMouseLeave }, Utilities_1.getNativeProps(this.props, Utilities_1.divProperties), tooltipProps)))));
        };
        TooltipHostBase.prototype.componentWillUnmount = function () {
            if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip === this) {
                TooltipHostBase._currentVisibleTooltip = undefined;
            }
        };
        TooltipHostBase.prototype._getTargetElement = function () {
            if (!this._tooltipHost.current) {
                return undefined;
            }
            var overflowMode = this.props.overflowMode;
            // Select target element based on overflow mode. For parent mode, you want to position the tooltip relative
            // to the parent element, otherwise it might look off.
            if (overflowMode !== undefined) {
                switch (overflowMode) {
                    case TooltipHost_types_1.TooltipOverflowMode.Parent:
                        return this._tooltipHost.current.parentElement;
                    case TooltipHost_types_1.TooltipOverflowMode.Self:
                        return this._tooltipHost.current;
                }
            }
            return this._tooltipHost.current;
        };
        TooltipHostBase.prototype._toggleTooltip = function (isTooltipVisible) {
            var _this = this;
            if (this.state.isTooltipVisible !== isTooltipVisible) {
                this.setState({ isTooltipVisible: isTooltipVisible }, function () { return _this.props.onTooltipToggle && _this.props.onTooltipToggle(_this.state.isTooltipVisible); });
            }
        };
        TooltipHostBase.defaultProps = {
            delay: Tooltip_types_1.TooltipDelay.medium
        };
        return TooltipHostBase;
    }(Utilities_1.BaseComponent));
    exports.TooltipHostBase = TooltipHostBase;
});
//# sourceMappingURL=TooltipHost.base.js.map