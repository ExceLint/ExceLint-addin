define(["require", "exports", "../../Utilities", "../../Styling"], function (require, exports, Utilities_1, Styling_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Size breakpoint when the default border width changes from 2px to 4px.
    var CELL_BORDER_BREAKPOINT = 24;
    var LARGE_BORDER = 4;
    var SMALL_BORDER = 2;
    var DIVIDING_PADDING = 2;
    var DEFAULT_CELL_SIZE = 20;
    exports.getStyles = function (props) {
        var theme = props.theme, disabled = props.disabled, selected = props.selected, circle = props.circle, isWhite = props.isWhite, _a = props.height, height = _a === void 0 ? DEFAULT_CELL_SIZE : _a, _b = props.width, width = _b === void 0 ? DEFAULT_CELL_SIZE : _b, borderWidth = props.borderWidth;
        var semanticColors = theme.semanticColors;
        // If user provided a value, use it. If not, then we decide depending on the 24px size breakpoint.
        var calculatedBorderWidth = borderWidth ? borderWidth : width < CELL_BORDER_BREAKPOINT ? SMALL_BORDER : LARGE_BORDER;
        return {
            // this is a button that wraps the color
            colorCell: [
                {
                    backgroundColor: semanticColors.bodyBackground,
                    padding: 0,
                    position: 'relative',
                    boxSizing: 'border-box',
                    display: 'inline-block',
                    cursor: 'pointer',
                    userSelect: 'none',
                    border: 'none',
                    height: height,
                    width: width
                },
                !circle && {
                    selectors: (_c = {},
                        _c["." + Utilities_1.IsFocusVisibleClassName + " &:focus::after"] = {
                            // -1px so that we don't increase visually the size of the cell.
                            outlineOffset: calculatedBorderWidth - 1 + "px"
                        },
                        _c)
                },
                // In focus state for circle we want a round border which is not possible with outline.
                circle && {
                    borderRadius: '50%',
                    selectors: (_d = {},
                        _d["." + Utilities_1.IsFocusVisibleClassName + " &:focus::after"] = {
                            outline: 'none',
                            borderColor: semanticColors.focusBorder,
                            borderRadius: '50%',
                            left: -calculatedBorderWidth,
                            right: -calculatedBorderWidth,
                            top: -calculatedBorderWidth,
                            bottom: -calculatedBorderWidth,
                            selectors: (_e = {},
                                _e[Styling_1.HighContrastSelector] = {
                                    outline: "1px solid ButtonText"
                                },
                                _e)
                        },
                        _d)
                },
                selected && {
                    padding: DIVIDING_PADDING,
                    border: calculatedBorderWidth + "px solid " + theme.palette.neutralTertiaryAlt
                },
                !selected && {
                    selectors: (_f = {},
                        _f['&:hover, &:active, &:focus'] = {
                            backgroundColor: semanticColors.bodyBackground,
                            padding: DIVIDING_PADDING,
                            border: calculatedBorderWidth + "px solid " + theme.palette.neutralLight
                        },
                        _f['&:focus'] = {
                            borderColor: semanticColors.bodyBackground,
                            padding: 0,
                            selectors: {
                                ':hover': {
                                    borderColor: theme.palette.neutralLight,
                                    padding: DIVIDING_PADDING
                                }
                            }
                        },
                        _f)
                },
                disabled && {
                    color: semanticColors.disabledBodyText,
                    pointerEvents: 'none',
                    opacity: 0.3
                },
                isWhite &&
                    !selected && {
                    // fake a border for white
                    backgroundColor: semanticColors.bodyDivider,
                    padding: 1
                }
            ],
            // the <svg> that holds the color
            svg: [
                {
                    width: '100%',
                    height: '100%'
                },
                circle && {
                    borderRadius: '50%'
                }
            ]
        };
        var _c, _d, _e, _f;
    };
});
//# sourceMappingURL=ColorPickerGridCell.styles.js.map