{"version":3,"file":"DropdownSizePosCache.js","sourceRoot":"../src/","sources":["components/Dropdown/utilities/DropdownSizePosCache.ts"],"names":[],"mappings":";;;IAEA;;;;;;;;;OASG;IACH;QAAA;YAEU,UAAK,GAAG,CAAC,CAAC;QAkDpB,CAAC;QAhDC;;WAEG;QACI,4CAAa,GAApB,UAAqB,OAA0B;YAC7C,IAAM,uBAAuB,GAAG,EAAE,CAAC;YACnC,IAAI,IAAI,GAAG,CAAC,CAAC;YACb,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACvC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,QAAQ,KAAK,qCAAoB,CAAC,OAAO,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,QAAQ,KAAK,qCAAoB,CAAC,MAAM,EAAE;oBAC/G,uBAAuB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;iBACjC;qBAAM;oBACL,IAAI,EAAE,CAAC;iBACR;aACF;YAED,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;YAClB,IAAI,CAAC,wBAAwB,GAAG,uBAAuB,CAAC;QAC1D,CAAC;QAKD,sBAAW,+CAAa;YAHxB;;eAEG;iBACH;gBACE,OAAO,IAAI,CAAC,KAAK,CAAC;YACpB,CAAC;;;WAAA;QAED;;;;WAIG;QACI,4CAAa,GAApB,UAAqB,KAAyB;YAC5C,IAAI,KAAK,KAAK,SAAS,EAAE;gBACvB,OAAO,SAAS,CAAC;aAClB;YAED,+GAA+G;YAC/G,gHAAgH;YAChH,IAAI,MAAM,GAAG,CAAC,CAAC;YACf,OAAO,KAAK,GAAG,IAAI,CAAC,wBAAwB,CAAC,MAAM,CAAC,EAAE;gBACpD,MAAM,EAAE,CAAC;aACV;YAED,IAAI,IAAI,CAAC,wBAAwB,CAAC,MAAM,CAAC,KAAK,KAAK,EAAE;gBACnD,MAAM,IAAI,KAAK,CAAC,iCAA+B,KAAK,kCAA+B,CAAC,CAAC;aACtF;YAED,OAAO,KAAK,GAAG,MAAM,GAAG,CAAC,CAAC;QAC5B,CAAC;QACH,2BAAC;IAAD,CAAC,AApDD,IAoDC;IApDY,oDAAoB","sourcesContent":["import { IDropdownOption, DropdownMenuItemType } from '../Dropdown.types';\r\n\r\n/**\r\n * A utility class to cache size and position in cache.\r\n *\r\n * Dropdown options has non-selectable display types. It is therefore not cheap to determine\r\n * the total number of actual selectable options as well as the position an option is in the\r\n * list of options - O(n) cost for each lookup.\r\n *\r\n * Given that we potentially have to make this determination on every single render pass, this\r\n * cache should provide a little bit of relief.\r\n */\r\nexport class DropdownSizePosCache {\r\n  private _displayOnlyOptionsCache: number[];\r\n  private _size = 0;\r\n\r\n  /**\r\n   * Invalidates the cache and recalculate the size of selectable options.\r\n   */\r\n  public updateOptions(options: IDropdownOption[]) {\r\n    const displayOnlyOptionsCache = [];\r\n    let size = 0;\r\n    for (let i = 0; i < options.length; i++) {\r\n      if (options[i].itemType === DropdownMenuItemType.Divider || options[i].itemType === DropdownMenuItemType.Header) {\r\n        displayOnlyOptionsCache.push(i);\r\n      } else {\r\n        size++;\r\n      }\r\n    }\r\n\r\n    this._size = size;\r\n    this._displayOnlyOptionsCache = displayOnlyOptionsCache;\r\n  }\r\n\r\n  /**\r\n   * The size of all the selectable options.\r\n   */\r\n  public get optionSetSize(): number {\r\n    return this._size;\r\n  }\r\n\r\n  /**\r\n   * Returns the position of this option element relative to the full set of selectable option elements.\r\n   * Note: the first selectable element is position 1 in the set.\r\n   * @param index The raw index of the option element.\r\n   */\r\n  public positionInSet(index: number | undefined): number | undefined {\r\n    if (index === undefined) {\r\n      return undefined;\r\n    }\r\n\r\n    // we could possibly memoize this too but this should be good enough, most of the time (the expectation is that\r\n    // when you have a lot of options, the selectable options will heavily dominate over the non-selectable options.\r\n    let offset = 0;\r\n    while (index > this._displayOnlyOptionsCache[offset]) {\r\n      offset++;\r\n    }\r\n\r\n    if (this._displayOnlyOptionsCache[offset] === index) {\r\n      throw new Error(`Unexpected: Option at index ${index} is not a selectable element.`);\r\n    }\r\n\r\n    return index - offset + 1;\r\n  }\r\n}\r\n"]}