{"version":3,"file":"ComboBox.js","sourceRoot":"../src/","sources":["components/ComboBox/ComboBox.tsx"],"names":[],"mappings":";;;IA6DA,IAAK,eAIJ;IAJD,WAAK,eAAe;QAClB,8DAAa,CAAA;QACb,qDAAQ,CAAA;QACR,2DAAW,CAAA;IACb,CAAC,EAJI,eAAe,KAAf,eAAe,QAInB;IAED,IAAK,WAKJ;IALD,WAAK,WAAW;QACd,iFAAiF;QACjF,sDAAa,CAAA;QACb,mFAAmF;QACnF,oDAAY,CAAA;IACd,CAAC,EALI,WAAW,KAAX,WAAW,QAKf;IAED,IAAM,eAAe,GAAG,GAAG,CAAC,QAAQ,CAAC;IACrC,IAAM,cAAc,GAAG,GAAG,CAAC,CAAC,QAAQ;IAEpC;;;OAGG;IACH,IAAM,kCAAkC,GAAG,IAAI,CAAC,QAAQ,CAAC;IAczD;;;;OAIG;IACH;QAAoC,iDAAgD;QAApF;;QASA,CAAC;QARQ,sCAAM,GAAb;YACE,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC;QAC7B,CAAC;QAEM,qDAAqB,GAA5B,UAA6B,QAAqC;YAChE,uEAAuE;YACvE,OAAO,CAAC,0BAAc,sBAAM,IAAI,CAAC,KAAK,IAAE,MAAM,EAAE,SAAS,0BAAS,QAAQ,IAAE,MAAM,EAAE,SAAS,IAAG,CAAC;QACnG,CAAC;QACH,4BAAC;IAAD,CAAC,AATD,CAAoC,KAAK,CAAC,SAAS,GASlD;IAGD;QAA8B,oCAA6C;QAyDzE,kBAAY,KAAqB;YAAjC,YACE,kBAAM,KAAK,CAAC,SAmCb;YArFO,WAAK,GAAG,KAAK,CAAC,SAAS,EAAkB,CAAC;YAElD,uCAAuC;YAC/B,eAAS,GAAG,KAAK,CAAC,SAAS,EAAa,CAAC;YAEjD,+CAA+C;YACvC,sBAAgB,GAAG,KAAK,CAAC,SAAS,EAAkB,CAAC;YAE7D,0BAA0B;YAClB,mBAAa,GAAG,KAAK,CAAC,SAAS,EAAkB,CAAC;YAE1D,uDAAuD;YAC/C,sBAAgB,GAAG,KAAK,CAAC,SAAS,EAAmB,CAAC;YA+S9D;;eAEG;YACI,WAAK,GAAG,UAAC,iBAA2B,EAAE,aAAuB;gBAClE,IAAI,KAAI,CAAC,SAAS,CAAC,OAAO,EAAE;oBAC1B,IAAI,aAAa,EAAE;wBACjB,sBAAU,CAAC,KAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;qBACpC;yBAAM;wBACL,KAAI,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;qBAChC;oBAED,IAAI,iBAAiB,EAAE;wBACrB,KAAI,CAAC,QAAQ,CAAC;4BACZ,MAAM,EAAE,IAAI;yBACb,CAAC,CAAC;qBACJ;iBACF;YACH,CAAC,CAAC;YAEF;;eAEG;YACI,iBAAW,GAAG;gBACX,IAAA,2BAAM,CAAgB;gBAC9B,MAAM,IAAI,KAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;YAC7C,CAAC,CAAC;YAEF;;;;;;eAMG;YACK,8CAAwC,GAAG;gBACjD,IAAM,QAAQ,GAAG,KAAI,CAAC,SAAS,CAAC,OAAO,CAAC;gBAExC,IAAI,CAAC,QAAQ,EAAE;oBACb,OAAO,IAAI,CAAC;iBACb;gBAED,IAAI,QAAQ,CAAC,KAAK,KAAK,IAAI,IAAI,QAAQ,CAAC,KAAK,KAAK,SAAS,EAAE;oBAC3D,OAAO,IAAI,CAAC;iBACb;gBAED,IAAM,YAAY,GAAG,KAAI,CAAC,kBAAkB,CAAC,KAAI,CAAC,oBAAoB,CAAC,CAAC;gBACxE,IAAI,QAAQ,CAAC,KAAK,KAAK,YAAY,EAAE;oBACnC,wDAAwD;oBACxD,6DAA6D;oBAC7D,0DAA0D;oBAC1D,OAAO,YAAY,IAAI,GAAG,CAAC;iBAC5B;gBAED,OAAO,QAAQ,CAAC,KAAK,CAAC;YACxB,CAAC,CAAC;YAEF;;;;;;;eAOG;YACK,+DAAyD,GAAG;gBAClE,OAAO,KAAI,CAAC,oBAAoB,KAAK,KAAI,CAAC,KAAK,CAAC,qBAAqB,CAAC;YACxE,CAAC,CAAC;YAEF;;;;eAIG;YACK,sBAAgB,GAAG;gBACnB,IAAA,gBAAyD,EAAvD,cAAI,EAAE,gBAAK,EAAE,gCAAa,EAAE,8BAAY,CAAgB;gBAC1D,IAAA,gBAQQ,EAPZ,oCAAe,EACf,gEAA6B,EAC7B,kCAAc,EACd,4CAAmB,EACnB,gDAAqB,EACrB,kBAAM,EACN,oBAAO,CACM;gBAEf,IAAM,wBAAwB,GAAG,KAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,6BAA6B,CAAC,CAAC;gBAExG,+CAA+C;gBAC/C,4DAA4D;gBAC5D,IAAI,CAAC,CAAC,MAAM,IAAI,wBAAwB,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,mBAAmB,KAAK,IAAI,IAAI,mBAAmB,KAAK,SAAS,CAAC,CAAC,EAAE;oBAC1H,OAAO,IAAI,CAAC;iBACb;gBAED,IAAI,CAAC,CAAC,MAAM,IAAI,wBAAwB,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,mBAAmB,KAAK,IAAI,IAAI,mBAAmB,KAAK,SAAS,CAAC,CAAC,EAAE;oBAC3H,OAAO,KAAK,CAAC;iBACd;gBAED,6CAA6C;gBAC7C,IAAM,aAAa,GAAG,EAAE,CAAC;gBAEzB,IAAI,KAAI,CAAC,KAAK,CAAC,WAAW,EAAE;oBAC1B,eAAe;oBACf,IAAI,OAAO,EAAE;wBACX,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC;wBACf,IAAI,YAAY,KAAK,IAAI,IAAI,wBAAwB,EAAE;4BACrD,KAAK,GAAG,6BAA6B,CAAC;yBACvC;wBACD,aAAa,CAAC,IAAI,CAChB,mBAAmB,KAAK,IAAI,IAAI,mBAAmB,KAAK,SAAS;4BAC/D,CAAC,CAAC,mBAAmB;4BACrB,CAAC,CAAC,KAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,KAAK,CAAC;gCAChD,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,IAAI;gCAC5B,CAAC,CAAC,EAAE,CACP,CAAC;qBACH;yBAAM;wBACL,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,eAAe,IAAI,GAAG,GAAG,eAAe,CAAC,MAAM,EAAE,GAAG,EAAE,EAAE;4BACxE,IAAM,KAAK,GAAW,eAAe,CAAC,GAAG,CAAC,CAAC;4BAC3C,aAAa,CAAC,IAAI,CAChB,KAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAI,CAAC,kBAAkB,CAAC,qBAAqB,CAAC,CAC7H,CAAC;yBACH;qBACF;iBACF;qBAAM;oBACL,gBAAgB;oBAChB,IAAI,KAAK,GAAW,KAAI,CAAC,sBAAsB,EAAE,CAAC;oBAClD,IAAI,aAAa,EAAE;wBACjB,4DAA4D;wBAC5D,iEAAiE;wBACjE,6BAA6B;wBAC7B,IAAI,YAAY,KAAK,IAAI,IAAI,wBAAwB,EAAE;4BACrD,KAAK,GAAG,6BAA6B,CAAC;yBACvC;wBAED,kFAAkF;wBAClF,gGAAgG;wBAChG,aAAa,CAAC,IAAI,CAChB,mBAAmB,KAAK,IAAI,IAAI,mBAAmB,KAAK,SAAS;4BAC/D,CAAC,CAAC,mBAAmB;4BACrB,CAAC,CAAC,KAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,KAAK,CAAC;gCAChD,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,IAAI;gCAC5B,CAAC,CAAC,EAAE,CACP,CAAC;qBACH;yBAAM;wBACL,6CAA6C;wBAC7C,8CAA8C;wBAC9C,yDAAyD;wBACzD,IAAI,wBAAwB,IAAI,YAAY,KAAK,IAAI,EAAE;4BACrD,oCAAoC;4BACpC,wCAAwC;4BACxC,6BAA6B;4BAC7B,KAAK,GAAG,6BAA6B,CAAC;4BACtC,aAAa,CAAC,IAAI,CAAC,KAAI,CAAC,kBAAkB,CAAC,mBAAmB,CAAC,CAAC,CAAC;yBAClE;6BAAM;4BACL,aAAa,CAAC,IAAI,CAChB,KAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAI,CAAC,kBAAkB,CAAC,qBAAqB,CAAC,CAC7H,CAAC;yBACH;qBACF;iBACF;gBAED,sEAAsE;gBACtE,6CAA6C;gBAC7C,IAAI,aAAa,GAAG,EAAE,CAAC;gBACvB,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,aAAa,CAAC,MAAM,EAAE,GAAG,EAAE,EAAE;oBACnD,IAAI,GAAG,GAAG,CAAC,EAAE;wBACX,aAAa,IAAI,IAAI,CAAC;qBACvB;oBACD,aAAa,IAAI,aAAa,CAAC,GAAG,CAAC,CAAC;iBACrC;gBACD,OAAO,aAAa,CAAC;YACvB,CAAC,CAAC;YAeF;;;eAGG;YACK,oBAAc,GAAG,UAAC,YAAoB;gBAC5C,IAAI,KAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;oBACvB,KAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;oBAChD,OAAO;iBACR;gBAED,KAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,KAAI,CAAC,+BAA+B,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,KAAI,CAAC,kCAAkC,CAAC,YAAY,CAAC,CAAC;YACxI,CAAC,CAAC;YAuQF;;;eAGG;YACK,aAAO,GAAG;gBAChB,IAAI,KAAI,CAAC,SAAS,CAAC,OAAO,IAAI,KAAI,CAAC,SAAS,CAAC,OAAO,CAAC,YAAY,EAAE;oBACjE,KAAI,CAAC,SAAS,CAAC,OAAO,CAAC,YAAY,CAAC,MAAM,EAAE,CAAC;iBAC9C;gBAED,IAAI,CAAC,KAAI,CAAC,KAAK,CAAC,OAAO,EAAE;oBACvB,KAAI,CAAC,QAAQ,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;iBAClC;YACH,CAAC,CAAC;YAEF;;;;eAIG;YACK,uBAAiB,GAAG;gBAC1B,IAAI,KAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE;oBAC/B,kBAAkB;oBAClB,IAAM,UAAU,GAAG,KAAI,CAAC,KAAK,CAAC,gBAAgB,sBAAM,KAAI,CAAC,KAAK,CAAC,cAAc,EAAG,CAAC;oBAEjF,4EAA4E;oBAC5E,qIAAqI;oBACrI,IAAI,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;wBAC7B,KAAI,CAAC,QAAQ,CAAC;4BACZ,cAAc,EAAE,UAAU;yBAC3B,CAAC,CAAC;qBACJ;yBAAM,IAAI,UAAU,IAAI,UAAU,CAAC,IAAI,EAAE;wBACxC,mFAAmF;wBACnF,gDAAgD;wBAChD,IAAM,SAAO,GAAmC,CAAC,KAAI,CAAC,eAAe,GAAG,UAAU,CAAC,CAAC;wBACpF,SAAO,CAAC,IAAI,CAAC,UAAC,qBAAwC;4BACpD,IAAI,SAAO,KAAK,KAAI,CAAC,eAAe,EAAE;gCACpC,KAAI,CAAC,QAAQ,CAAC;oCACZ,cAAc,EAAE,qBAAqB;iCACtC,CAAC,CAAC;6BACJ;wBACH,CAAC,CAAC,CAAC;qBACJ;iBACF;YACH,CAAC,CAAC;YAEF;;;eAGG;YACK,aAAO,GAAG,UAAC,KAAyC;gBAC1D,kDAAkD;gBAClD,sDAAsD;gBACtD,uDAAuD;gBACvD,IAAI,aAAa,GAAG,KAAK,CAAC,aAAa,CAAC;gBACxC,IAAI,KAAK,CAAC,aAAa,KAAK,IAAI,EAAE;oBAChC,iEAAiE;oBACjE,gEAAgE;oBAChE,kEAAkE;oBAClE,kEAAkE;oBAClE,eAAe;oBACf,aAAa,GAAG,QAAQ,CAAC,aAAwB,CAAC;iBACnD;gBACD,IACE,aAAa;oBACb,oDAAoD;oBACpD,CAAC,CAAC,KAAI,CAAC,KAAK,CAAC,OAAO,IAAI,KAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,aAA4B,CAAC,CAAC;wBAChF,uDAAuD;wBACvD,CAAC,KAAI,CAAC,aAAa,CAAC,OAAO;4BACzB,CAAC,KAAI,CAAC,aAAa,CAAC,OAAO,CAAC,QAAQ,CAAC,aAA4B,CAAC;gCAChE,mHAAmH;gCACnH,2DAA2D;gCAC3D,gCAAoB,CAAC,KAAI,CAAC,aAAa,CAAC,OAAO,EAAE,UAAA,OAAO,IAAI,OAAA,OAAO,KAAK,aAAa,EAAzB,CAAyB,CAAC,CAAC,CAAC,CAAC,EAC/F;oBACA,KAAK,CAAC,cAAc,EAAE,CAAC;oBACvB,KAAK,CAAC,eAAe,EAAE,CAAC;oBACxB,OAAO;iBACR;gBAED,IAAI,KAAI,CAAC,KAAK,CAAC,OAAO,EAAE;oBACtB,KAAI,CAAC,QAAQ,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,CAAC;oBAClC,IAAI,CAAC,KAAI,CAAC,KAAK,CAAC,WAAW,IAAI,KAAI,CAAC,KAAK,CAAC,aAAa,EAAE;wBACvD,KAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;qBACjC;iBACF;YACH,CAAC,CAAC;YAgGF,4CAA4C;YACpC,wBAAkB,GAAG,UAAC,KAAqB;gBAE/C,IAAA,iCAAY,EACZ,iCAAY,EACZ,mCAAa,EACb,yCAAgB,EAChB,+BAAiD,EAAjD,uEAAiD,EACjD,qDAAsB,EACtB,+BAAW,CACH;gBAEF,IAAA,2BAAM,CAAgB;gBAE9B,IAAM,iBAAiB,GACrB,sBAAsB,IAAI,KAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC,KAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;gBAEtH,OAAO,CACL,oBAAC,iBAAO,qBACN,aAAa,EAAE,KAAK,EACpB,QAAQ,EAAE,CAAC,EACX,UAAU,EAAE,KAAK,EACjB,eAAe,EAAE,iCAAe,CAAC,cAAc,EAC/C,oBAAoB,EAAE,KAAK,IACvB,YAAY,IAChB,cAAc,EAAE,KAAI,CAAC,eAAe,EACpC,SAAS,EAAE,eAAG,CAAC,KAAI,CAAC,WAAW,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,EAC3F,MAAM,EAAE,KAAI,CAAC,gBAAgB,CAAC,OAAO,EACrC,SAAS,EAAE,KAAI,CAAC,UAAU,EAC1B,QAAQ,EAAE,KAAI,CAAC,SAAS,EACxB,eAAe,EAAE,KAAK,EACtB,YAAY,EAAE,sBAAsB,IAAI,KAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC,iBAAiB,IAAI,iBAAiB,CAAC,CAAC,CAAC,aAAa,EAC9H,eAAe,EAAE,gBAAgB,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,iBAAiB,EACxE,MAAM,EAAE,WAAW,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS;oBAEzC,6BAAK,SAAS,EAAE,KAAI,CAAC,WAAW,CAAC,uBAAuB,EAAE,GAAG,EAAE,KAAI,CAAC,aAAa,IAC7E,YAAoB,sBAAM,KAAK,GAAI,KAAI,CAAC,aAAa,CAAC,CACpD;oBACL,oBAAoB,CAAC,KAAI,CAAC,KAAK,EAAE,KAAI,CAAC,qBAAqB,CAAC,CACrD,CACX,CAAC;YACJ,CAAC,CAAC;YAUM,qBAAe,GAAG;gBACxB,KAAI,CAAC,sBAAsB,EAAE,CAAC;gBAE9B,IAAI,KAAI,CAAC,KAAK,CAAC,YAAY,IAAI,KAAI,CAAC,KAAK,CAAC,YAAY,CAAC,cAAc,EAAE;oBACrE,KAAI,CAAC,KAAK,CAAC,YAAY,CAAC,cAAc,EAAE,CAAC;iBAC1C;YACH,CAAC,CAAC;YAEF,uBAAuB;YACf,mBAAa,GAAG,UAAC,KAAqB;gBACpC,IAAA,iCAAY,EAAE,uBAAO,CAAW;gBAExC,IAAM,EAAE,GAAG,KAAI,CAAC,GAAG,CAAC;gBACpB,OAAO,CACL,6BAAK,EAAE,EAAE,EAAE,GAAG,OAAO,EAAE,SAAS,EAAE,KAAI,CAAC,WAAW,CAAC,gBAAgB,qBAAmB,EAAE,GAAG,QAAQ,EAAE,IAAI,EAAC,SAAS,IAChH,OAAO,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAC,YAAoB,CAAC,IAAI,EAAE,KAAI,CAAC,aAAa,CAAC,EAA/C,CAA+C,CAAC,CACjE,CACP,CAAC;YACJ,CAAC,CAAC;YAEF,eAAe;YACP,mBAAa,GAAG,UAAC,IAAqB;gBAC5C,QAAQ,IAAI,CAAC,QAAQ,EAAE;oBACrB,KAAK,qDAA4B,CAAC,OAAO;wBACvC,OAAO,KAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;oBACrC,KAAK,qDAA4B,CAAC,MAAM;wBACtC,OAAO,KAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;oBAClC;wBACE,OAAO,KAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;iBACnC;YACH,CAAC,CAAC;YAEF,yDAAyD;YACjD,2BAAqB,GAAG;gBAC9B,OAAO,IAAI,CAAC;YACd,CAAC,CAAC;YAsBM,mBAAa,GAAG,UAAC,IAAqB;gBACpC,IAAA,+BAA4C,EAA5C,kEAA4C,CAAgB;gBACpE,IAAM,EAAE,GAAG,KAAI,CAAC,GAAG,CAAC;gBACpB,IAAM,UAAU,GAAY,KAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAC/D,IAAM,YAAY,GAAG,KAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;gBACxD,IAAM,gBAAgB,GAAG,iDAA2B,CAAC,KAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC,CAAC;gBACzF,IAAM,cAAc,GAAG;oBACrB,OAAO,YAAY,CAAC;gBACtB,CAAC,CAAC;gBACF,IAAM,KAAK,GAAG,KAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;gBAEzC,IAAM,kBAAkB,GAAG;oBACzB,OAAO,CAAC,KAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAC/B,oBAAC,sBAAa,IACZ,EAAE,EAAE,EAAE,GAAG,OAAO,GAAG,IAAI,CAAC,KAAK,EAC7B,GAAG,EAAE,IAAI,CAAC,GAAG,gBACD,IAAI,CAAC,KAAK,EACtB,MAAM,EAAE,KAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,EAC1C,OAAO,EAAE,UAAU,EACnB,SAAS,EAAE,oBAAoB,EAC/B,OAAO,EAAE,KAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAChC,YAAY,EAAE,KAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,KAAI,EAAE,IAAI,CAAC,KAAK,CAAC,EAC7D,WAAW,EAAE,KAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,KAAI,EAAE,IAAI,CAAC,KAAK,CAAC,EAC3D,YAAY,EAAE,KAAI,CAAC,mBAAmB,EACtC,IAAI,EAAC,QAAQ,mBACE,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,EAC5C,SAAS,EAAE,KAAI,CAAC,eAAe,CAAC,IAAI,CAAC,EACrC,QAAQ,EAAE,IAAI,CAAC,QAAQ,EACvB,KAAK,EAAE,KAAK;wBAEX,GAAG;wBAEF,8BAAM,SAAS,EAAE,gBAAgB,CAAC,iBAAiB,EAAE,GAAG,EAAE,UAAU,CAAC,CAAC,CAAC,KAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,SAAS,IACrG,cAAc,CAAC,IAAI,EAAE,KAAI,CAAC,sBAAsB,CAAC,CAC7C,CAEK,CACjB,CAAC,CAAC,CAAC,CACF,oBAAC,mBAAQ,IACP,EAAE,EAAE,EAAE,GAAG,OAAO,GAAG,IAAI,CAAC,KAAK,EAC7B,SAAS,EAAE,KAAI,CAAC,eAAe,CAAC,IAAI,CAAC,EACrC,GAAG,EAAE,IAAI,CAAC,GAAG,gBACD,IAAI,CAAC,KAAK,EACtB,MAAM,EAAE,cAAc,EACtB,SAAS,EAAE,oBAAoB,uBACZ,IAAI,EACvB,QAAQ,EAAE,KAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EACjC,KAAK,EAAE,IAAI,CAAC,IAAI,EAChB,IAAI,EAAC,QAAQ,mBACE,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,EAC5C,OAAO,EAAE,UAAU,EACnB,KAAK,EAAE,KAAK,IAEX,cAAc,CAAC,IAAI,EAAE,KAAI,CAAC,sBAAsB,CAAC,CACzC,CACZ,CAAC;gBACJ,CAAC,CAAC;gBAEF,OAAO,CACL,oBAAC,qBAAqB,IACpB,GAAG,EAAE,IAAI,CAAC,GAAG,EACb,KAAK,EAAE,IAAI,CAAC,KAAK,EACjB,QAAQ,EAAE,IAAI,CAAC,QAAQ,EACvB,UAAU,EAAE,UAAU,EACtB,IAAI,EAAE,IAAI,CAAC,IAAI,EACf,MAAM,EAAE,kBAAkB,GAC1B,CACH,CAAC;YACJ,CAAC,CAAC;YAoDF;;;eAGG;YACK,eAAS,GAAG;gBAClB,IAAI,CAAC,KAAI,CAAC,aAAa,IAAI,KAAI,CAAC,oBAAoB,KAAK,SAAS,EAAE;oBAClE,KAAI,CAAC,MAAM,CAAC,YAAY,CAAC,KAAI,CAAC,oBAAoB,CAAC,CAAC;oBACpD,KAAI,CAAC,oBAAoB,GAAG,SAAS,CAAC;iBACvC;qBAAM;oBACL,KAAI,CAAC,aAAa,GAAG,KAAK,CAAC;iBAC5B;gBAED,KAAI,CAAC,oBAAoB,GAAG,KAAI,CAAC,MAAM,CAAC,UAAU,CAAC;oBACjD,KAAI,CAAC,aAAa,GAAG,IAAI,CAAC;gBAC5B,CAAC,EAAE,eAAe,CAAC,CAAC;YACtB,CAAC,CAAC;YA6CM,4BAAsB,GAAG,UAAC,IAAqB;gBACrD,IAAM,gBAAgB,GAAG,iDAA2B,CAAC,KAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC,CAAC;gBACzF,OAAO,8BAAM,SAAS,EAAE,gBAAgB,CAAC,UAAU,IAAG,IAAI,CAAC,IAAI,CAAQ,CAAC;YAC1E,CAAC,CAAC;YAuBF;;eAEG;YACK,gBAAU,GAAG;gBACnB,yDAAyD;gBACzD,0DAA0D;gBAC1D,uBAAuB;gBACvB,IAAI,KAAI,CAAC,KAAK,CAAC,WAAW,EAAE;oBAC1B,KAAI,CAAC,sBAAsB,EAAE,CAAC;iBAC/B;gBAED,iBAAiB;gBACjB,KAAI,CAAC,4BAA4B,CAAC,KAAK,CAAC,YAAY,EAAE,KAAK,CAAC,0BAA0B,CAAC,CAAC;gBAExF,2BAA2B;gBAC3B,0BAA0B;gBAC1B,KAAI,CAAC,mBAAmB,EAAE,CAAC;YAC7B,CAAC,CAAC;YAwEM,8BAAwB,GAAG;gBACjC,KAAI,CAAC,2BAA2B,GAAG,KAAK,CAAC;YAC3C,CAAC,CAAC;YAuHF;;;eAGG;YACK,qBAAe,GAAG,UAAC,EAA+C;gBAClE,IAAA,gBAAsD,EAApD,sBAAQ,EAAE,gCAAa,EAAE,8BAAY,CAAgB;gBACvD,IAAA,gBAA6E,EAA3E,kBAAM,EAAE,kCAAc,EAAE,8EAAoC,CAAgB;gBAEpF,4EAA4E;gBAC5E,8CAA8C;gBAC9C,KAAI,CAAC,wBAAwB,GAAG,KAAI,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;gBAEtD,IAAI,QAAQ,EAAE;oBACZ,KAAI,CAAC,wBAAwB,CAAC,EAAE,CAAC,CAAC;oBAClC,OAAO;iBACR;gBAED,IAAI,KAAK,GAAG,KAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,gCAAgC,CAAC,CAAC;gBAElF,QAAQ,EAAE,CAAC,KAAK,EAAE;oBAChB,KAAK,oBAAQ,CAAC,KAAK;wBACjB,IAAI,KAAI,CAAC,SAAS,CAAC,OAAO,IAAI,KAAI,CAAC,SAAS,CAAC,OAAO,CAAC,YAAY,EAAE;4BACjE,KAAI,CAAC,SAAS,CAAC,OAAO,CAAC,YAAY,CAAC,MAAM,EAAE,CAAC;yBAC9C;wBAED,KAAI,CAAC,mBAAmB,CAAC,EAAE,CAAC,CAAC;wBAC7B,IAAI,KAAI,CAAC,KAAK,CAAC,WAAW,IAAI,MAAM,EAAE;4BACpC,KAAI,CAAC,QAAQ,CAAC;gCACZ,6BAA6B,EAAE,KAAK;6BACrC,CAAC,CAAC;yBACJ;6BAAM;4BACL,oCAAoC;4BACpC,IACE,MAAM;gCACN,CAAC,CAAC,CAAC,aAAa;oCACd,KAAI,CAAC,KAAK,CAAC,mBAAmB,KAAK,SAAS;oCAC5C,KAAI,CAAC,KAAK,CAAC,mBAAmB,KAAK,IAAI;oCACvC,KAAI,CAAC,KAAK,CAAC,mBAAmB,CAAC,MAAM,IAAI,CAAC,CAAC;oCAC3C,KAAI,CAAC,KAAK,CAAC,6BAA6B,GAAG,CAAC,CAAC,EAC/C;gCACA,oBAAoB;gCACpB,qCAAqC;gCACrC,+BAA+B;gCAC/B,6BAA6B;gCAC7B,sBAAsB;gCACtB,KAAI,CAAC,QAAQ,CAAC;oCACZ,MAAM,EAAE,CAAC,MAAM;iCAChB,CAAC,CAAC;6BACJ;yBACF;wBACD,MAAM;oBAER,KAAK,oBAAQ,CAAC,GAAG;wBACf,oCAAoC;wBACpC,IAAI,CAAC,KAAI,CAAC,KAAK,CAAC,WAAW,EAAE;4BAC3B,KAAI,CAAC,mBAAmB,CAAC,EAAE,CAAC,CAAC;yBAC9B;wBAED,kCAAkC;wBAClC,+CAA+C;wBAC/C,IAAI,MAAM,EAAE;4BACV,KAAI,CAAC,4BAA4B,CAAC,CAAC,MAAM,EAAE,KAAK,CAAC,0BAA0B,CAAC,CAAC;yBAC9E;wBAED,yBAAyB;wBACzB,OAAO;oBAET,KAAK,oBAAQ,CAAC,MAAM;wBAClB,2BAA2B;wBAC3B,KAAI,CAAC,mBAAmB,EAAE,CAAC;wBAE3B,2BAA2B;wBAC3B,IAAI,MAAM,EAAE;4BACV,KAAI,CAAC,QAAQ,CAAC;gCACZ,MAAM,EAAE,KAAK;6BACd,CAAC,CAAC;yBACJ;6BAAM;4BACL,OAAO;yBACR;wBACD,MAAM;oBAER,KAAK,oBAAQ,CAAC,EAAE;wBACd,yDAAyD;wBACzD,8CAA8C;wBAC9C,uBAAuB;wBACvB,IAAI,oCAAoC,KAAK,WAAW,CAAC,QAAQ,EAAE;4BACjE,KAAK,GAAG,KAAI,CAAC,KAAK,CAAC,cAAc,CAAC,MAAM,CAAC;yBAC1C;wBAED,IAAI,EAAE,CAAC,MAAM,IAAI,EAAE,CAAC,OAAO,EAAE;4BAC3B,4CAA4C;4BAC5C,0DAA0D;4BAC1D,4DAA4D;4BAC5D,IAAI,MAAM,EAAE;gCACV,KAAI,CAAC,4BAA4B,CAAC,CAAC,MAAM,EAAE,IAAI,CAAC,0BAA0B,CAAC,CAAC;gCAC5E,MAAM;6BACP;4BAED,OAAO;yBACR;wBAED,4BAA4B;wBAC5B,KAAI,CAAC,oCAAoC,CAAC,KAAK,EAAE,eAAe,CAAC,QAAQ,CAAC,CAAC;wBAC3E,MAAM;oBAER,KAAK,oBAAQ,CAAC,IAAI;wBAChB,yCAAyC;wBACzC,IAAI,EAAE,CAAC,MAAM,IAAI,EAAE,CAAC,OAAO,EAAE;4BAC3B,KAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,0BAA0B,CAAC,CAAC;yBACvF;6BAAM;4BACL,yDAAyD;4BACzD,8CAA8C;4BAC9C,wBAAwB;4BACxB,IAAI,oCAAoC,KAAK,WAAW,CAAC,QAAQ,EAAE;gCACjE,KAAK,GAAG,CAAC,CAAC,CAAC;6BACZ;4BAED,yBAAyB;4BACzB,KAAI,CAAC,oCAAoC,CAAC,KAAK,EAAE,eAAe,CAAC,OAAO,CAAC,CAAC;yBAC3E;wBACD,MAAM;oBAER,KAAK,oBAAQ,CAAC,IAAI,CAAC;oBACnB,KAAK,oBAAQ,CAAC,GAAG;wBACf,IAAI,aAAa,EAAE;4BACjB,OAAO;yBACR;wBAED,4CAA4C;wBAC5C,4CAA4C;wBAC5C,KAAK,GAAG,CAAC,CAAC,CAAC;wBACX,IAAI,iBAAiB,GAAG,eAAe,CAAC,OAAO,CAAC;wBAEhD,8CAA8C;wBAC9C,2CAA2C;wBAC3C,IAAI,EAAE,CAAC,KAAK,KAAK,oBAAQ,CAAC,GAAG,EAAE;4BAC7B,KAAK,GAAG,cAAc,CAAC,MAAM,CAAC;4BAC9B,iBAAiB,GAAG,eAAe,CAAC,QAAQ,CAAC;yBAC9C;wBAED,KAAI,CAAC,oCAAoC,CAAC,KAAK,EAAE,iBAAiB,CAAC,CAAC;wBACpE,MAAM;oBAER,KAAK,oBAAQ,CAAC,KAAK;wBACjB,oCAAoC;wBACpC,IAAI,CAAC,aAAa,IAAI,YAAY,KAAK,KAAK,EAAE;4BAC5C,MAAM;yBACP;oBAEH;wBACE,mDAAmD;wBACnD,IAAI,EAAE,CAAC,KAAK,IAAI,GAAG,CAAC,QAAQ,IAAI,EAAE,CAAC,KAAK,IAAI,GAAG,CAAC,SAAS,EAAE;4BACzD,OAAO;yBACR;wBAED,+CAA+C;wBAC/C,uCAAuC;wBACvC,IAAI,EAAE,CAAC,OAAO,KAAK,oBAAQ,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,KAAK,MAAM,CAAC,eAAe,EAAE;4BACpE,OAAO;yBACR;wBAED,sCAAsC;wBACtC,+CAA+C;wBAC/C,6CAA6C;wBAC7C,IAAI,CAAC,aAAa,IAAI,YAAY,KAAK,IAAI,EAAE;4BAC3C,KAAI,CAAC,cAAc,CAAC,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;4BACnD,MAAM;yBACP;wBAED,wCAAwC;wBACxC,OAAO;iBACV;gBAED,EAAE,CAAC,eAAe,EAAE,CAAC;gBACrB,EAAE,CAAC,cAAc,EAAE,CAAC;YACtB,CAAC,CAAC;YASF;;;eAGG;YACK,mBAAa,GAAG,UAAC,EAA+C;gBAChE,IAAA,gBAAsD,EAApD,sBAAQ,EAAE,gCAAa,EAAE,8BAAY,CAAgB;gBAC7D,IAAM,MAAM,GAAG,KAAI,CAAC,KAAK,CAAC,MAAM,CAAC;gBAEjC,qEAAqE;gBACrE,mDAAmD;gBACnD,uFAAuF;gBACvF,8BAA8B;gBAC9B,gCAAgC;gBAChC,+FAA+F;gBAC/F,2EAA2E;gBAC3E,IAAM,wBAAwB,GAAG,KAAI,CAAC,wBAAwB,IAAI,KAAI,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;gBACxF,KAAI,CAAC,wBAAwB,GAAG,KAAK,CAAC;gBACtC,IAAM,eAAe,GAAG,wBAAwB,IAAI,CAAC,CAAC,iBAAK,EAAE,IAAI,iBAAK,EAAE,CAAC,CAAC;gBAE1E,IAAI,QAAQ,EAAE;oBACZ,KAAI,CAAC,wBAAwB,CAAC,EAAE,CAAC,CAAC;oBAClC,OAAO;iBACR;gBAED,QAAQ,EAAE,CAAC,KAAK,EAAE;oBAChB,KAAK,oBAAQ,CAAC,KAAK;wBACjB,2DAA2D;wBAC3D,0CAA0C;wBAC1C,mCAAmC;wBACnC,IAAI,CAAC,aAAa,IAAI,YAAY,KAAK,KAAK,EAAE;4BAC5C,KAAI,CAAC,4BAA4B,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC;4BACrD,OAAO;yBACR;wBACD,MAAM;oBACR;wBACE,IAAI,eAAe,IAAI,MAAM,EAAE;4BAC7B,KAAI,CAAC,4BAA4B,CAAC,CAAC,MAAM,EAAE,IAAI,CAAC,0BAA0B,CAAC,CAAC;yBAC7E;wBACD,OAAO;iBACV;gBAED,EAAE,CAAC,eAAe,EAAE,CAAC;gBACrB,EAAE,CAAC,cAAc,EAAE,CAAC;YACtB,CAAC,CAAC;YAwBM,yBAAmB,GAAG;gBAC5B,IAAI,KAAI,CAAC,uBAAuB,EAAE,EAAE;oBAClC,OAAO;iBACR;gBAED,0DAA0D;gBAC1D,+DAA+D;gBAC/D,IAAI,KAAI,CAAC,KAAK,CAAC,WAAW,IAAI,CAAC,KAAI,CAAC,KAAK,CAAC,MAAM,EAAE;oBAChD,OAAO;iBACR;gBAED,KAAI,CAAC,QAAQ,CAAC;oBACZ,oCAAoC,EAAE,WAAW,CAAC,QAAQ;iBAC3D,CAAC,CAAC;YACL,CAAC,CAAC;YAiCF;;;;eAIG;YACK,sBAAgB,GAAG;gBACjB,IAAA,+BAAQ,CAAgB;gBACxB,IAAA,2BAAM,CAAgB;gBAE9B,IAAI,CAAC,QAAQ,EAAE;oBACb,KAAI,CAAC,4BAA4B,CAAC,CAAC,MAAM,EAAE,KAAK,CAAC,0BAA0B,CAAC,CAAC;oBAC7E,KAAI,CAAC,QAAQ,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;iBAClC;YACH,CAAC,CAAC;YAEF;;eAEG;YACK,sBAAgB,GAAG;gBACzB,IAAI,KAAI,CAAC,KAAK,CAAC,aAAa,EAAE;oBAC5B,KAAI,CAAC,KAAK,CAAC,KAAI,CAAC,KAAK,CAAC,MAAM,IAAI,KAAI,CAAC,gBAAgB,CAAC,CAAC;iBACxD;qBAAM;oBACL,KAAI,CAAC,gBAAgB,EAAE,CAAC;iBACzB;YACH,CAAC,CAAC;YAEM,mBAAa,GAAe;gBAClC,IAAI,KAAI,CAAC,gBAAgB,CAAC,OAAO,IAAI,CAAC,CAAC,eAAe,IAAI,KAAI,CAAC,gBAAgB,CAAC,EAAE;oBAChF,KAAI,CAAC,2BAA2B,EAAE,CAAC;iBACpC;YACH,CAAC,CAAC;YAEM,oBAAc,GAAG,UAAC,EAAgB;gBACxC,IAAI,EAAE,CAAC,WAAW,KAAK,OAAO,EAAE;oBAC9B,KAAI,CAAC,2BAA2B,EAAE,CAAC;oBAEnC,EAAE,CAAC,cAAc,EAAE,CAAC;oBACpB,EAAE,CAAC,wBAAwB,EAAE,CAAC;iBAC/B;YACH,CAAC,CAAC;YAnuDA,KAAI,CAAC,sBAAsB,CAAC;gBAC1B,kBAAkB,EAAE,aAAa;gBACjC,IAAI,EAAE,oBAAoB;gBAC1B,KAAK,EAAE,oBAAoB;gBAC3B,WAAW,EAAE,OAAO;gBACpB,aAAa,EAAE,wBAAwB;aACxC,CAAC,CAAC;YAEH,KAAI,CAAC,iBAAiB,CAAC;gBACrB,KAAK,EAAE,MAAM;gBACb,SAAS,EAAE,UAAU;aACtB,CAAC,CAAC;YAEH,KAAI,CAAC,GAAG,GAAG,KAAK,CAAC,EAAE,IAAI,iBAAK,CAAC,UAAU,CAAC,CAAC;YACzC,IAAM,YAAY,GAAwB,KAAI,CAAC,yBAAyB,CAAC,KAAK,CAAC,kBAAkB,EAAE,KAAK,CAAC,WAAW,CAAC,CAAC;YAEtH,KAAI,CAAC,aAAa,GAAG,IAAI,CAAC;YAC1B,KAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC;YAC9B,KAAI,CAAC,aAAa,GAAG,KAAK,CAAC;YAC3B,KAAI,CAAC,2BAA2B,GAAG,KAAK,CAAC;YAEzC,IAAM,sBAAsB,GAAa,KAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;YAE/F,KAAI,CAAC,KAAK,GAAG;gBACX,MAAM,EAAE,KAAK;gBACb,eAAe,EAAE,sBAAsB;gBACvC,OAAO,EAAE,KAAK;gBACd,qBAAqB,EAAE,SAAS;gBAChC,cAAc,EAAE,KAAI,CAAC,KAAK,CAAC,OAAO;gBAClC,6BAA6B,EAAE,CAAC,CAAC;gBACjC,mBAAmB,EAAE,SAAS;gBAC9B,oCAAoC,EAAE,WAAW,CAAC,OAAO;aAC1D,CAAC;;QACJ,CAAC;QAEM,oCAAiB,GAAxB;YACE,IAAI,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE;gBACjC,mDAAmD;gBACnD,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,OAAO,EAAE,IAAI,CAAC,iBAAiB,EAAE,IAAI,CAAC,CAAC;gBACtF,IAAI,eAAe,IAAI,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE;oBACpD,4GAA4G;oBAC5G,+GAA+G;oBAC/G,uCAAuC;oBACvC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,aAAa,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;iBAC1F;aACF;QACH,CAAC;QAEM,4CAAyB,GAAhC,UAAiC,QAAwB;YACvD,uDAAuD;YACvD,kDAAkD;YAClD,IACE,QAAQ,CAAC,WAAW,KAAK,IAAI,CAAC,KAAK,CAAC,WAAW;gBAC/C,QAAQ,CAAC,IAAI,KAAK,IAAI,CAAC,KAAK,CAAC,IAAI;gBACjC,QAAQ,CAAC,KAAK,KAAK,IAAI,CAAC,KAAK,CAAC,KAAK;gBACnC,QAAQ,CAAC,OAAO,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,EACvC;gBACA,IAAM,YAAY,GAAwB,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;gBACxF,IAAM,OAAO,GAAa,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;gBAEnF,IAAI,CAAC,QAAQ,CAAC;oBACZ,eAAe,EAAE,OAAO;oBACxB,cAAc,EAAE,QAAQ,CAAC,OAAO;iBACjC,CAAC,CAAC;aACJ;QACH,CAAC;QAEM,qCAAkB,GAAzB,UAA0B,SAAyB,EAAE,SAAyB;YAA9E,iBA0DC;YAzDO,IAAA,eAAwE,EAAtE,gCAAa,EAAE,cAAI,EAAE,gBAAK,EAAE,0BAAU,EAAE,oCAAe,CAAgB;YACzE,IAAA,eAAgF,EAA9E,kBAAM,EAAE,oBAAO,EAAE,oCAAe,EAAE,gEAA6B,CAAgB;YAEvF,wEAAwE;YACxE,wEAAwE;YACxE,IAAI,MAAM,IAAI,CAAC,CAAC,SAAS,CAAC,MAAM,IAAI,SAAS,CAAC,6BAA6B,KAAK,6BAA6B,CAAC,EAAE;gBAC9G,yEAAyE;gBACzE,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,cAAM,OAAA,KAAI,CAAC,eAAe,EAAE,EAAtB,CAAsB,EAAE,CAAC,CAAC,CAAC;aACzD;YAED,uDAAuD;YACvD,0EAA0E;YAC1E,0DAA0D;YAC1D,IACE,OAAO;gBACP,CAAC,MAAM;oBACL,CAAC,SAAS,CAAC,MAAM;wBACf,CAAC,MAAM;wBACP,IAAI,CAAC,qBAAqB;wBAC1B,IAAI,CAAC,SAAS,CAAC,OAAO;wBACtB,QAAQ,CAAC,aAAa,KAAK,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,EACpE;gBACA,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,qBAAqB,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC;aACrE;YAED,mCAAmC;YACnC,mCAAmC;YACnC,oBAAoB;YACpB,wDAAwD;YACxD,mCAAmC;YACnC,wBAAwB;YACxB,2BAA2B;YAC3B,IACE,IAAI,CAAC,qBAAqB;gBAC1B,CAAC,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC;oBAC5B,CAAC,OAAO;wBACN,CAAC,CAAC,CAAC,MAAM;4BACP,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW;4BACvB,SAAS,CAAC,eAAe;4BACzB,eAAe;4BACf,SAAS,CAAC,eAAe,CAAC,CAAC,CAAC,KAAK,eAAe,CAAC,CAAC,CAAC,CAAC;4BACpD,CAAC,aAAa;4BACd,IAAI,KAAK,SAAS,CAAC,IAAI;4BACvB,KAAK,KAAK,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,EAClC;gBACA,IAAI,CAAC,OAAO,EAAE,CAAC;aAChB;YAED,IAAI,CAAC,0BAA0B,CAAC,SAAS,CAAC,CAAC;YAE3C,IAAI,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,UAAU,EAAE;gBAC7C,UAAU,EAAE,CAAC;aACd;YAED,IAAI,CAAC,MAAM,IAAI,SAAS,CAAC,MAAM,IAAI,eAAe,EAAE;gBAClD,eAAe,EAAE,CAAC;aACnB;QACH,CAAC;QAEM,uCAAoB,GAA3B;YACE,iBAAM,oBAAoB,WAAE,CAAC;YAE7B,8DAA8D;YAC9D,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;QAClD,CAAC;QAED,iBAAiB;QACV,yBAAM,GAAb;YAAA,iBA8HC;YA7HC,IAAM,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC;YACd,IAAA,eAuBQ,EAtBZ,wBAAS,EACT,gBAAK,EACL,sBAAQ,EACR,wBAAS,EACT,oCAAe,EACf,sBAAQ,EACR,8BAAY,EACZ,yBAA2C,EAA3C,gEAA2C,EAC3C,oBAAiC,EAAjC,sDAAiC,EACjC,oBAAiC,EAAjC,sDAAiC,EACjC,sBAA4C,EAA5C,iEAA4C,EAC5C,gCAAa,EACb,oCAAe,EACf,0BAAyB,EAAzB,8CAAyB,EACzB,wBAAoB,EACpB,gBAAK,EACL,gBAAK,EACL,4BAAW,EACX,4BAAW,EACX,sBAAQ,EACR,sBAAQ,EACR,4BAAW,CACE;YACT,IAAA,eAAuD,EAArD,kBAAM,EAAE,oBAAO,EAAE,gDAAqB,CAAgB;YAC9D,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;YAEpD,IAAM,QAAQ,GAAG,0BAAc,CAAC,IAAI,CAAC,KAAK,EAAE,yBAAa,EAAE,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC,CAAC;YAElF,IAAM,eAAe,GAAG,YAAY,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC;YAE/E,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa;gBACzC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,KAAM,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,aAAa,EAAE,CAAC,CAAC,eAAe,EAAE,SAAS,CAAC;gBAC9H,CAAC,CAAC,mCAAa,CACX,2BAAS,CAAC,KAAM,EAAE,YAAY,CAAC,EAC/B,SAAU,EACV,CAAC,CAAC,MAAM,EACR,CAAC,CAAC,QAAQ,EACV,CAAC,CAAC,QAAQ,EACV,CAAC,CAAC,OAAO,EACT,CAAC,CAAC,aAAa,EACf,CAAC,CAAC,eAAe,CAClB,CAAC;YAEN,OAAO,CACL,gDAAS,QAAQ,IAAE,GAAG,EAAE,IAAI,CAAC,KAAK,EAAE,SAAS,EAAE,IAAI,CAAC,WAAW,CAAC,SAAS;gBACtE,KAAK,IAAI,CACR,oBAAC,aAAK,IAAC,EAAE,EAAE,EAAE,GAAG,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,EAAE,GAAG,QAAQ,EAAE,SAAS,EAAE,IAAI,CAAC,WAAW,CAAC,KAAK,IACxH,KAAK,CACA,CACT;gBACD,oBAAC,uBAAU,IAAC,WAAW,EAAE,WAAW,EAAE,QAAQ,EAAE,QAAQ,IACrD,UAAC,gBAAqB,IAAkB,OAAA,CACvC,gDACmB,gBAAgB,CAAC,iBAAiB,CAAC,EACpD,GAAG,EAAE,KAAI,CAAC,gBAAgB,EAC1B,EAAE,EAAE,EAAE,GAAG,SAAS,EAClB,SAAS,EAAE,KAAI,CAAC,WAAW,CAAC,IAAI;oBAEhC,oBAAC,gBAAQ,gDACkB,gBAAgB,CAAC,yBAAyB,CAAC,0BAC9C,CAAC,QAAQ,EAC/B,YAAY,EAAE,KAAI,CAAC,SAAS,EAC5B,EAAE,EAAE,EAAE,GAAG,QAAQ,EACjB,SAAS,EAAE,KAAI,CAAC,WAAW,CAAC,KAAK,EACjC,IAAI,EAAC,MAAM,EACX,OAAO,EAAE,KAAI,CAAC,OAAO,EACrB,MAAM,EAAE,KAAI,CAAC,OAAO,EACpB,SAAS,EAAE,KAAI,CAAC,eAAe,EAC/B,OAAO,EAAE,KAAI,CAAC,aAAa,EAC3B,OAAO,EAAE,KAAI,CAAC,gBAAgB,EAC9B,YAAY,EAAE,KAAI,CAAC,aAAa,EAChC,kBAAkB,EAAE,KAAI,CAAC,cAAc,mBACxB,MAAM,uBACF,KAAI,CAAC,yBAAyB,EAAE,EACnD,IAAI,EAAC,UAAU,EACf,QAAQ,EAAE,QAAQ,IAAI,CAAC,aAAa,qBACnB,KAAK,IAAI,EAAE,GAAG,QAAQ,gBAC3B,SAAS,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,sBACrC,oCAAwB,CAAC,eAAe,EAAE,gBAAgB,CAAC,kBAAkB,CAAC,CAAC,2BAC1E,KAAI,CAAC,0BAA0B,EAAE,mBACzC,QAAQ,mBACR,QAAQ,eACZ,MAAM,CAAC,CAAC,CAAC,EAAE,GAAG,OAAO,CAAC,CAAC,CAAC,SAAS,EAC5C,UAAU,EAAE,KAAK,EACjB,mBAAmB,EAAE,KAAI,CAAC,oBAAoB,EAC9C,qBAAqB,EAAE,qBAAqB,EAC5C,6BAA6B,EAAE,KAAI,CAAC,wCAAwC,EAC5E,8CAA8C,EAAE,KAAI,CAAC,yDAAyD,EAC9G,KAAK,EAAE,KAAK,EACZ,qBAAqB,EAAE,CAAC,OAAO,EAC/B,WAAW,EAAE,WAAW,EACxB,QAAQ,EAAE,QAAQ,IACd,QAAQ,EACZ;oBACF,oBAAC,mBAAU,IACT,SAAS,EAAE,8BAA8B,EACzC,MAAM,EAAE,KAAI,CAAC,qBAAqB,EAAE,EACpC,IAAI,EAAC,cAAc,iBACN,kBAAkB,uBACZ,KAAK,EACxB,QAAQ,EAAE,CAAC,CAAC,EACZ,OAAO,EAAE,KAAI,CAAC,gBAAgB,EAC9B,SAAS,EAAE,eAAe,EAC1B,QAAQ,EAAE,QAAQ,EAClB,OAAO,EAAE,MAAM,GACf,CACE,CACP,EAxDwC,CAwDxC,CACU;gBACZ,CAAC,WAAW,IAAI,MAAM,CAAC;oBACrB,iBAAyB,sBAEnB,IAAI,CAAC,KAAK,IACb,YAAY,cAAA;wBACZ,YAAY,cAAA;wBACZ,cAAc,gBAAA,EACd,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,GAAG,CAAC,UAAC,IAAI,EAAE,KAAK,IAAK,OAAA,sBAAM,IAAI,IAAE,KAAK,EAAE,KAAK,IAAG,EAA3B,CAA2B,CAAC,KAEtF,IAAI,CAAC,kBAAkB,CACxB;gBACF,YAAY,IAAI,6BAAK,SAAS,EAAE,IAAI,CAAC,WAAW,CAAC,YAAY,IAAG,YAAY,CAAO,CAChF,CACP,CAAC;QACJ,CAAC;QA8KD;;;;;WAKG;QACK,qCAAkB,GAA1B,UAA2B,OAAsC,EAAE,KAAa;YAC9E,IAAI,CAAC,OAAO,EAAE;gBACZ,OAAO,KAAK,CAAC;aACd;YACD,OAAO,KAAK,IAAI,CAAC,IAAI,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC;QAC9C,CAAC;QAeD;;;;WAIG;QACK,kDAA+B,GAAvC,UAAwC,YAAoB;YAA5D,iBA8EC;YA7ES,IAAA,0CAAc,CAAgB;YACtC,YAAY,GAAG,IAAI,CAAC,sBAAsB,CAAC,YAAY,CAAC,CAAC;YACzD,IAAI,gCAAgC,GAAG,CAAC,CAAC,CAAC;YAE1C,2DAA2D;YAC3D,gCAAgC;YAChC,IAAI,YAAY,KAAK,EAAE,EAAE;gBACvB,IAAM,KAAK,GAAG,cAAc;qBACzB,GAAG,CAAC,UAAC,IAAI,EAAE,KAAK;oBACf,4BAAY,IAAI,IAAE,KAAK,OAAA,IAAG;gBAC5B,CAAC,CAAC;qBACD,MAAM,CACL,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,MAAM,IAAI,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,OAAO,EAAnH,CAAmH,CAC9H;qBACA,MAAM,CAAC,UAAA,MAAM,IAAI,OAAA,KAAI,CAAC,eAAe,CAAC,MAAM,CAAC,KAAK,YAAY,EAA7C,CAA6C,CAAC,CAAC;gBAEnE,yCAAyC;gBACzC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;oBACtB,gCAAgC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;iBACnD;gBAED,IAAI,CAAC,eAAe,CAAC,YAAY,EAAE,gCAAgC,EAAE,YAAY,CAAC,CAAC;gBACnF,OAAO;aACR;YAED,wCAAwC;YACxC,0CAA0C;YAC1C,IAAM,oBAAoB,GAAW,YAAY,CAAC;YAClD,YAAY,GAAG,YAAY,CAAC,iBAAiB,EAAE,CAAC;YAEhD,IAAI,wBAAwB,GAAG,EAAE,CAAC;YAElC,4EAA4E;YAC5E,IAAI,IAAI,CAAC,KAAK,CAAC,YAAY,KAAK,IAAI,EAAE;gBACpC,2GAA2G;gBAC3G,IAAM,KAAK,GAAG,cAAc;qBACzB,GAAG,CAAC,UAAC,IAAI,EAAE,KAAK;oBACf,4BAAY,IAAI,IAAE,KAAK,OAAA,IAAG;gBAC5B,CAAC,CAAC;qBACD,MAAM,CACL,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,MAAM,IAAI,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,OAAO,EAAnH,CAAmH,CAC9H;qBACA,MAAM,CACL,UAAA,MAAM;oBACJ,OAAA,KAAI,CAAC,eAAe,CAAC,MAAM,CAAC;yBACzB,iBAAiB,EAAE;yBACnB,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC;gBAF9B,CAE8B,CACjC,CAAC;gBACJ,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;oBACpB,oDAAoD;oBACpD,IAAM,IAAI,GAAW,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;oBAEpD,mGAAmG;oBACnG,wBAAwB,GAAG,IAAI,CAAC,iBAAiB,EAAE,KAAK,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC;oBAEjF,2CAA2C;oBAC3C,gCAAgC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;iBACnD;aACF;iBAAM;gBACL,gHAAgH;gBAChH,IAAM,KAAK,GAAG,cAAc;qBACzB,GAAG,CAAC,UAAC,IAAI,EAAE,KAAK;oBACf,4BAAY,IAAI,IAAE,KAAK,OAAA,IAAG;gBAC5B,CAAC,CAAC;qBACD,MAAM,CACL,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,MAAM,IAAI,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,OAAO,EAAnH,CAAmH,CAC9H;qBACA,MAAM,CAAC,UAAA,MAAM,IAAI,OAAA,KAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC,iBAAiB,EAAE,KAAK,YAAY,EAAjE,CAAiE,CAAC,CAAC;gBAEvF,yCAAyC;gBACzC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;oBACtB,gCAAgC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;iBACnD;aACF;YAED,wBAAwB;YACxB,IAAI,CAAC,eAAe,CAAC,oBAAoB,EAAE,gCAAgC,EAAE,wBAAwB,CAAC,CAAC;QACzG,CAAC;QAED;;;;WAIG;QACK,qDAAkC,GAA1C,UAA2C,YAAoB;YAA/D,iBAyDC;YAxDO,IAAA,eAAmF,EAAjF,4CAAmB,EAAE,gEAA6B,EAAE,kCAAc,CAAgB;YAE1F,YAAY,GAAG,IAAI,CAAC,sBAAsB,CAAC,YAAY,CAAC,CAAC;YACzD,IAAI,IAAI,CAAC,KAAK,CAAC,YAAY,KAAK,IAAI,EAAE;gBACpC,qDAAqD;gBACrD,4EAA4E;gBAC5E,2EAA2E;gBAC3E,wFAAwF;gBACxF,6DAA6D;gBAC7D,IAAI,YAAY,KAAK,EAAE,EAAE;oBACvB,mDAAmD;oBACnD,4DAA4D;oBAC5D,+DAA+D;oBAC/D,iEAAiE;oBACjE,IAAI,IAAI,CAAC,wCAAwC,KAAK,SAAS,EAAE;wBAC/D,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,wCAAwC,CAAC,CAAC;wBACxE,IAAI,CAAC,wCAAwC,GAAG,SAAS,CAAC;wBAC1D,YAAY,GAAG,IAAI,CAAC,kBAAkB,CAAC,mBAAmB,CAAC,GAAG,YAAY,CAAC;qBAC5E;oBAED,IAAM,oBAAoB,GAAW,YAAY,CAAC;oBAClD,YAAY,GAAG,YAAY,CAAC,iBAAiB,EAAE,CAAC;oBAEhD,2GAA2G;oBAC3G,IAAM,KAAK,GAAG,cAAc;yBACzB,GAAG,CAAC,UAAC,IAAI,EAAE,CAAC;wBACX,4BAAY,IAAI,IAAE,KAAK,EAAE,CAAC,IAAG;oBAC/B,CAAC,CAAC;yBACD,MAAM,CACL,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,MAAM,IAAI,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,OAAO,EAAnH,CAAmH,CAC9H;yBACA,MAAM,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,EAA3D,CAA2D,CAAC,CAAC;oBAEjF,yCAAyC;oBACzC,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;wBACpB,IAAI,CAAC,eAAe,CAAC,oBAAoB,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;qBAC5F;oBAED,uEAAuE;oBACvE,IAAI,CAAC,wCAAwC,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC;wBACrE,KAAI,CAAC,wCAAwC,GAAG,SAAS,CAAC;oBAC5D,CAAC,EAAE,kCAAkC,CAAC,CAAC;oBACvC,OAAO;iBACR;aACF;YAED,6FAA6F;YAC7F,kGAAkG;YAClG,4CAA4C;YAC5C,IAAM,KAAK,GAAG,6BAA6B,IAAI,CAAC,CAAC,CAAC,CAAC,6BAA6B,CAAC,CAAC,CAAC,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAEjH,iDAAiD;YACjD,kDAAkD;YAClD,oDAAoD;YACpD,6DAA6D;YAC7D,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;QACvC,CAAC;QAEO,yCAAsB,GAA9B;YACE,OAAO,IAAI,CAAC,KAAK,CAAC,eAAe,IAAI,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAClH,CAAC;QAED;;;;;;;WAOG;QACK,0CAAuB,GAA/B,UAAgC,KAAa,EAAE,eAAgC;YACrE,IAAA,0CAAc,CAAgB;YAEtC,IAAI,QAAQ,GAAG,KAAK,GAAG,eAAe,CAAC;YAEvC,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC;YAEtE,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,QAAQ,CAAC,EAAE;gBACtD,OAAO,CAAC,CAAC,CAAC;aACX;YAED,IAAM,MAAM,GAAoB,cAAc,CAAC,QAAQ,CAAC,CAAC;YAEzD,uCAAuC;YACvC,IAAI,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,MAAM,IAAI,MAAM,CAAC,QAAQ,KAAK,qDAA4B,CAAC,OAAO,EAAE;gBACvH,qDAAqD;gBACrD,IACE,eAAe,KAAK,eAAe,CAAC,IAAI;oBACxC,CAAC,CAAC,QAAQ,GAAG,CAAC,IAAI,eAAe,GAAG,eAAe,CAAC,IAAI,CAAC;wBACvD,CAAC,QAAQ,IAAI,CAAC,IAAI,QAAQ,GAAG,cAAc,CAAC,MAAM,IAAI,eAAe,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC,EAChG;oBACA,QAAQ,GAAG,IAAI,CAAC,uBAAuB,CAAC,QAAQ,EAAE,eAAe,CAAC,CAAC;iBACpE;qBAAM;oBACL,2EAA2E;oBAC3E,OAAO,KAAK,CAAC;iBACd;aACF;YAED,qDAAqD;YACrD,OAAO,QAAQ,CAAC;QAClB,CAAC;QAED;;;;;WAKG;QACK,oCAAiB,GAAzB,UAA0B,KAAa,EAAE,uBAA4B,EAAE,eAAuD;YAAvD,gCAAA,EAAA,kBAAmC,eAAe,CAAC,IAAI;YACtH,IAAA,eAA2D,EAAzD,sBAAQ,EAAE,wBAAS,EAAE,gDAAqB,CAAgB;YAC1D,IAAA,0CAAc,CAAgB;YAChC,IAAA,4CAAe,CAAgB;YAErC,IAAI,CAAC,eAAe,EAAE;gBACpB,eAAe,GAAG,EAAE,CAAC;aACtB;YAED,6DAA6D;YAC7D,sCAAsC;YACtC,KAAK,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,eAAe,CAAC,CAAC;YAE7D,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,KAAK,CAAC,EAAE;gBACnD,OAAO;aACR;YAED,4DAA4D;YAC5D,yBAAyB;YACzB,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,KAAK,CAAC,IAAI,eAAe,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,EAAE;gBAC1H,IAAM,MAAM,GAAoB,cAAc,CAAC,KAAK,CAAC,CAAC;gBACtD,IAAI,CAAC,MAAM,EAAE;oBACX,OAAO;iBACR;gBACD,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE;oBAC1B,wFAAwF;oBACxF,2DAA2D;oBAC3D,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAC,QAAQ,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,eAAe,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;oBACxG,IAAI,MAAM,CAAC,QAAQ,IAAI,eAAe,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;wBACzD,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;qBAC7B;yBAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,IAAI,eAAe,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;wBAClE,eAAe,GAAG,eAAe,CAAC,MAAM,CAAC,UAAC,KAAa,IAAK,OAAA,KAAK,KAAK,KAAK,EAAf,CAAe,CAAC,CAAC;qBAC9E;iBACF;qBAAM;oBACL,eAAe,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;iBAC5B;gBAED,0BAA0B;gBAC1B,IAAI,CAAC,QAAQ,CAAC;oBACZ,eAAe,EAAE,eAAe;iBACjC,CAAC,CAAC;gBAEH,qDAAqD;gBACrD,IAAI,IAAI,CAAC,gBAAgB,IAAI,qBAAqB,EAAE;oBAClD,qBAAqB,EAAE,CAAC;oBACxB,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC;iBAC/B;gBAED,IAAI,QAAQ,EAAE;oBACZ,QAAQ,CAAC,uBAAuB,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC;iBAC7D;gBAED,IAAI,SAAS,EAAE;oBACb,SAAS,CAAC,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,uBAAuB,CAAC,CAAC;iBAC9D;gBAED,mCAAmC;gBACnC,gCAAgC;gBAChC,IAAI,CAAC,iBAAiB,EAAE,CAAC;aAC1B;QACH,CAAC;QAwFD;;WAEG;QACK,sCAAmB,GAA3B,UAA4B,uBAA4B;YAChD,IAAA,eAAiE,EAA/D,sBAAQ,EAAE,wBAAS,EAAE,gCAAa,EAAE,8BAAY,CAAgB;YAClE,IAAA,eAAyH,EAAvH,4CAAmB,EAAE,gEAA6B,EAAE,kCAAc,EAAE,8EAAoC,CAAgB;YAC1H,IAAA,4CAAe,CAAgB;YAErC,wCAAwC;YACxC,mDAAmD;YACnD,IAAI,IAAI,CAAC,2BAA2B,EAAE;gBACpC,OAAO;aACR;YAED,8CAA8C;YAC9C,IAAI,aAAa,EAAE;gBACjB,+EAA+E;gBAC/E,0EAA0E;gBAC1E,IAAI,mBAAmB,KAAK,IAAI,IAAI,mBAAmB,KAAK,SAAS,EAAE;oBACrE,qEAAqE;oBACrE,IAAI,oCAAoC,IAAI,CAAC,EAAE;wBAC7C,IAAI,CAAC,iBAAiB,CAAC,oCAAoC,EAAE,uBAAuB,CAAC,CAAC;wBACtF,IAAI,CAAC,iBAAiB,EAAE,CAAC;qBAC1B;oBAED,OAAO;iBACR;gBAED,gDAAgD;gBAChD,IAAI,IAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,6BAA6B,CAAC,EAAE;oBAC1E,IAAM,iBAAiB,GAAW,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,6BAA6B,CAAC,CAAC,CAAC,iBAAiB,EAAE,CAAC;oBAE1H,8FAA8F;oBAC9F,2FAA2F;oBAC3F,8DAA8D;oBAC9D,sFAAsF;oBACtF,IACE,mBAAmB,CAAC,iBAAiB,EAAE,KAAK,iBAAiB;wBAC7D,CAAC,CAAC,YAAY;4BACZ,iBAAiB,CAAC,OAAO,CAAC,mBAAmB,CAAC,iBAAiB,EAAE,CAAC,KAAK,CAAC;4BACxE,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO;gCACrB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,eAAe;gCACtC,mBAAmB,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,YAAa,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,cAAe,CAAC;oCAC1G,iBAAiB,CAAC,MAAM,CAAC,CAAC;4BAC9B,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO;gCACrB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,YAAY;gCACnC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,iBAAiB,EAAE,KAAK,iBAAiB,CAAC,CAAC,EACzF;wBACA,IAAI,CAAC,iBAAiB,CAAC,6BAA6B,EAAE,uBAAuB,CAAC,CAAC;wBAC/E,IAAI,CAAC,iBAAiB,EAAE,CAAC;wBACzB,OAAO;qBACR;iBACF;gBAED,IAAI,QAAQ,IAAI,SAAS,EAAE;oBACzB,IAAI,QAAQ,EAAE;wBACZ,kCAAkC;wBAClC,QAAQ,CAAC,uBAAuB,EAAE,SAAS,EAAE,SAAS,EAAE,mBAAmB,CAAC,CAAC;qBAC9E;oBACD,IAAI,SAAS,EAAE;wBACb,mCAAmC;wBACnC,SAAS,CAAC,SAAS,EAAE,SAAS,EAAE,mBAAmB,EAAE,uBAAuB,CAAC,CAAC;qBAC/E;iBACF;qBAAM;oBACL,gDAAgD;oBAChD,IAAM,SAAS,GAAoB;wBACjC,GAAG,EAAE,mBAAmB,IAAI,iBAAK,EAAE;wBACnC,IAAI,EAAE,IAAI,CAAC,kBAAkB,CAAC,mBAAmB,CAAC;qBACnD,CAAC;oBACF,IAAM,UAAU,GAA0B,cAAc,SAAE,SAAS,EAAC,CAAC;oBACrE,IAAI,eAAe,EAAE;wBACnB,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE;4BAC3B,eAAe,GAAG,EAAE,CAAC;yBACtB;wBACD,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;qBAC7C;oBACD,IAAI,CAAC,QAAQ,CAAC;wBACZ,cAAc,EAAE,UAAU;wBAC1B,eAAe,EAAE,eAAe;qBACjC,CAAC,CAAC;iBACJ;aACF;iBAAM,IAAI,6BAA6B,IAAI,CAAC,EAAE;gBAC7C,8DAA8D;gBAC9D,6BAA6B;gBAC7B,IAAI,CAAC,iBAAiB,CAAC,6BAA6B,EAAE,uBAAuB,CAAC,CAAC;aAChF;iBAAM,IAAI,oCAAoC,IAAI,CAAC,EAAE;gBACpD,kEAAkE;gBAClE,IAAI,CAAC,iBAAiB,CAAC,oCAAoC,EAAE,uBAAuB,CAAC,CAAC;aACvF;YAED,kCAAkC;YAClC,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAC3B,CAAC;QA6CO,yCAAsB,GAA9B;YACE,2EAA2E;YAC3E,0EAA0E;YAC1E,8EAA8E;YAC9E,gBAAgB;YAChB,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;QAC7B,CAAC;QAuCD,mBAAmB;QACX,mCAAgB,GAAxB,UAAyB,IAAqB;YACpC,IAAA,kBAAK,EAAE,cAAG,CAAU;YAE5B,IAAI,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE;gBACtB,OAAO,6BAAK,IAAI,EAAC,WAAW,EAAC,GAAG,EAAE,GAAG,EAAE,SAAS,EAAE,IAAI,CAAC,WAAW,CAAC,OAAO,GAAI,CAAC;aAChF;YACD,OAAO,IAAI,CAAC;QACd,CAAC;QAEO,gCAAa,GAArB,UAAsB,IAAqB;YACjC,IAAA,8BAA4C,EAA5C,iEAA4C,CAAgB;YAEpE,OAAO,CACL,6BAAK,GAAG,EAAE,IAAI,CAAC,GAAG,EAAE,SAAS,EAAE,IAAI,CAAC,WAAW,CAAC,MAAM,IACnD,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,sBAAsB,CAAC,CAC9C,CACP,CAAC;QACJ,CAAC;QAwED;;;;;;;;;;;aAWK;QACG,oCAAiB,GAAzB,UAA0B,KAAyB;YACzC,IAAA,sFAAoC,CAAgB;YAE5D,sEAAsE;YACtE,gEAAgE;YAChE,IAAI,oCAAoC,KAAK,WAAW,CAAC,QAAQ,EAAE;gBACjE,OAAO,KAAK,CAAC;aACd;YAED,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,IAAI,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,yBAAyB,CAAC,KAAK,KAAK,EAAE;gBACtG,OAAO,IAAI,CAAC;aACb;YAED,IAAI,kBAAkB,GAAG,CAAC,CAAC,CAAC;YAC5B,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,IAAI,KAAK,KAAK,SAAS,IAAI,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE;gBAC/E,kBAAkB,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aAChE;YACD,OAAO,kBAAkB,IAAI,CAAC,CAAC;QACjC,CAAC;QAED;;;;WAIG;QACK,2CAAwB,GAAhC,UAAiC,0BAAmC;YAC5D,IAAA,eAAyG,EAAvG,8EAAoC,EAAE,gEAA6B,EAAE,4CAAmB,CAAgB;YAEhH,OAAO,oCAAoC,IAAI,CAAC;gBAC9C,CAAC,CAAC,oCAAoC;gBACtC,CAAC,CAAC,6BAA6B,IAAI,CAAC;oBAClC,CAAC,0BAA0B,IAAI,CAAC,mBAAmB,KAAK,IAAI,IAAI,mBAAmB,KAAK,SAAS,CAAC,CAAC;oBACrG,CAAC,CAAC,6BAA6B;oBAC/B,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW;wBACxB,CAAC,CAAC,CAAC;wBACH,CAAC,CAAC,IAAI,CAAC,sBAAsB,EAAE,CAAC;QACpC,CAAC;QAmBD;;WAEG;QACK,kCAAe,GAAvB;YACQ,IAAA,eAAoD,EAAlD,kCAAc,EAAE,4CAAmB,CAAgB;YAErD,IAAA,eAAmE,EAAjE,gEAA6B,EAAE,4CAAmB,CAAgB;YAE1E,IAAI,cAAc,EAAE;gBAClB,gCAAgC;gBAChC,cAAc,CACZ,6BAA6B,IAAI,CAAC,IAAI,mBAAmB,KAAK,EAAE,CAAC,CAAC,CAAC,6BAA6B,CAAC,CAAC,CAAC,IAAI,CAAC,sBAAsB,EAAE,CACjI,CAAC;aACH;iBAAM,IAAI,IAAI,CAAC,gBAAgB,CAAC,OAAO,IAAI,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,YAAY,EAAE;gBACtF,8CAA8C;gBAC9C,IAAI,mBAAmB,EAAE;oBACvB,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,YAAY,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;iBACjE;qBAAM;oBACL,IAAI,UAAU,GAAG,IAAI,CAAC;oBAEtB,IAAI,IAAI,CAAC,aAAa,CAAC,OAAO,IAAI,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,YAAY,EAAE;wBACzE,IAAM,oBAAoB,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,YAAY,CAAC,qBAAqB,EAAE,CAAC;wBAC7F,IAAM,mBAAmB,GAAG,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,YAAY,CAAC,qBAAqB,EAAE,CAAC;wBAE/F,6DAA6D;wBAC7D,IACE,oBAAoB,CAAC,GAAG,IAAI,mBAAmB,CAAC,GAAG;4BACnD,oBAAoB,CAAC,GAAG,GAAG,oBAAoB,CAAC,MAAM,IAAI,mBAAmB,CAAC,GAAG,GAAG,mBAAmB,CAAC,MAAM,EAC9G;4BACA,OAAO;yBACR;wBAED,yFAAyF;wBACzF,IAAI,oBAAoB,CAAC,GAAG,GAAG,oBAAoB,CAAC,MAAM,IAAI,mBAAmB,CAAC,GAAG,GAAG,mBAAmB,CAAC,MAAM,EAAE;4BAClH,UAAU,GAAG,KAAK,CAAC;yBACpB;qBACF;oBAED,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,YAAY,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;iBACvE;aACF;QACH,CAAC;QAOD;;;;WAIG;QACK,+BAAY,GAApB,UAAqB,IAAqB;YAA1C,iBAcC;YAbS,IAAA,oCAAW,CAAgB;YAC3B,IAAA,kBAAK,CAAU;YAEvB,OAAO,UAAC,EAAO;gBACb,WAAW,IAAI,WAAW,CAAC,EAAE,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;gBAC5C,KAAI,CAAC,iBAAiB,CAAC,KAAe,EAAE,EAAE,CAAC,CAAC;gBAC5C,IAAI,CAAC,KAAI,CAAC,KAAK,CAAC,WAAW,EAAE;oBAC3B,yDAAyD;oBACzD,KAAI,CAAC,QAAQ,CAAC;wBACZ,MAAM,EAAE,KAAK;qBACd,CAAC,CAAC;iBACJ;YACH,CAAC,CAAC;QACJ,CAAC;QAqBD;;;;;WAKG;QACK,sCAAmB,GAA3B,UAA4B,OAAsC,EAAE,YAA6C;YAC/G,IAAI,CAAC,OAAO,IAAI,CAAC,YAAY,EAAE;gBAC7B,OAAO,EAAE,CAAC;aACX;YAED,IAAM,eAAe,GAA+B,EAAE,CAAC;YACvD,OAAO,CAAC,OAAO,CAAC,UAAC,MAAuB,EAAE,KAAa;gBACrD,IAAI,MAAM,CAAC,QAAQ,EAAE;oBACnB,eAAe,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;iBAC/B;YACH,CAAC,CAAC,CAAC;oCAEQ,WAAW;gBACpB,IAAM,KAAK,GAAG,qBAAS,CAAC,OAAO,EAAE,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,GAAG,KAAK,WAAW,EAA1B,CAA0B,CAAC,CAAC;gBACvE,IAAI,KAAK,GAAG,CAAC,CAAC,EAAE;oBACd,eAAe,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;iBAC/B;YACH,CAAC;YALD,KAA0B,UAAY,EAAZ,6BAAY,EAAZ,0BAAY,EAAZ,IAAY;gBAAjC,IAAM,WAAW,qBAAA;wBAAX,WAAW;aAKrB;YAED,OAAO,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC;iBAChC,GAAG,CAAC,MAAM,CAAC;iBACX,IAAI,EAAE,CAAC;QACZ,CAAC;QAED;;;;;WAKG;QACK,sCAAmB,GAA3B;YACU,IAAA,0CAAc,CAAgB;YAEtC,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAEzB,IAAM,aAAa,GAAW,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAC5D,IAAI,aAAa,GAAG,CAAC,IAAI,aAAa,GAAG,cAAc,CAAC,MAAM,EAAE;gBAC9D,IAAI,CAAC,QAAQ,CAAC;oBACZ,qBAAqB,EAAE,cAAc,CAAC,aAAa,CAAC,CAAC,IAAI;iBAC1D,CAAC,CAAC;aACJ;iBAAM,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE;gBAC9C,0CAA0C;gBAC1C,IAAI,CAAC,QAAQ,CAAC;oBACZ,qBAAqB,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK;iBAC3D,CAAC,CAAC;aACJ;QACH,CAAC;QAED;;WAEG;QACK,oCAAiB,GAAzB;YACE,IAAI,CAAC,2BAA2B,GAAG,IAAI,CAAC;YACxC,IAAI,CAAC,QAAQ,CACX;gBACE,mBAAmB,EAAE,SAAS;gBAC9B,6BAA6B,EAAE,CAAC,CAAC;gBACjC,qBAAqB,EAAE,SAAS;gBAChC,oCAAoC,EAAE,WAAW,CAAC,OAAO;aAC1D,EACD,IAAI,CAAC,wBAAwB,CAC9B,CAAC;QACJ,CAAC;QAMD;;;;;WAKG;QACK,kCAAe,GAAvB,UAAwB,mBAA4B,EAAE,6BAA0C,EAAE,qBAA8B;YAA1E,8CAAA,EAAA,iCAAyC,CAAC;YAC9F,IAAI,IAAI,CAAC,2BAA2B,EAAE;gBACpC,OAAO;aACR;YAED,IAAI,CAAC,QAAQ,CAAC;gBACZ,mBAAmB,EAAE,mBAAmB,IAAI,IAAI,CAAC,sBAAsB,CAAC,mBAAmB,CAAC;gBAC5F,6BAA6B,EAAE,6BAA6B;gBAC5D,qBAAqB,EAAE,qBAAqB;gBAC5C,oCAAoC,EAAE,WAAW,CAAC,OAAO;aAC1D,CAAC,CAAC;QACL,CAAC;QAED;;;WAGG;QACK,2CAAwB,GAAhC,UAAiC,KAAa;YACpC,IAAA,0CAAc,CAAgB;YAEtC,IAAI,KAAK,IAAI,CAAC,IAAI,KAAK,GAAG,cAAc,CAAC,MAAM,EAAE;gBAC/C,IAAM,MAAM,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;gBACrC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC;aACzF;iBAAM;gBACL,IAAI,CAAC,iBAAiB,EAAE,CAAC;aAC1B;QACH,CAAC;QAED;;;;WAIG;QACK,uDAAoC,GAA5C,UAA6C,KAAa,EAAE,eAAgC;YAClF,IAAA,0CAAc,CAAgB;YAEtC,wCAAwC;YACxC,IAAI,eAAe,KAAK,eAAe,CAAC,OAAO,IAAI,KAAK,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE;gBACrF,KAAK,GAAG,CAAC,CAAC,CAAC;aACZ;iBAAM,IAAI,eAAe,KAAK,eAAe,CAAC,QAAQ,IAAI,KAAK,IAAI,CAAC,EAAE;gBACrE,KAAK,GAAG,cAAc,CAAC,MAAM,CAAC;aAC/B;YAED,6BAA6B;YAC7B,IAAM,WAAW,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,eAAe,CAAC,CAAC;YAEzE,mDAAmD;YACnD,oEAAoE;YACpE,qEAAqE;YACrE,0DAA0D;YAC1D,IAAI,KAAK,KAAK,WAAW,EAAE;gBACzB,IAAI,eAAe,KAAK,eAAe,CAAC,OAAO,EAAE;oBAC/C,KAAK,GAAG,IAAI,CAAC,uBAAuB,CAAC,CAAC,CAAC,EAAE,eAAe,CAAC,CAAC;iBAC3D;qBAAM,IAAI,eAAe,KAAK,eAAe,CAAC,QAAQ,EAAE;oBACvD,KAAK,GAAG,IAAI,CAAC,uBAAuB,CAAC,cAAc,CAAC,MAAM,EAAE,eAAe,CAAC,CAAC;iBAC9E;aACF;iBAAM;gBACL,KAAK,GAAG,WAAW,CAAC;aACrB;YAED,IAAI,IAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,KAAK,CAAC,EAAE;gBAClD,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;aACtC;QACH,CAAC;QAEO,6CAA0B,GAAlC,UAAmC,SAAyB;YAClD,IAAA,wDAAqB,CAAgB;YAE7C,IAAI,CAAC,qBAAqB,EAAE;gBAC1B,OAAO;aACR;YAEK,IAAA,eAAyH,EAAvH,4CAAmB,EAAE,kCAAc,EAAE,gEAA6B,EAAE,8EAAoC,CAAgB;YAEhI,IAAI,eAAe,GAAuB,SAAS,CAAC;YACpD,IAAI,eAAe,GAAuB,SAAS,CAAC;YAEpD,IACE,oCAAoC,KAAK,SAAS,CAAC,oCAAoC;gBACvF,IAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,oCAAoC,CAAC,EAC7E;gBACA,mDAAmD;gBACnD,eAAe,GAAG,oCAAoC,CAAC;aACxD;iBAAM,IACL,6BAA6B,KAAK,SAAS,CAAC,6BAA6B;gBACzE,IAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,6BAA6B,CAAC,EACtE;gBACA,qEAAqE;gBACrE,eAAe,GAAG,6BAA6B,CAAC;aACjD;iBAAM,IAAI,mBAAmB,KAAK,SAAS,CAAC,mBAAmB,IAAI,mBAAmB,KAAK,EAAE,EAAE;gBAC9F,uEAAuE;gBACvE,eAAe,GAAG,mBAAmB,CAAC;aACvC;YAED,iHAAiH;YACjH,IAAI,eAAe,KAAK,SAAS,IAAI,eAAe,KAAK,SAAS,IAAI,IAAI,CAAC,gBAAgB,EAAE;gBAC3F,qBAAqB,CAAC,eAAe,KAAK,SAAS,CAAC,CAAC,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,SAAS,EAAE,eAAe,EAAE,eAAe,CAAC,CAAC;gBACrI,IAAI,CAAC,gBAAgB,GAAG,eAAe,KAAK,SAAS,IAAI,eAAe,KAAK,SAAS,CAAC;aACxF;QACH,CAAC;QAED;;WAEG;QACK,+CAA4B,GAApC,UAAqC,MAAe,EAAE,oBAA6B;YACjF,IAAI,CAAC,qBAAqB,GAAG,oBAAoB,CAAC;YAClD,IAAI,CAAC,QAAQ,CAAC;gBACZ,MAAM,EAAE,MAAM;aACf,CAAC,CAAC;QACL,CAAC;QAmLD;;WAEG;QACK,+BAAY,GAApB,UAAqB,EAA+C;YAClE,OAAO,EAAE,CAAC,KAAK,KAAK,oBAAQ,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,KAAK,MAAM,CAAC;QACxD,CAAC;QA+CO,sCAAmB,GAA3B,UAA4B,KAAa;YACvC,IAAI,IAAI,CAAC,uBAAuB,EAAE,EAAE;gBAClC,OAAO;aACR;YAED,IAAI,CAAC,QAAQ,CAAC;gBACZ,oCAAoC,EAAE,KAAK;aAC5C,CAAC,CAAC;QACL,CAAC;QAEO,qCAAkB,GAA1B,UAA2B,KAAa;YACtC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;YAE1B,IAAI,CAAC,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,KAAK,CAAC,oCAAoC,KAAK,KAAK,EAAE;gBACpF,OAAO;aACR;YAED,IAAI,CAAC,QAAQ,CAAC;gBACZ,oCAAoC,EAAE,KAAK;aAC5C,CAAC,CAAC;QACL,CAAC;QAkBO,0CAAuB,GAA/B;YACE,OAAO,CAAC,IAAI,CAAC,aAAa,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC;QACpD,CAAC;QAED;;;;WAIG;QACK,2CAAwB,GAAhC,UAAiC,EAAsD;YACrF,iDAAiD;YACjD,8CAA8C;YAC9C,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;gBACvB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;oBACrB,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;iBAClC;gBAED,qDAAqD;gBACrD,6DAA6D;gBAC7D,IACE,EAAE,KAAK,IAAI;oBACX,EAAE,CAAC,KAAK,KAAK,oBAAQ,CAAC,GAAG;oBACzB,EAAE,CAAC,KAAK,KAAK,oBAAQ,CAAC,MAAM;oBAC5B,CAAC,EAAE,CAAC,KAAK,GAAG,GAAG,CAAC,QAAQ,IAAI,EAAE,CAAC,KAAK,GAAG,GAAG,CAAC,CAAC,SAAS,EACrD;oBACA,EAAE,CAAC,eAAe,EAAE,CAAC;oBACrB,EAAE,CAAC,cAAc,EAAE,CAAC;iBACrB;aACF;QACH,CAAC;QA2CO,8CAA2B,GAAnC;YAAA,iBAaC;YAZC,kFAAkF;YAClF,+CAA+C;YAC/C,IAAI,IAAI,CAAC,mBAAmB,KAAK,SAAS,EAAE;gBAC1C,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;gBACnD,IAAI,CAAC,mBAAmB,GAAG,SAAS,CAAC;aACtC;YACD,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;YAE7B,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC;gBAChD,KAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC;gBAC9B,KAAI,CAAC,mBAAmB,GAAG,SAAS,CAAC;YACvC,CAAC,EAAE,cAAc,CAAC,CAAC;QACrB,CAAC;QAED;;;WAGG;QACK,wCAAqB,GAA7B;YACU,IAAA,8DAAkD,CAAgB;YAC1E,OAAO,0CAAwB,CAAC,IAAI,CAAC,KAAK,CAAC,KAAM,EAAE,2BAA2B,CAAC,CAAC;QAClF,CAAC;QAED;;;WAGG;QACK,0CAAuB,GAA/B,UAAgC,IAAqB;YAC3C,IAAA,2DAA+C,CAAgB;YAC/D,IAAA,0CAAoC,CAAU;YAEtD,OAAO,iCAAe,CAAC,IAAI,CAAC,KAAK,CAAC,KAAM,EAAE,yBAAyB,EAAE,4BAA4B,EAAE,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC;QAClI,CAAC;QAED;;;WAGG;QACK,6CAA0B,GAAlC;YACE,IAAI,cAAc,GAChB,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,eAAe,IAAI,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,MAAM,IAAI,CAAC;gBACvF,CAAC,CAAC,IAAI,CAAC,GAAG,GAAG,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC;gBACpD,CAAC,CAAC,SAAS,CAAC;YAChB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,IAAI,IAAI,CAAC,KAAK,CAAC,6BAA6B,KAAK,CAAC,CAAC,EAAE;gBAC9F,cAAc,GAAG,IAAI,CAAC,GAAG,GAAG,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,6BAA6B,CAAC;aAChF;YACD,OAAO,cAAc,CAAC;QACxB,CAAC;QAED;;;;WAIG;QACK,4CAAyB,GAAjC;YACE,IAAM,YAAY,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,YAAY,KAAK,IAAI,CAAC;YAC9E,OAAO,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;QAChF,CAAC;QAEO,mCAAgB,GAAxB,UAAyB,IAAqB;YAC5C,OAAO,IAAI,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,KAAK,CAAC,6BAA6B,CAAC;QACzE,CAAC;QAED;;;;;;WAMG;QACK,4CAAyB,GAAjC,UACE,kBAA4E,EAC5E,WAAqE;YAErE,IAAM,YAAY,GAAwB,IAAI,CAAC,kBAAkB,CAAC,kBAAkB,CAAC,CAAC;YACtF,IAAI,YAAY,CAAC,MAAM,EAAE;gBACvB,OAAO,YAAY,CAAC;aACrB;YACD,OAAO,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;QAC9C,CAAC;QAEO,qCAAkB,GAA1B,UAA2B,WAAqE;YAC9F,IAAI,WAAW,KAAK,SAAS,EAAE;gBAC7B,OAAO,EAAE,CAAC;aACX;YAED,oDAAoD;YACpD,OAAO,CAAC,WAAW,YAAY,KAAK,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAwB,CAAC;QAC7F,CAAC;QAED,2FAA2F;QAC3F,8FAA8F;QAC9F,kDAAkD;QAC1C,kCAAe,GAAvB,UAAwB,IAAqB;YAC3C,OAAO,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;QAChF,CAAC;QAEO,qCAAkB,GAA1B,UAA2B,KAAc;YACvC,OAAO,KAAK,IAAI,EAAE,CAAC;QACrB,CAAC;QAEO,yCAAsB,GAA9B,UAA+B,KAAa;YAC1C,yCAAyC;YACzC,OAAO,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;QAC7C,CAAC;QAz4Da,qBAAY,GAAmB;YAC3C,OAAO,EAAE,EAAE;YACX,aAAa,EAAE,KAAK;YACpB,YAAY,EAAE,IAAI;YAClB,eAAe,EAAE,EAAE,QAAQ,EAAE,aAAa,EAAE;SAC7C,CAAC;QANS,QAAQ;YADpB,wBAAY,CAAC,UAAU,EAAE,CAAC,OAAO,EAAE,QAAQ,CAAC,EAAE,IAAI,CAAC;WACvC,QAAQ,CA24DpB;QAAD,eAAC;KAAA,AA34DD,CAA8B,yBAAa,GA24D1C;IA34DY,4BAAQ","sourcesContent":["import * as React from 'react';\r\nimport { Autofill, IAutofill } from '../Autofill/index';\r\nimport {\r\n  BaseComponent,\r\n  css,\r\n  customizable,\r\n  divProperties,\r\n  findElementRecursive,\r\n  findIndex,\r\n  focusAsync,\r\n  getId,\r\n  getNativeProps,\r\n  isIOS,\r\n  isMac,\r\n  KeyCodes,\r\n  shallowCompare,\r\n  mergeAriaAttributeValues\r\n} from '../../Utilities';\r\nimport { Callout } from '../../Callout';\r\nimport { Checkbox } from '../../Checkbox';\r\nimport { CommandButton, IButtonStyles, IconButton } from '../../Button';\r\nimport { DirectionalHint } from '../../common/DirectionalHint';\r\nimport { getCaretDownButtonStyles, getOptionStyles, getStyles } from './ComboBox.styles';\r\nimport { getClassNames, getComboBoxOptionClassNames, IComboBoxClassNames } from './ComboBox.classNames';\r\nimport { IComboBoxOption, IComboBoxOptionStyles, IComboBoxProps } from './ComboBox.types';\r\nimport { KeytipData } from '../../KeytipData';\r\nimport { Label } from '../../Label';\r\nimport { SelectableOptionMenuItemType } from '../../utilities/selectableOption/SelectableOption.types';\r\n\r\nexport interface IComboBoxState {\r\n  /** The open state */\r\n  isOpen?: boolean;\r\n\r\n  /** The currently selected indices */\r\n  selectedIndices?: number[];\r\n\r\n  /** The focused state of the comboBox */\r\n  focused?: boolean;\r\n\r\n  /** This value is used for the autocomplete hint value */\r\n  suggestedDisplayValue?: string;\r\n\r\n  /** The options currently available for the callout */\r\n  currentOptions: IComboBoxOption[];\r\n\r\n  /**\r\n   * When taking input, this will store the index that the options input matches\r\n   * (-1 if no input or match)\r\n   */\r\n  currentPendingValueValidIndex: number;\r\n\r\n  /**\r\n   * Stores the hovered over value in the dropdown\r\n   * (used for styling the options without updating the input)\r\n   */\r\n  currentPendingValueValidIndexOnHover: number;\r\n\r\n  /** When taking input, this will store the actual text that is being entered */\r\n  currentPendingValue?: string;\r\n}\r\n\r\nenum SearchDirection {\r\n  backward = -1,\r\n  none = 0,\r\n  forward = 1\r\n}\r\n\r\nenum HoverStatus {\r\n  /** Used when the user was hovering and has since moused out of the menu items */\r\n  clearAll = -2,\r\n  /** Default \"normal\" state, when no hover has happened or a hover is in progress */\r\n  default = -1\r\n}\r\n\r\nconst ScrollIdleDelay = 250 /* ms */;\r\nconst TouchIdleDelay = 500; /* ms */\r\n\r\n/**\r\n * This is used to clear any pending autocomplete text (used when autocomplete is true and\r\n * allowFreeform is false)\r\n */\r\nconst ReadOnlyPendingAutoCompleteTimeout = 1000 /* ms */;\r\n\r\ninterface IComboBoxOptionWrapperProps extends IComboBoxOption {\r\n  /** True if the option is currently selected */\r\n  isSelected: boolean;\r\n\r\n  /**\r\n   * A function that returns the children of the OptionWrapper. We pass this in as a function to ensure that\r\n   * children methods don't get called unnecessarily if the component doesn't need to be updated. This leads\r\n   * to a significant performance increase in ComboBoxes with many options and/or complex onRenderOption functions\r\n   */\r\n  render: () => JSX.Element;\r\n}\r\n\r\n/**\r\n * Internal class that is used to wrap all ComboBox options.\r\n * This is used to customize when we want to rerender components,\r\n * so we don't rerender every option every time render is executed.\r\n */\r\nclass ComboBoxOptionWrapper extends React.Component<IComboBoxOptionWrapperProps, {}> {\r\n  public render(): React.ReactNode {\r\n    return this.props.render();\r\n  }\r\n\r\n  public shouldComponentUpdate(newProps: IComboBoxOptionWrapperProps): boolean {\r\n    // The render function will always be different, so we ignore that prop\r\n    return !shallowCompare({ ...this.props, render: undefined }, { ...newProps, render: undefined });\r\n  }\r\n}\r\n\r\n@customizable('ComboBox', ['theme', 'styles'], true)\r\nexport class ComboBox extends BaseComponent<IComboBoxProps, IComboBoxState> {\r\n  public static defaultProps: IComboBoxProps = {\r\n    options: [],\r\n    allowFreeform: false,\r\n    autoComplete: 'on',\r\n    buttonIconProps: { iconName: 'ChevronDown' }\r\n  };\r\n\r\n  private _root = React.createRef<HTMLDivElement>();\r\n\r\n  /** The input aspect of the comboBox */\r\n  private _autofill = React.createRef<IAutofill>();\r\n\r\n  /** The wrapping div of the input and button */\r\n  private _comboBoxWrapper = React.createRef<HTMLDivElement>();\r\n\r\n  /** The callout element */\r\n  private _comboBoxMenu = React.createRef<HTMLDivElement>();\r\n\r\n  /** The menu item element that is currently selected */\r\n  private _selectedElement = React.createRef<HTMLSpanElement>();\r\n\r\n  /** The base id for the comboBox */\r\n  private _id: string;\r\n\r\n  /**\r\n   * After a character is inserted when autocomplete is true and allowFreeform is false,\r\n   * remember the task that will clear the pending string of characters.\r\n   */\r\n  private _lastReadOnlyAutoCompleteChangeTimeoutId: number | undefined;\r\n\r\n  /** Promise used when resolving the comboBox options */\r\n  private _currentPromise: PromiseLike<IComboBoxOption[]>;\r\n\r\n  /** The current visible value sent to the auto fill on render */\r\n  private _currentVisibleValue: string | undefined;\r\n  private _classNames: IComboBoxClassNames;\r\n  private _isScrollIdle: boolean;\r\n  private _hasPendingValue: boolean;\r\n  private _scrollIdleTimeoutId: number | undefined;\r\n  private _processingTouch: boolean;\r\n  private _lastTouchTimeoutId: number | undefined;\r\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\r\n  private _lastKeyDownWasAltOrMeta: boolean | undefined;\r\n\r\n  /**\r\n   * Determines if we should be setting focus back to the input when the menu closes.\r\n   * The general rule of thumb is if the menu was launched via the keyboard focus should go back\r\n   * to the input, if it was dropped via the mouse focus should not be forced back to the input.\r\n   */\r\n  private _focusInputAfterClose: boolean;\r\n\r\n  /** Flag for when we get the first mouseMove */\r\n  private _gotMouseMove: boolean;\r\n\r\n  private _processingClearPendingInfo: boolean;\r\n\r\n  constructor(props: IComboBoxProps) {\r\n    super(props);\r\n\r\n    this._warnMutuallyExclusive({\r\n      defaultSelectedKey: 'selectedKey',\r\n      text: 'defaultSelectedKey',\r\n      value: 'defaultSelectedKey',\r\n      selectedKey: 'value',\r\n      dropdownWidth: 'useComboBoxAsMenuWidth'\r\n    });\r\n\r\n    this._warnDeprecations({\r\n      value: 'text',\r\n      onChanged: 'onChange'\r\n    });\r\n\r\n    this._id = props.id || getId('ComboBox');\r\n    const selectedKeys: string[] | number[] = this._buildDefaultSelectedKeys(props.defaultSelectedKey, props.selectedKey);\r\n\r\n    this._isScrollIdle = true;\r\n    this._processingTouch = false;\r\n    this._gotMouseMove = false;\r\n    this._processingClearPendingInfo = false;\r\n\r\n    const initialSelectedIndices: number[] = this._getSelectedIndices(props.options, selectedKeys);\r\n\r\n    this.state = {\r\n      isOpen: false,\r\n      selectedIndices: initialSelectedIndices,\r\n      focused: false,\r\n      suggestedDisplayValue: undefined,\r\n      currentOptions: this.props.options,\r\n      currentPendingValueValidIndex: -1,\r\n      currentPendingValue: undefined,\r\n      currentPendingValueValidIndexOnHover: HoverStatus.default\r\n    };\r\n  }\r\n\r\n  public componentDidMount(): void {\r\n    if (this._comboBoxWrapper.current) {\r\n      // hook up resolving the options if needed on focus\r\n      this._events.on(this._comboBoxWrapper.current, 'focus', this._onResolveOptions, true);\r\n      if ('onpointerdown' in this._comboBoxWrapper.current) {\r\n        // For ComboBoxes, touching anywhere in the combo box should drop the dropdown, including the input element.\r\n        // This gives more hit target space for touch environments. We're setting the onpointerdown here, because React\r\n        // does not support Pointer events yet.\r\n        this._events.on(this._comboBoxWrapper.current, 'pointerdown', this._onPointerDown, true);\r\n      }\r\n    }\r\n  }\r\n\r\n  public componentWillReceiveProps(newProps: IComboBoxProps): void {\r\n    // Update the selectedIndex and currentOptions state if\r\n    // the selectedKey, value, or options have changed\r\n    if (\r\n      newProps.selectedKey !== this.props.selectedKey ||\r\n      newProps.text !== this.props.text ||\r\n      newProps.value !== this.props.value ||\r\n      newProps.options !== this.props.options\r\n    ) {\r\n      const selectedKeys: string[] | number[] = this._buildSelectedKeys(newProps.selectedKey);\r\n      const indices: number[] = this._getSelectedIndices(newProps.options, selectedKeys);\r\n\r\n      this.setState({\r\n        selectedIndices: indices,\r\n        currentOptions: newProps.options\r\n      });\r\n    }\r\n  }\r\n\r\n  public componentDidUpdate(prevProps: IComboBoxProps, prevState: IComboBoxState) {\r\n    const { allowFreeform, text, value, onMenuOpen, onMenuDismissed } = this.props;\r\n    const { isOpen, focused, selectedIndices, currentPendingValueValidIndex } = this.state;\r\n\r\n    // If we are newly open or are open and the pending valid index changed,\r\n    // make sure the currently selected/pending option is scrolled into view\r\n    if (isOpen && (!prevState.isOpen || prevState.currentPendingValueValidIndex !== currentPendingValueValidIndex)) {\r\n      // Need this timeout so that the selectedElement ref is correctly updated\r\n      this._async.setTimeout(() => this._scrollIntoView(), 0);\r\n    }\r\n\r\n    // if an action is taken that put focus in the ComboBox\r\n    // and If we are open or we are just closed, shouldFocusAfterClose is set,\r\n    // but we are not the activeElement set focus on the input\r\n    if (\r\n      focused &&\r\n      (isOpen ||\r\n        (prevState.isOpen &&\r\n          !isOpen &&\r\n          this._focusInputAfterClose &&\r\n          this._autofill.current &&\r\n          document.activeElement !== this._autofill.current.inputElement))\r\n    ) {\r\n      this.focus(undefined /*shouldOpenOnFocus*/, true /*useFocusAsync*/);\r\n    }\r\n\r\n    // If we should focusAfterClose AND\r\n    //   just opened/closed the menu OR\r\n    //   are focused AND\r\n    //     updated the selectedIndex with the menu closed OR\r\n    //     are not allowing freeform OR\r\n    //     the value changed\r\n    // we need to set selection\r\n    if (\r\n      this._focusInputAfterClose &&\r\n      ((prevState.isOpen && !isOpen) ||\r\n        (focused &&\r\n          ((!isOpen &&\r\n            !this.props.multiSelect &&\r\n            prevState.selectedIndices &&\r\n            selectedIndices &&\r\n            prevState.selectedIndices[0] !== selectedIndices[0]) ||\r\n            !allowFreeform ||\r\n            text !== prevProps.text ||\r\n            value !== prevProps.value)))\r\n    ) {\r\n      this._select();\r\n    }\r\n\r\n    this._notifyPendingValueChanged(prevState);\r\n\r\n    if (isOpen && !prevState.isOpen && onMenuOpen) {\r\n      onMenuOpen();\r\n    }\r\n\r\n    if (!isOpen && prevState.isOpen && onMenuDismissed) {\r\n      onMenuDismissed();\r\n    }\r\n  }\r\n\r\n  public componentWillUnmount(): void {\r\n    super.componentWillUnmount();\r\n\r\n    // remove the eventHanlder that was added in componentDidMount\r\n    this._events.off(this._comboBoxWrapper.current);\r\n  }\r\n\r\n  // Primary Render\r\n  public render(): JSX.Element {\r\n    const id = this._id;\r\n    const {\r\n      className,\r\n      label,\r\n      disabled,\r\n      ariaLabel,\r\n      ariaDescribedBy,\r\n      required,\r\n      errorMessage,\r\n      onRenderContainer = this._onRenderContainer,\r\n      onRenderList = this._onRenderList,\r\n      onRenderItem = this._onRenderItem,\r\n      onRenderOption = this._onRenderOptionContent,\r\n      allowFreeform,\r\n      buttonIconProps,\r\n      isButtonAriaHidden = true,\r\n      styles: customStyles,\r\n      theme,\r\n      title,\r\n      keytipProps,\r\n      placeholder,\r\n      tabIndex,\r\n      autofill,\r\n      persistMenu\r\n    } = this.props;\r\n    const { isOpen, focused, suggestedDisplayValue } = this.state;\r\n    this._currentVisibleValue = this._getVisibleValue();\r\n\r\n    const divProps = getNativeProps(this.props, divProperties, ['onChange', 'value']);\r\n\r\n    const hasErrorMessage = errorMessage && errorMessage.length > 0 ? true : false;\r\n\r\n    this._classNames = this.props.getClassNames\r\n      ? this.props.getClassNames(theme!, !!isOpen, !!disabled, !!required, !!focused, !!allowFreeform, !!hasErrorMessage, className)\r\n      : getClassNames(\r\n          getStyles(theme!, customStyles),\r\n          className!,\r\n          !!isOpen,\r\n          !!disabled,\r\n          !!required,\r\n          !!focused,\r\n          !!allowFreeform,\r\n          !!hasErrorMessage\r\n        );\r\n\r\n    return (\r\n      <div {...divProps} ref={this._root} className={this._classNames.container}>\r\n        {label && (\r\n          <Label id={id + '-label'} disabled={disabled} required={required} htmlFor={id + '-input'} className={this._classNames.label}>\r\n            {label}\r\n          </Label>\r\n        )}\r\n        <KeytipData keytipProps={keytipProps} disabled={disabled}>\r\n          {(keytipAttributes: any): JSX.Element => (\r\n            <div\r\n              data-ktp-target={keytipAttributes['data-ktp-target']}\r\n              ref={this._comboBoxWrapper}\r\n              id={id + 'wrapper'}\r\n              className={this._classNames.root}\r\n            >\r\n              <Autofill\r\n                data-ktp-execute-target={keytipAttributes['data-ktp-execute-target']}\r\n                data-is-interactable={!disabled}\r\n                componentRef={this._autofill}\r\n                id={id + '-input'}\r\n                className={this._classNames.input}\r\n                type=\"text\"\r\n                onFocus={this._select}\r\n                onBlur={this._onBlur}\r\n                onKeyDown={this._onInputKeyDown}\r\n                onKeyUp={this._onInputKeyUp}\r\n                onClick={this._onAutofillClick}\r\n                onTouchStart={this._onTouchStart}\r\n                onInputValueChange={this._onInputChange}\r\n                aria-expanded={isOpen}\r\n                aria-autocomplete={this._getAriaAutoCompleteValue()}\r\n                role=\"combobox\"\r\n                readOnly={disabled || !allowFreeform}\r\n                aria-labelledby={label && id + '-label'}\r\n                aria-label={ariaLabel && !label ? ariaLabel : undefined}\r\n                aria-describedby={mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby'])}\r\n                aria-activedescendant={this._getAriaActiveDescentValue()}\r\n                aria-required={required}\r\n                aria-disabled={disabled}\r\n                aria-owns={isOpen ? id + '-list' : undefined}\r\n                spellCheck={false}\r\n                defaultVisibleValue={this._currentVisibleValue}\r\n                suggestedDisplayValue={suggestedDisplayValue}\r\n                updateValueInWillReceiveProps={this._onUpdateValueInAutofillWillReceiveProps}\r\n                shouldSelectFullInputValueInComponentDidUpdate={this._onShouldSelectFullInputValueInAutofillComponentDidUpdate}\r\n                title={title}\r\n                preventValueSelection={!focused}\r\n                placeholder={placeholder}\r\n                tabIndex={tabIndex}\r\n                {...autofill}\r\n              />\r\n              <IconButton\r\n                className={'ms-ComboBox-CaretDown-button'}\r\n                styles={this._getCaretButtonStyles()}\r\n                role=\"presentation\"\r\n                aria-hidden={isButtonAriaHidden}\r\n                data-is-focusable={false}\r\n                tabIndex={-1}\r\n                onClick={this._onComboBoxClick}\r\n                iconProps={buttonIconProps}\r\n                disabled={disabled}\r\n                checked={isOpen}\r\n              />\r\n            </div>\r\n          )}\r\n        </KeytipData>\r\n        {(persistMenu || isOpen) &&\r\n          (onRenderContainer as any)(\r\n            {\r\n              ...this.props,\r\n              onRenderList,\r\n              onRenderItem,\r\n              onRenderOption,\r\n              options: this.state.currentOptions.map((item, index) => ({ ...item, index: index }))\r\n            },\r\n            this._onRenderContainer\r\n          )}\r\n        {errorMessage && <div className={this._classNames.errorMessage}>{errorMessage}</div>}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  /**\r\n   * {@inheritdoc}\r\n   */\r\n  public focus = (shouldOpenOnFocus?: boolean, useFocusAsync?: boolean): void => {\r\n    if (this._autofill.current) {\r\n      if (useFocusAsync) {\r\n        focusAsync(this._autofill.current);\r\n      } else {\r\n        this._autofill.current.focus();\r\n      }\r\n\r\n      if (shouldOpenOnFocus) {\r\n        this.setState({\r\n          isOpen: true\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Close menu callout if it is open\r\n   */\r\n  public dismissMenu = (): void => {\r\n    const { isOpen } = this.state;\r\n    isOpen && this.setState({ isOpen: false });\r\n  };\r\n\r\n  /**\r\n   * componentWillReceiveProps handler for the auto fill component\r\n   * Checks/updates the iput value to set, if needed\r\n   * @param defaultVisibleValue - the defaultVisibleValue that got passed\r\n   *  in to the auto fill's componentWillReceiveProps\r\n   * @returns - the updated value to set, if needed\r\n   */\r\n  private _onUpdateValueInAutofillWillReceiveProps = (): string | null => {\r\n    const comboBox = this._autofill.current;\r\n\r\n    if (!comboBox) {\r\n      return null;\r\n    }\r\n\r\n    if (comboBox.value === null || comboBox.value === undefined) {\r\n      return null;\r\n    }\r\n\r\n    const visibleValue = this._normalizeToString(this._currentVisibleValue);\r\n    if (comboBox.value !== visibleValue) {\r\n      // If visibleValue is empty, make it a zero width space.\r\n      // If we did not do that, the empty string would not get used\r\n      // potentially resulting in an unexpected value being used\r\n      return visibleValue || '';\r\n    }\r\n\r\n    return comboBox.value;\r\n  };\r\n\r\n  /**\r\n   * componentDidUpdate handler for the auto fill component\r\n   *\r\n   * @param defaultVisibleValue - the current defaultVisibleValue in the auto fill's componentDidUpdate\r\n   * @param suggestedDisplayValue - the current suggestedDisplayValue in the auto fill's componentDidUpdate\r\n   * @returns - should the full value of the input be selected?\r\n   * True if the defaultVisibleValue equals the suggestedDisplayValue, false otherwise\r\n   */\r\n  private _onShouldSelectFullInputValueInAutofillComponentDidUpdate = (): boolean => {\r\n    return this._currentVisibleValue === this.state.suggestedDisplayValue;\r\n  };\r\n\r\n  /**\r\n   * Get the correct value to pass to the input\r\n   * to show to the user based off of the current props and state\r\n   * @returns the value to pass to the input\r\n   */\r\n  private _getVisibleValue = (): string | undefined => {\r\n    const { text, value, allowFreeform, autoComplete } = this.props;\r\n    const {\r\n      selectedIndices,\r\n      currentPendingValueValidIndex,\r\n      currentOptions,\r\n      currentPendingValue,\r\n      suggestedDisplayValue,\r\n      isOpen,\r\n      focused\r\n    } = this.state;\r\n\r\n    const currentPendingIndexValid = this._indexWithinBounds(currentOptions, currentPendingValueValidIndex);\r\n\r\n    // If the user passed is a value prop, use that\r\n    // unless we are open and have a valid current pending index\r\n    if (!(isOpen && currentPendingIndexValid) && (text && (currentPendingValue === null || currentPendingValue === undefined))) {\r\n      return text;\r\n    }\r\n\r\n    if (!(isOpen && currentPendingIndexValid) && (value && (currentPendingValue === null || currentPendingValue === undefined))) {\r\n      return value;\r\n    }\r\n\r\n    // Values to display in the BaseAutoFill area\r\n    const displayValues = [];\r\n\r\n    if (this.props.multiSelect) {\r\n      // Multi-select\r\n      if (focused) {\r\n        let index = -1;\r\n        if (autoComplete === 'on' && currentPendingIndexValid) {\r\n          index = currentPendingValueValidIndex;\r\n        }\r\n        displayValues.push(\r\n          currentPendingValue !== null && currentPendingValue !== undefined\r\n            ? currentPendingValue\r\n            : this._indexWithinBounds(currentOptions, index)\r\n            ? currentOptions[index].text\r\n            : ''\r\n        );\r\n      } else {\r\n        for (let idx = 0; selectedIndices && idx < selectedIndices.length; idx++) {\r\n          const index: number = selectedIndices[idx];\r\n          displayValues.push(\r\n            this._indexWithinBounds(currentOptions, index) ? currentOptions[index].text : this._normalizeToString(suggestedDisplayValue)\r\n          );\r\n        }\r\n      }\r\n    } else {\r\n      // Single-select\r\n      let index: number = this._getFirstSelectedIndex();\r\n      if (allowFreeform) {\r\n        // If we are allowing freeform and autocomplete is also true\r\n        // and we've got a pending value that matches an option, remember\r\n        // the matched option's index\r\n        if (autoComplete === 'on' && currentPendingIndexValid) {\r\n          index = currentPendingValueValidIndex;\r\n        }\r\n\r\n        // Since we are allowing freeform, if there is currently a pending value, use that\r\n        // otherwise use the index determined above (falling back to '' if we did not get a valid index)\r\n        displayValues.push(\r\n          currentPendingValue !== null && currentPendingValue !== undefined\r\n            ? currentPendingValue\r\n            : this._indexWithinBounds(currentOptions, index)\r\n            ? currentOptions[index].text\r\n            : ''\r\n        );\r\n      } else {\r\n        // If we are not allowing freeform and have a\r\n        // valid index that matches the pending value,\r\n        // we know we will need some version of the pending value\r\n        if (currentPendingIndexValid && autoComplete === 'on') {\r\n          // If autoComplete is on, return the\r\n          // raw pending value, otherwise remember\r\n          // the matched option's index\r\n          index = currentPendingValueValidIndex;\r\n          displayValues.push(this._normalizeToString(currentPendingValue));\r\n        } else {\r\n          displayValues.push(\r\n            this._indexWithinBounds(currentOptions, index) ? currentOptions[index].text : this._normalizeToString(suggestedDisplayValue)\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // If we have a valid index then return the text value of that option,\r\n    // otherwise return the suggestedDisplayValue\r\n    let displayString = '';\r\n    for (let idx = 0; idx < displayValues.length; idx++) {\r\n      if (idx > 0) {\r\n        displayString += ', ';\r\n      }\r\n      displayString += displayValues[idx];\r\n    }\r\n    return displayString;\r\n  };\r\n\r\n  /**\r\n   * Is the index within the bounds of the array?\r\n   * @param options - options to check if the index is valid for\r\n   * @param index - the index to check\r\n   * @returns - true if the index is valid for the given options, false otherwise\r\n   */\r\n  private _indexWithinBounds(options: IComboBoxOption[] | undefined, index: number): boolean {\r\n    if (!options) {\r\n      return false;\r\n    }\r\n    return index >= 0 && index < options.length;\r\n  }\r\n\r\n  /**\r\n   * Handler for typing changes on the input\r\n   * @param updatedValue - the newly changed value\r\n   */\r\n  private _onInputChange = (updatedValue: string): void => {\r\n    if (this.props.disabled) {\r\n      this._handleInputWhenDisabled(null /* event */);\r\n      return;\r\n    }\r\n\r\n    this.props.allowFreeform ? this._processInputChangeWithFreeform(updatedValue) : this._processInputChangeWithoutFreeform(updatedValue);\r\n  };\r\n\r\n  /**\r\n   * Process the new input's new value when the comboBox\r\n   * allows freeform entry\r\n   * @param updatedValue - the input's newly changed value\r\n   */\r\n  private _processInputChangeWithFreeform(updatedValue: string): void {\r\n    const { currentOptions } = this.state;\r\n    updatedValue = this._removeZeroWidthSpaces(updatedValue);\r\n    let newCurrentPendingValueValidIndex = -1;\r\n\r\n    // if the new value is empty, see if we have an exact match\r\n    // and then set the pending info\r\n    if (updatedValue === '') {\r\n      const items = currentOptions\r\n        .map((item, index) => {\r\n          return { ...item, index };\r\n        })\r\n        .filter(\r\n          option => option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider\r\n        )\r\n        .filter(option => this._getPreviewText(option) === updatedValue);\r\n\r\n      // if we found a match remember the index\r\n      if (items.length === 1) {\r\n        newCurrentPendingValueValidIndex = items[0].index;\r\n      }\r\n\r\n      this._setPendingInfo(updatedValue, newCurrentPendingValueValidIndex, updatedValue);\r\n      return;\r\n    }\r\n\r\n    // Remember the original value and then,\r\n    // make the value lowercase for comparison\r\n    const originalUpdatedValue: string = updatedValue;\r\n    updatedValue = updatedValue.toLocaleLowerCase();\r\n\r\n    let newSuggestedDisplayValue = '';\r\n\r\n    // If autoComplete is on, attempt to find a match from the available options\r\n    if (this.props.autoComplete === 'on') {\r\n      // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\r\n      const items = currentOptions\r\n        .map((item, index) => {\r\n          return { ...item, index };\r\n        })\r\n        .filter(\r\n          option => option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider\r\n        )\r\n        .filter(\r\n          option =>\r\n            this._getPreviewText(option)\r\n              .toLocaleLowerCase()\r\n              .indexOf(updatedValue) === 0\r\n        );\r\n      if (items.length > 0) {\r\n        // use ariaLabel as the value when the option is set\r\n        const text: string = this._getPreviewText(items[0]);\r\n\r\n        // If the user typed out the complete option text, we don't need any suggested display text anymore\r\n        newSuggestedDisplayValue = text.toLocaleLowerCase() !== updatedValue ? text : '';\r\n\r\n        // remember the index of the match we found\r\n        newCurrentPendingValueValidIndex = items[0].index;\r\n      }\r\n    } else {\r\n      // If autoComplete is off, attempt to find a match only when the value is exactly equal to the text of an option\r\n      const items = currentOptions\r\n        .map((item, index) => {\r\n          return { ...item, index };\r\n        })\r\n        .filter(\r\n          option => option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider\r\n        )\r\n        .filter(option => this._getPreviewText(option).toLocaleLowerCase() === updatedValue);\r\n\r\n      // if we found a match remember the index\r\n      if (items.length === 1) {\r\n        newCurrentPendingValueValidIndex = items[0].index;\r\n      }\r\n    }\r\n\r\n    // Set the updated state\r\n    this._setPendingInfo(originalUpdatedValue, newCurrentPendingValueValidIndex, newSuggestedDisplayValue);\r\n  }\r\n\r\n  /**\r\n   * Process the new input's new value when the comboBox\r\n   * does not allow freeform entry\r\n   * @param updatedValue - the input's newly changed value\r\n   */\r\n  private _processInputChangeWithoutFreeform(updatedValue: string): void {\r\n    const { currentPendingValue, currentPendingValueValidIndex, currentOptions } = this.state;\r\n\r\n    updatedValue = this._removeZeroWidthSpaces(updatedValue);\r\n    if (this.props.autoComplete === 'on') {\r\n      // If autoComplete is on while allow freeform is off,\r\n      // we will remember the keypresses and build up a string to attempt to match\r\n      // as long as characters are typed within a the timeout span of each other,\r\n      // otherwise we will clear the string and start building a new one on the next keypress.\r\n      // Also, only do this processing if we have a non-empty value\r\n      if (updatedValue !== '') {\r\n        // If we have a pending autocomplete clearing task,\r\n        // we know that the user is typing with keypresses happening\r\n        // within the timeout of each other so remove the clearing task\r\n        // and continue building the pending value with the udpated value\r\n        if (this._lastReadOnlyAutoCompleteChangeTimeoutId !== undefined) {\r\n          this._async.clearTimeout(this._lastReadOnlyAutoCompleteChangeTimeoutId);\r\n          this._lastReadOnlyAutoCompleteChangeTimeoutId = undefined;\r\n          updatedValue = this._normalizeToString(currentPendingValue) + updatedValue;\r\n        }\r\n\r\n        const originalUpdatedValue: string = updatedValue;\r\n        updatedValue = updatedValue.toLocaleLowerCase();\r\n\r\n        // If autoComplete is on, attempt to find a match where the text of an option starts with the updated value\r\n        const items = currentOptions\r\n          .map((item, i) => {\r\n            return { ...item, index: i };\r\n          })\r\n          .filter(\r\n            option => option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider\r\n          )\r\n          .filter(option => option.text.toLocaleLowerCase().indexOf(updatedValue) === 0);\r\n\r\n        // If we found a match, udpdate the state\r\n        if (items.length > 0) {\r\n          this._setPendingInfo(originalUpdatedValue, items[0].index, this._getPreviewText(items[0]));\r\n        }\r\n\r\n        // Schedule a timeout to clear the pending value after the timeout span\r\n        this._lastReadOnlyAutoCompleteChangeTimeoutId = this._async.setTimeout(() => {\r\n          this._lastReadOnlyAutoCompleteChangeTimeoutId = undefined;\r\n        }, ReadOnlyPendingAutoCompleteTimeout);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // If we get here, either autoComplete is on or we did not find a match with autoComplete on.\r\n    // Remember we are not allowing freeform, so at this point, if we have a pending valid value index\r\n    // use that; otherwise use the selectedIndex\r\n    const index = currentPendingValueValidIndex >= 0 ? currentPendingValueValidIndex : this._getFirstSelectedIndex();\r\n\r\n    // Since we are not allowing freeform, we need to\r\n    // set both the pending and suggested values/index\r\n    // to allow us to select all content in the input to\r\n    // give the illusion that we are readonly (e.g. freeform off)\r\n    this._setPendingInfoFromIndex(index);\r\n  }\r\n\r\n  private _getFirstSelectedIndex(): number {\r\n    return this.state.selectedIndices && this.state.selectedIndices.length > 0 ? this.state.selectedIndices[0] : -1;\r\n  }\r\n\r\n  /**\r\n   * Walk along the options starting at the index, stepping by the delta (positive or negative)\r\n   * looking for the next valid selectable index (e.g. skipping headings and dividers)\r\n   * @param index - the index to get the next selectable index from\r\n   * @param delta - optional delta to step by when finding the next index, defaults to 0\r\n   * @returns - the next valid selectable index. If the new index is outside of the bounds,\r\n   * it will snap to the edge of the options array. If delta == 0 and the given index is not selectable\r\n   */\r\n  private _getNextSelectableIndex(index: number, searchDirection: SearchDirection): number {\r\n    const { currentOptions } = this.state;\r\n\r\n    let newIndex = index + searchDirection;\r\n\r\n    newIndex = Math.max(0, Math.min(currentOptions.length - 1, newIndex));\r\n\r\n    if (!this._indexWithinBounds(currentOptions, newIndex)) {\r\n      return -1;\r\n    }\r\n\r\n    const option: IComboBoxOption = currentOptions[newIndex];\r\n\r\n    // attempt to skip headers and dividers\r\n    if (option.itemType === SelectableOptionMenuItemType.Header || option.itemType === SelectableOptionMenuItemType.Divider) {\r\n      // Should we continue looking for an index to select?\r\n      if (\r\n        searchDirection !== SearchDirection.none &&\r\n        ((newIndex > 0 && searchDirection < SearchDirection.none) ||\r\n          (newIndex >= 0 && newIndex < currentOptions.length && searchDirection > SearchDirection.none))\r\n      ) {\r\n        newIndex = this._getNextSelectableIndex(newIndex, searchDirection);\r\n      } else {\r\n        // If we cannot perform a useful search just return the index we were given\r\n        return index;\r\n      }\r\n    }\r\n\r\n    // We have the next valid selectable index, return it\r\n    return newIndex;\r\n  }\r\n\r\n  /**\r\n   * Set the selected index. Note, this is\r\n   * the \"real\" selected index, not the pending selected index\r\n   * @param index - the index to set (or the index to set from if a search direction is provided)\r\n   * @param searchDirection - the direction to search along the options from the given index\r\n   */\r\n  private _setSelectedIndex(index: number, submitPendingValueEvent: any, searchDirection: SearchDirection = SearchDirection.none): void {\r\n    const { onChange, onChanged, onPendingValueChanged } = this.props;\r\n    const { currentOptions } = this.state;\r\n    let { selectedIndices } = this.state;\r\n\r\n    if (!selectedIndices) {\r\n      selectedIndices = [];\r\n    }\r\n\r\n    // Find the next selectable index, if searchDirection is none\r\n    // we will get our starting index back\r\n    index = this._getNextSelectableIndex(index, searchDirection);\r\n\r\n    if (!this._indexWithinBounds(currentOptions, index)) {\r\n      return;\r\n    }\r\n\r\n    // Are we at a new index? If so, update the state, otherwise\r\n    // there is nothing to do\r\n    if (this.props.multiSelect || selectedIndices.length < 1 || (selectedIndices.length === 1 && selectedIndices[0] !== index)) {\r\n      const option: IComboBoxOption = currentOptions[index];\r\n      if (!option) {\r\n        return;\r\n      }\r\n      if (this.props.multiSelect) {\r\n        // Setting the initial state of option.selected in Multi-select combobox by checking the\r\n        // selectedIndices array and overriding the undefined issue\r\n        option.selected = option.selected !== undefined ? !option.selected : selectedIndices.indexOf(index) < 0;\r\n        if (option.selected && selectedIndices.indexOf(index) < 0) {\r\n          selectedIndices.push(index);\r\n        } else if (!option.selected && selectedIndices.indexOf(index) >= 0) {\r\n          selectedIndices = selectedIndices.filter((value: number) => value !== index);\r\n        }\r\n      } else {\r\n        selectedIndices[0] = index;\r\n      }\r\n\r\n      // Set the selected option\r\n      this.setState({\r\n        selectedIndices: selectedIndices\r\n      });\r\n\r\n      // If ComboBox value is changed, revert preview first\r\n      if (this._hasPendingValue && onPendingValueChanged) {\r\n        onPendingValueChanged();\r\n        this._hasPendingValue = false;\r\n      }\r\n\r\n      if (onChange) {\r\n        onChange(submitPendingValueEvent, option, index, undefined);\r\n      }\r\n\r\n      if (onChanged) {\r\n        onChanged(option, index, undefined, submitPendingValueEvent);\r\n      }\r\n\r\n      // if we have a new selected index,\r\n      // clear all of the pending info\r\n      this._clearPendingInfo();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Focus (and select) the content of the input\r\n   * and set the focused state\r\n   */\r\n  private _select = (): void => {\r\n    if (this._autofill.current && this._autofill.current.inputElement) {\r\n      this._autofill.current.inputElement.select();\r\n    }\r\n\r\n    if (!this.state.focused) {\r\n      this.setState({ focused: true });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Callback issued when the options should be resolved, if they have been updated or\r\n   * if they need to be passed in the first time. This only does work if an onResolveOptions\r\n   * callback was passed in\r\n   */\r\n  private _onResolveOptions = (): void => {\r\n    if (this.props.onResolveOptions) {\r\n      // get the options\r\n      const newOptions = this.props.onResolveOptions({ ...this.state.currentOptions });\r\n\r\n      // Check to see if the returned value is an array, if it is update the state\r\n      // If the returned value is not an array then check to see if it's a promise or PromiseLike. If it is then resolve it asynchronously.\r\n      if (Array.isArray(newOptions)) {\r\n        this.setState({\r\n          currentOptions: newOptions\r\n        });\r\n      } else if (newOptions && newOptions.then) {\r\n        // Ensure that the promise will only use the callback if it was the most recent one\r\n        // and update the state when the promise returns\r\n        const promise: PromiseLike<IComboBoxOption[]> = (this._currentPromise = newOptions);\r\n        promise.then((newOptionsFromPromise: IComboBoxOption[]) => {\r\n          if (promise === this._currentPromise) {\r\n            this.setState({\r\n              currentOptions: newOptionsFromPromise\r\n            });\r\n          }\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * OnBlur handler. Set the focused state to false\r\n   * and submit any pending value\r\n   */\r\n  private _onBlur = (event: React.FocusEvent<HTMLInputElement>): void => {\r\n    // Do nothing if the blur is coming from something\r\n    // inside the comboBox root or the comboBox menu since\r\n    // it we are not really bluring from the whole comboBox\r\n    let relatedTarget = event.relatedTarget;\r\n    if (event.relatedTarget === null) {\r\n      // In IE11, due to lack of support, event.relatedTarget is always\r\n      // null making every onBlur call to be \"outside\" of the ComboBox\r\n      // even when it's not. Using document.activeElement is another way\r\n      // for us to be able to get what the relatedTarget without relying\r\n      // on the event\r\n      relatedTarget = document.activeElement as Element;\r\n    }\r\n    if (\r\n      relatedTarget &&\r\n      // when event coming from withing the comboBox title\r\n      ((this._root.current && this._root.current.contains(relatedTarget as HTMLElement)) ||\r\n        // when event coming from within the comboBox list menu\r\n        (this._comboBoxMenu.current &&\r\n          (this._comboBoxMenu.current.contains(relatedTarget as HTMLElement) ||\r\n            // when event coming from the callout containing the comboBox list menu (ex: when scrollBar of the Callout clicked)\r\n            // checks if the relatedTarget is a parent of _comboBoxMenu\r\n            findElementRecursive(this._comboBoxMenu.current, element => element === relatedTarget))))\r\n    ) {\r\n      event.preventDefault();\r\n      event.stopPropagation();\r\n      return;\r\n    }\r\n\r\n    if (this.state.focused) {\r\n      this.setState({ focused: false });\r\n      if (!this.props.multiSelect || this.props.allowFreeform) {\r\n        this._submitPendingValue(event);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Submit a pending value if there is one\r\n   */\r\n  private _submitPendingValue(submitPendingValueEvent: any): void {\r\n    const { onChange, onChanged, allowFreeform, autoComplete } = this.props;\r\n    const { currentPendingValue, currentPendingValueValidIndex, currentOptions, currentPendingValueValidIndexOnHover } = this.state;\r\n    let { selectedIndices } = this.state;\r\n\r\n    // Do not submit any pending value if we\r\n    // have already initiated clearing the pending info\r\n    if (this._processingClearPendingInfo) {\r\n      return;\r\n    }\r\n\r\n    // If we allow freeform we need to handle that\r\n    if (allowFreeform) {\r\n      // if currentPendingValue is null or undefined the user did not submit anything\r\n      // (not even empty because we would have stored that as the pending value)\r\n      if (currentPendingValue === null || currentPendingValue === undefined) {\r\n        // if a user did not type anything they may just hovered over an item\r\n        if (currentPendingValueValidIndexOnHover >= 0) {\r\n          this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\r\n          this._clearPendingInfo();\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      // Check to see if the user typed an exact match\r\n      if (this._indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {\r\n        const pendingOptionText: string = this._getPreviewText(currentOptions[currentPendingValueValidIndex]).toLocaleLowerCase();\r\n\r\n        // By exact match, that means: our pending value is the same as the the pending option text OR\r\n        // the pending option starts with the pending value and we have an \"autoComplete\" selection\r\n        // where the total length is equal to pending option length OR\r\n        // the live value in the underlying input matches the pending option; update the state\r\n        if (\r\n          currentPendingValue.toLocaleLowerCase() === pendingOptionText ||\r\n          ((autoComplete &&\r\n            pendingOptionText.indexOf(currentPendingValue.toLocaleLowerCase()) === 0 &&\r\n            (this._autofill.current &&\r\n              this._autofill.current.isValueSelected &&\r\n              currentPendingValue.length + (this._autofill.current.selectionEnd! - this._autofill.current.selectionStart!) ===\r\n                pendingOptionText.length)) ||\r\n            (this._autofill.current &&\r\n              this._autofill.current.inputElement &&\r\n              this._autofill.current.inputElement.value.toLocaleLowerCase() === pendingOptionText))\r\n        ) {\r\n          this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\r\n          this._clearPendingInfo();\r\n          return;\r\n        }\r\n      }\r\n\r\n      if (onChange || onChanged) {\r\n        if (onChange) {\r\n          // trigger onChange to clear value\r\n          onChange(submitPendingValueEvent, undefined, undefined, currentPendingValue);\r\n        }\r\n        if (onChanged) {\r\n          // trigger onChanged to clear value\r\n          onChanged(undefined, undefined, currentPendingValue, submitPendingValueEvent);\r\n        }\r\n      } else {\r\n        // If we are not controlled, create a new option\r\n        const newOption: IComboBoxOption = {\r\n          key: currentPendingValue || getId(),\r\n          text: this._normalizeToString(currentPendingValue)\r\n        };\r\n        const newOptions: IComboBoxOption[] = [...currentOptions, newOption];\r\n        if (selectedIndices) {\r\n          if (!this.props.multiSelect) {\r\n            selectedIndices = [];\r\n          }\r\n          selectedIndices.push(newOptions.length - 1);\r\n        }\r\n        this.setState({\r\n          currentOptions: newOptions,\r\n          selectedIndices: selectedIndices\r\n        });\r\n      }\r\n    } else if (currentPendingValueValidIndex >= 0) {\r\n      // Since we are not allowing freeform, we must have a matching\r\n      // to be able to update state\r\n      this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);\r\n    } else if (currentPendingValueValidIndexOnHover >= 0) {\r\n      // If all else failed and we were hovering over an item, select it\r\n      this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);\r\n    }\r\n\r\n    // Finally, clear the pending info\r\n    this._clearPendingInfo();\r\n  }\r\n\r\n  // Render Callout container and pass in list\r\n  private _onRenderContainer = (props: IComboBoxProps): JSX.Element => {\r\n    const {\r\n      onRenderList,\r\n      calloutProps,\r\n      dropdownWidth,\r\n      dropdownMaxWidth,\r\n      onRenderLowerContent = this._onRenderLowerContent,\r\n      useComboBoxAsMenuWidth,\r\n      persistMenu\r\n    } = props;\r\n\r\n    const { isOpen } = this.state;\r\n\r\n    const comboBoxMenuWidth =\r\n      useComboBoxAsMenuWidth && this._comboBoxWrapper.current ? this._comboBoxWrapper.current.clientWidth + 2 : undefined;\r\n\r\n    return (\r\n      <Callout\r\n        isBeakVisible={false}\r\n        gapSpace={0}\r\n        doNotLayer={false}\r\n        directionalHint={DirectionalHint.bottomLeftEdge}\r\n        directionalHintFixed={false}\r\n        {...calloutProps}\r\n        onLayerMounted={this._onLayerMounted}\r\n        className={css(this._classNames.callout, calloutProps ? calloutProps.className : undefined)}\r\n        target={this._comboBoxWrapper.current}\r\n        onDismiss={this._onDismiss}\r\n        onScroll={this._onScroll}\r\n        setInitialFocus={false}\r\n        calloutWidth={useComboBoxAsMenuWidth && this._comboBoxWrapper.current ? comboBoxMenuWidth && comboBoxMenuWidth : dropdownWidth}\r\n        calloutMaxWidth={dropdownMaxWidth ? dropdownMaxWidth : comboBoxMenuWidth}\r\n        hidden={persistMenu ? !isOpen : undefined}\r\n      >\r\n        <div className={this._classNames.optionsContainerWrapper} ref={this._comboBoxMenu}>\r\n          {(onRenderList as any)({ ...props }, this._onRenderList)}\r\n        </div>\r\n        {onRenderLowerContent(this.props, this._onRenderLowerContent)}\r\n      </Callout>\r\n    );\r\n  };\r\n\r\n  private _onCalloutLayerMounted() {\r\n    // In persistMenu mode _onLayerMounted is only called once for the lifetime\r\n    // of the component. Any functionality required for callout \"on mount\" can\r\n    // go here so that we can also call it again during callout dismissal to reset\r\n    // object state.\r\n    this._gotMouseMove = false;\r\n  }\r\n\r\n  private _onLayerMounted = () => {\r\n    this._onCalloutLayerMounted();\r\n\r\n    if (this.props.calloutProps && this.props.calloutProps.onLayerMounted) {\r\n      this.props.calloutProps.onLayerMounted();\r\n    }\r\n  };\r\n\r\n  // Render List of items\r\n  private _onRenderList = (props: IComboBoxProps): JSX.Element => {\r\n    const { onRenderItem, options } = props;\r\n\r\n    const id = this._id;\r\n    return (\r\n      <div id={id + '-list'} className={this._classNames.optionsContainer} aria-labelledby={id + '-label'} role=\"listbox\">\r\n        {options.map(item => (onRenderItem as any)(item, this._onRenderItem))}\r\n      </div>\r\n    );\r\n  };\r\n\r\n  // Render items\r\n  private _onRenderItem = (item: IComboBoxOption): JSX.Element | null => {\r\n    switch (item.itemType) {\r\n      case SelectableOptionMenuItemType.Divider:\r\n        return this._renderSeparator(item);\r\n      case SelectableOptionMenuItemType.Header:\r\n        return this._renderHeader(item);\r\n      default:\r\n        return this._renderOption(item);\r\n    }\r\n  };\r\n\r\n  // Default _onRenderLowerContent function returns nothing\r\n  private _onRenderLowerContent = (): null => {\r\n    return null;\r\n  };\r\n\r\n  // Render separator\r\n  private _renderSeparator(item: IComboBoxOption): JSX.Element | null {\r\n    const { index, key } = item;\r\n\r\n    if (index && index > 0) {\r\n      return <div role=\"separator\" key={key} className={this._classNames.divider} />;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private _renderHeader(item: IComboBoxOption): JSX.Element {\r\n    const { onRenderOption = this._onRenderOptionContent } = this.props;\r\n\r\n    return (\r\n      <div key={item.key} className={this._classNames.header}>\r\n        {onRenderOption(item, this._onRenderOptionContent)}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  private _renderOption = (item: IComboBoxOption): JSX.Element => {\r\n    const { onRenderOption = this._onRenderOptionContent } = this.props;\r\n    const id = this._id;\r\n    const isSelected: boolean = this._isOptionSelected(item.index);\r\n    const optionStyles = this._getCurrentOptionStyles(item);\r\n    const optionClassNames = getComboBoxOptionClassNames(this._getCurrentOptionStyles(item));\r\n    const checkboxStyles = () => {\r\n      return optionStyles;\r\n    };\r\n    const title = this._getPreviewText(item);\r\n\r\n    const getOptionComponent = () => {\r\n      return !this.props.multiSelect ? (\r\n        <CommandButton\r\n          id={id + '-list' + item.index}\r\n          key={item.key}\r\n          data-index={item.index}\r\n          styles={this._getCurrentOptionStyles(item)}\r\n          checked={isSelected}\r\n          className={'ms-ComboBox-option'}\r\n          onClick={this._onItemClick(item)}\r\n          onMouseEnter={this._onOptionMouseEnter.bind(this, item.index)}\r\n          onMouseMove={this._onOptionMouseMove.bind(this, item.index)}\r\n          onMouseLeave={this._onOptionMouseLeave}\r\n          role=\"option\"\r\n          aria-selected={isSelected ? 'true' : 'false'}\r\n          ariaLabel={this._getPreviewText(item)}\r\n          disabled={item.disabled}\r\n          title={title}\r\n        >\r\n          {' '}\r\n          {\r\n            <span className={optionClassNames.optionTextWrapper} ref={isSelected ? this._selectedElement : undefined}>\r\n              {onRenderOption(item, this._onRenderOptionContent)}\r\n            </span>\r\n          }\r\n        </CommandButton>\r\n      ) : (\r\n        <Checkbox\r\n          id={id + '-list' + item.index}\r\n          ariaLabel={this._getPreviewText(item)}\r\n          key={item.key}\r\n          data-index={item.index}\r\n          styles={checkboxStyles}\r\n          className={'ms-ComboBox-option'}\r\n          data-is-focusable={true}\r\n          onChange={this._onItemClick(item)}\r\n          label={item.text}\r\n          role=\"option\"\r\n          aria-selected={isSelected ? 'true' : 'false'}\r\n          checked={isSelected}\r\n          title={title}\r\n        >\r\n          {onRenderOption(item, this._onRenderOptionContent)}\r\n        </Checkbox>\r\n      );\r\n    };\r\n\r\n    return (\r\n      <ComboBoxOptionWrapper\r\n        key={item.key}\r\n        index={item.index}\r\n        disabled={item.disabled}\r\n        isSelected={isSelected}\r\n        text={item.text}\r\n        render={getOptionComponent}\r\n      />\r\n    );\r\n  };\r\n\r\n  /**\r\n   * If we are coming from a mouseOut:\r\n   * there is no visible selected option.\r\n   *\r\n   * Else if We are hovering over an item:\r\n   * that gets the selected look.\r\n   *\r\n   * Else:\r\n   * Use the current valid pending index if it exists OR\r\n   * we do not have a valid index and we currently have a pending input value,\r\n   * otherwise use the selected index\r\n   * */\r\n  private _isOptionSelected(index: number | undefined): boolean {\r\n    const { currentPendingValueValidIndexOnHover } = this.state;\r\n\r\n    // If the hover state is set to clearAll, don't show a selected index.\r\n    // Note, this happens when the user moused out of the menu items\r\n    if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.props.multiSelect && this._getPendingSelectedIndex(true /* includePendingValue */) === index) {\r\n      return true;\r\n    }\r\n\r\n    let idxOfSelectedIndex = -1;\r\n    if (this.props.multiSelect && index !== undefined && this.state.selectedIndices) {\r\n      idxOfSelectedIndex = this.state.selectedIndices.indexOf(index);\r\n    }\r\n    return idxOfSelectedIndex >= 0;\r\n  }\r\n\r\n  /**\r\n   * Gets the pending selected index taking into account hover, valueValidIndex, and selectedIndex\r\n   * @param includeCurrentPendingValue - Should we include the currentPendingValue when\r\n   * finding the index\r\n   */\r\n  private _getPendingSelectedIndex(includeCurrentPendingValue: boolean): number {\r\n    const { currentPendingValueValidIndexOnHover, currentPendingValueValidIndex, currentPendingValue } = this.state;\r\n\r\n    return currentPendingValueValidIndexOnHover >= 0\r\n      ? currentPendingValueValidIndexOnHover\r\n      : currentPendingValueValidIndex >= 0 ||\r\n        (includeCurrentPendingValue && (currentPendingValue !== null && currentPendingValue !== undefined))\r\n      ? currentPendingValueValidIndex\r\n      : this.props.multiSelect\r\n      ? 0\r\n      : this._getFirstSelectedIndex();\r\n  }\r\n\r\n  /**\r\n   * Scroll handler for the callout to make sure the mouse events\r\n   * for updating focus are not interacting during scroll\r\n   */\r\n  private _onScroll = () => {\r\n    if (!this._isScrollIdle && this._scrollIdleTimeoutId !== undefined) {\r\n      this._async.clearTimeout(this._scrollIdleTimeoutId);\r\n      this._scrollIdleTimeoutId = undefined;\r\n    } else {\r\n      this._isScrollIdle = false;\r\n    }\r\n\r\n    this._scrollIdleTimeoutId = this._async.setTimeout(() => {\r\n      this._isScrollIdle = true;\r\n    }, ScrollIdleDelay);\r\n  };\r\n\r\n  /**\r\n   * Scroll the selected element into view\r\n   */\r\n  private _scrollIntoView(): void {\r\n    const { onScrollToItem, scrollSelectedToTop } = this.props;\r\n\r\n    const { currentPendingValueValidIndex, currentPendingValue } = this.state;\r\n\r\n    if (onScrollToItem) {\r\n      // Use the custom scroll handler\r\n      onScrollToItem(\r\n        currentPendingValueValidIndex >= 0 || currentPendingValue !== '' ? currentPendingValueValidIndex : this._getFirstSelectedIndex()\r\n      );\r\n    } else if (this._selectedElement.current && this._selectedElement.current.offsetParent) {\r\n      // We are using refs, scroll the ref into view\r\n      if (scrollSelectedToTop) {\r\n        this._selectedElement.current.offsetParent.scrollIntoView(true);\r\n      } else {\r\n        let alignToTop = true;\r\n\r\n        if (this._comboBoxMenu.current && this._comboBoxMenu.current.offsetParent) {\r\n          const scrollableParentRect = this._comboBoxMenu.current.offsetParent.getBoundingClientRect();\r\n          const selectedElementRect = this._selectedElement.current.offsetParent.getBoundingClientRect();\r\n\r\n          // If we are completely in view then we do not need to scroll\r\n          if (\r\n            scrollableParentRect.top <= selectedElementRect.top &&\r\n            scrollableParentRect.top + scrollableParentRect.height >= selectedElementRect.top + selectedElementRect.height\r\n          ) {\r\n            return;\r\n          }\r\n\r\n          // If we are lower than the scrollable parent viewport then we should align to the bottom\r\n          if (scrollableParentRect.top + scrollableParentRect.height <= selectedElementRect.top + selectedElementRect.height) {\r\n            alignToTop = false;\r\n          }\r\n        }\r\n\r\n        this._selectedElement.current.offsetParent.scrollIntoView(alignToTop);\r\n      }\r\n    }\r\n  }\r\n\r\n  private _onRenderOptionContent = (item: IComboBoxOption): JSX.Element => {\r\n    const optionClassNames = getComboBoxOptionClassNames(this._getCurrentOptionStyles(item));\r\n    return <span className={optionClassNames.optionText}>{item.text}</span>;\r\n  };\r\n\r\n  /**\r\n   * Click handler for the menu items\r\n   * to select the item and also close the menu\r\n   * @param index - the index of the item that was clicked\r\n   */\r\n  private _onItemClick(item: IComboBoxOption): (ev: any) => void {\r\n    const { onItemClick } = this.props;\r\n    const { index } = item;\r\n\r\n    return (ev: any): void => {\r\n      onItemClick && onItemClick(ev, item, index);\r\n      this._setSelectedIndex(index as number, ev);\r\n      if (!this.props.multiSelect) {\r\n        // only close the callout when it's in single-select mode\r\n        this.setState({\r\n          isOpen: false\r\n        });\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Handles dismissing (cancelling) the menu\r\n   */\r\n  private _onDismiss = (): void => {\r\n    // In persistMode we need to simulate callout layer mount\r\n    // since that only happens once. We do it on dismiss since\r\n    // it works either way.\r\n    if (this.props.persistMenu) {\r\n      this._onCalloutLayerMounted();\r\n    }\r\n\r\n    // close the menu\r\n    this._setOpenStateAndFocusOnClose(false /* isOpen */, false /* focusInputAfterClose */);\r\n\r\n    // reset the selected index\r\n    // to the last value state\r\n    this._resetSelectedIndex();\r\n  };\r\n\r\n  /**\r\n   * Get the indices of the options that are marked as selected\r\n   * @param options - the comboBox options\r\n   * @param selectedKeys - the known selected keys to find\r\n   * @returns - an array of the indices of the selected options, empty array if nothing is selected\r\n   */\r\n  private _getSelectedIndices(options: IComboBoxOption[] | undefined, selectedKeys: (string | number | undefined)[]): number[] {\r\n    if (!options || !selectedKeys) {\r\n      return [];\r\n    }\r\n\r\n    const selectedIndices: { [key: number]: boolean } = {};\r\n    options.forEach((option: IComboBoxOption, index: number) => {\r\n      if (option.selected) {\r\n        selectedIndices[index] = true;\r\n      }\r\n    });\r\n\r\n    for (const selectedKey of selectedKeys) {\r\n      const index = findIndex(options, option => option.key === selectedKey);\r\n      if (index > -1) {\r\n        selectedIndices[index] = true;\r\n      }\r\n    }\r\n\r\n    return Object.keys(selectedIndices)\r\n      .map(Number)\r\n      .sort();\r\n  }\r\n\r\n  /**\r\n   * Reset the selected index by clearing the\r\n   * input (of any pending text), clearing the pending state,\r\n   * and setting the suggested display value to the last\r\n   * selected state text\r\n   */\r\n  private _resetSelectedIndex(): void {\r\n    const { currentOptions } = this.state;\r\n\r\n    this._clearPendingInfo();\r\n\r\n    const selectedIndex: number = this._getFirstSelectedIndex();\r\n    if (selectedIndex > 0 && selectedIndex < currentOptions.length) {\r\n      this.setState({\r\n        suggestedDisplayValue: currentOptions[selectedIndex].text\r\n      });\r\n    } else if (this.props.text || this.props.value) {\r\n      // If we had a value initially, restore it\r\n      this.setState({\r\n        suggestedDisplayValue: this.props.text || this.props.value\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears the pending info state\r\n   */\r\n  private _clearPendingInfo(): void {\r\n    this._processingClearPendingInfo = true;\r\n    this.setState(\r\n      {\r\n        currentPendingValue: undefined,\r\n        currentPendingValueValidIndex: -1,\r\n        suggestedDisplayValue: undefined,\r\n        currentPendingValueValidIndexOnHover: HoverStatus.default\r\n      },\r\n      this._onAfterClearPendingInfo\r\n    );\r\n  }\r\n\r\n  private _onAfterClearPendingInfo = () => {\r\n    this._processingClearPendingInfo = false;\r\n  };\r\n\r\n  /**\r\n   * Set the pending info\r\n   * @param currentPendingValue - new pending value to set\r\n   * @param currentPendingValueValidIndex - new pending value index to set\r\n   * @param suggestedDisplayValue - new suggest display value to set\r\n   */\r\n  private _setPendingInfo(currentPendingValue?: string, currentPendingValueValidIndex: number = -1, suggestedDisplayValue?: string): void {\r\n    if (this._processingClearPendingInfo) {\r\n      return;\r\n    }\r\n\r\n    this.setState({\r\n      currentPendingValue: currentPendingValue && this._removeZeroWidthSpaces(currentPendingValue),\r\n      currentPendingValueValidIndex: currentPendingValueValidIndex,\r\n      suggestedDisplayValue: suggestedDisplayValue,\r\n      currentPendingValueValidIndexOnHover: HoverStatus.default\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set the pending info from the given index\r\n   * @param index - the index to set the pending info from\r\n   */\r\n  private _setPendingInfoFromIndex(index: number): void {\r\n    const { currentOptions } = this.state;\r\n\r\n    if (index >= 0 && index < currentOptions.length) {\r\n      const option = currentOptions[index];\r\n      this._setPendingInfo(this._getPreviewText(option), index, this._getPreviewText(option));\r\n    } else {\r\n      this._clearPendingInfo();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the pending info for the comboBox\r\n   * @param index - the index to search from\r\n   * @param searchDirection - the direction to search\r\n   */\r\n  private _setPendingInfoFromIndexAndDirection(index: number, searchDirection: SearchDirection): void {\r\n    const { currentOptions } = this.state;\r\n\r\n    // update index to allow content to wrap\r\n    if (searchDirection === SearchDirection.forward && index >= currentOptions.length - 1) {\r\n      index = -1;\r\n    } else if (searchDirection === SearchDirection.backward && index <= 0) {\r\n      index = currentOptions.length;\r\n    }\r\n\r\n    // get the next \"valid\" index\r\n    const indexUpdate = this._getNextSelectableIndex(index, searchDirection);\r\n\r\n    // if the two indicies are equal we didn't move and\r\n    // we should attempt to get  get the first/last \"valid\" index to use\r\n    // (Note, this takes care of the potential cases where the first/last\r\n    // item is not focusable), otherwise use the updated index\r\n    if (index === indexUpdate) {\r\n      if (searchDirection === SearchDirection.forward) {\r\n        index = this._getNextSelectableIndex(-1, searchDirection);\r\n      } else if (searchDirection === SearchDirection.backward) {\r\n        index = this._getNextSelectableIndex(currentOptions.length, searchDirection);\r\n      }\r\n    } else {\r\n      index = indexUpdate;\r\n    }\r\n\r\n    if (this._indexWithinBounds(currentOptions, index)) {\r\n      this._setPendingInfoFromIndex(index);\r\n    }\r\n  }\r\n\r\n  private _notifyPendingValueChanged(prevState: IComboBoxState): void {\r\n    const { onPendingValueChanged } = this.props;\r\n\r\n    if (!onPendingValueChanged) {\r\n      return;\r\n    }\r\n\r\n    const { currentPendingValue, currentOptions, currentPendingValueValidIndex, currentPendingValueValidIndexOnHover } = this.state;\r\n\r\n    let newPendingIndex: number | undefined = undefined;\r\n    let newPendingValue: string | undefined = undefined;\r\n\r\n    if (\r\n      currentPendingValueValidIndexOnHover !== prevState.currentPendingValueValidIndexOnHover &&\r\n      this._indexWithinBounds(currentOptions, currentPendingValueValidIndexOnHover)\r\n    ) {\r\n      // Set new pending index if hover index was changed\r\n      newPendingIndex = currentPendingValueValidIndexOnHover;\r\n    } else if (\r\n      currentPendingValueValidIndex !== prevState.currentPendingValueValidIndex &&\r\n      this._indexWithinBounds(currentOptions, currentPendingValueValidIndex)\r\n    ) {\r\n      // Set new pending index if currentPendingValueValidIndex was changed\r\n      newPendingIndex = currentPendingValueValidIndex;\r\n    } else if (currentPendingValue !== prevState.currentPendingValue && currentPendingValue !== '') {\r\n      // Set pendingValue in the case it was changed and no index was changed\r\n      newPendingValue = currentPendingValue;\r\n    }\r\n\r\n    // Notify when there is a new pending index/value. Also, if there is a pending value, it needs to send undefined.\r\n    if (newPendingIndex !== undefined || newPendingValue !== undefined || this._hasPendingValue) {\r\n      onPendingValueChanged(newPendingIndex !== undefined ? currentOptions[newPendingIndex] : undefined, newPendingIndex, newPendingValue);\r\n      this._hasPendingValue = newPendingIndex !== undefined || newPendingValue !== undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the isOpen state and updates focusInputAfterClose\r\n   */\r\n  private _setOpenStateAndFocusOnClose(isOpen: boolean, focusInputAfterClose: boolean): void {\r\n    this._focusInputAfterClose = focusInputAfterClose;\r\n    this.setState({\r\n      isOpen: isOpen\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle keydown on the input\r\n   * @param ev - The keyboard event that was fired\r\n   */\r\n  private _onInputKeyDown = (ev: React.KeyboardEvent<HTMLElement | Autofill>): void => {\r\n    const { disabled, allowFreeform, autoComplete } = this.props;\r\n    const { isOpen, currentOptions, currentPendingValueValidIndexOnHover } = this.state;\r\n\r\n    // Take note if we are processing an alt (option) or meta (command) keydown.\r\n    // See comment in _onInputKeyUp for reasoning.\r\n    this._lastKeyDownWasAltOrMeta = this._isAltOrMeta(ev);\r\n\r\n    if (disabled) {\r\n      this._handleInputWhenDisabled(ev);\r\n      return;\r\n    }\r\n\r\n    let index = this._getPendingSelectedIndex(false /* includeCurrentPendingValue */);\r\n\r\n    switch (ev.which) {\r\n      case KeyCodes.enter:\r\n        if (this._autofill.current && this._autofill.current.inputElement) {\r\n          this._autofill.current.inputElement.select();\r\n        }\r\n\r\n        this._submitPendingValue(ev);\r\n        if (this.props.multiSelect && isOpen) {\r\n          this.setState({\r\n            currentPendingValueValidIndex: index\r\n          });\r\n        } else {\r\n          // On enter submit the pending value\r\n          if (\r\n            isOpen ||\r\n            ((!allowFreeform ||\r\n              this.state.currentPendingValue === undefined ||\r\n              this.state.currentPendingValue === null ||\r\n              this.state.currentPendingValue.length <= 0) &&\r\n              this.state.currentPendingValueValidIndex < 0)\r\n          ) {\r\n            // if we are open or\r\n            // if we are not allowing freeform or\r\n            // our we have no pending value\r\n            // and no valid pending index\r\n            // flip the open state\r\n            this.setState({\r\n              isOpen: !isOpen\r\n            });\r\n          }\r\n        }\r\n        break;\r\n\r\n      case KeyCodes.tab:\r\n        // On enter submit the pending value\r\n        if (!this.props.multiSelect) {\r\n          this._submitPendingValue(ev);\r\n        }\r\n\r\n        // If we are not allowing freeform\r\n        // or the comboBox is open, flip the open state\r\n        if (isOpen) {\r\n          this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);\r\n        }\r\n\r\n        // Allow TAB to propigate\r\n        return;\r\n\r\n      case KeyCodes.escape:\r\n        // reset the selected index\r\n        this._resetSelectedIndex();\r\n\r\n        // Close the menu if opened\r\n        if (isOpen) {\r\n          this.setState({\r\n            isOpen: false\r\n          });\r\n        } else {\r\n          return;\r\n        }\r\n        break;\r\n\r\n      case KeyCodes.up:\r\n        // if we are in clearAll state (e.g. the user as hovering\r\n        // and has since mousedOut of the menu items),\r\n        // go to the last index\r\n        if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\r\n          index = this.state.currentOptions.length;\r\n        }\r\n\r\n        if (ev.altKey || ev.metaKey) {\r\n          // Close the menu if it is open and break so\r\n          // that the event get stopPropagation and prevent default.\r\n          // Otherwise, we need to let the event continue to propagate\r\n          if (isOpen) {\r\n            this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);\r\n            break;\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        // Go to the previous option\r\n        this._setPendingInfoFromIndexAndDirection(index, SearchDirection.backward);\r\n        break;\r\n\r\n      case KeyCodes.down:\r\n        // Expand the comboBox on ALT + DownArrow\r\n        if (ev.altKey || ev.metaKey) {\r\n          this._setOpenStateAndFocusOnClose(true /* isOpen */, true /* focusInputAfterClose */);\r\n        } else {\r\n          // if we are in clearAll state (e.g. the user as hovering\r\n          // and has since mousedOut of the menu items),\r\n          // go to the first index\r\n          if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {\r\n            index = -1;\r\n          }\r\n\r\n          // Got to the next option\r\n          this._setPendingInfoFromIndexAndDirection(index, SearchDirection.forward);\r\n        }\r\n        break;\r\n\r\n      case KeyCodes.home:\r\n      case KeyCodes.end:\r\n        if (allowFreeform) {\r\n          return;\r\n        }\r\n\r\n        // Set the initial values to respond to HOME\r\n        // which goes to the first selectable option\r\n        index = -1;\r\n        let directionToSearch = SearchDirection.forward;\r\n\r\n        // If end, update the values to respond to END\r\n        // which goes to the last selectable option\r\n        if (ev.which === KeyCodes.end) {\r\n          index = currentOptions.length;\r\n          directionToSearch = SearchDirection.backward;\r\n        }\r\n\r\n        this._setPendingInfoFromIndexAndDirection(index, directionToSearch);\r\n        break;\r\n\r\n      case KeyCodes.space:\r\n        // event handled in _onComboBoxKeyUp\r\n        if (!allowFreeform && autoComplete === 'off') {\r\n          break;\r\n        }\r\n\r\n      default:\r\n        // are we processing a function key? if so bail out\r\n        if (ev.which >= 112 /* F1 */ && ev.which <= 123 /* F12 */) {\r\n          return;\r\n        }\r\n\r\n        // If we get here and we got either and ALT key\r\n        // or meta key, let the event propagate\r\n        if (ev.keyCode === KeyCodes.alt || ev.key === 'Meta' /* && isOpen */) {\r\n          return;\r\n        }\r\n\r\n        // If we are not allowing freeform and\r\n        // allowing autoComplete, handle the input here\r\n        // since we have marked the input as readonly\r\n        if (!allowFreeform && autoComplete === 'on') {\r\n          this._onInputChange(String.fromCharCode(ev.which));\r\n          break;\r\n        }\r\n\r\n        // allow the key to propagate by default\r\n        return;\r\n    }\r\n\r\n    ev.stopPropagation();\r\n    ev.preventDefault();\r\n  };\r\n\r\n  /**\r\n   * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\r\n   */\r\n  private _isAltOrMeta(ev: React.KeyboardEvent<HTMLElement | Autofill>): boolean {\r\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\r\n  }\r\n\r\n  /**\r\n   * Handle keyup on the input\r\n   * @param ev - the keyboard event that was fired\r\n   */\r\n  private _onInputKeyUp = (ev: React.KeyboardEvent<HTMLElement | Autofill>): void => {\r\n    const { disabled, allowFreeform, autoComplete } = this.props;\r\n    const isOpen = this.state.isOpen;\r\n\r\n    // We close the menu on key up only if ALL of the following are true:\r\n    // - Most recent key down was alt or meta (command)\r\n    // - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\r\n    //   expand/collapse the menu)\r\n    // - We're not on a Mac (or iOS)\r\n    // This is because on Windows, pressing alt moves focus to the application menu bar or similar,\r\n    // closing any open context menus. There is not a similar behavior on Macs.\r\n    const keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && this._isAltOrMeta(ev);\r\n    this._lastKeyDownWasAltOrMeta = false;\r\n    const shouldHandleKey = keyPressIsAltOrMetaAlone && !(isMac() || isIOS());\r\n\r\n    if (disabled) {\r\n      this._handleInputWhenDisabled(ev);\r\n      return;\r\n    }\r\n\r\n    switch (ev.which) {\r\n      case KeyCodes.space:\r\n        // If we are not allowing freeform and are not autoComplete\r\n        // make space expand/collapse the comboBox\r\n        // and allow the event to propagate\r\n        if (!allowFreeform && autoComplete === 'off') {\r\n          this._setOpenStateAndFocusOnClose(!isOpen, !!isOpen);\r\n          return;\r\n        }\r\n        break;\r\n      default:\r\n        if (shouldHandleKey && isOpen) {\r\n          this._setOpenStateAndFocusOnClose(!isOpen, true /* focusInputAfterClose */);\r\n        }\r\n        return;\r\n    }\r\n\r\n    ev.stopPropagation();\r\n    ev.preventDefault();\r\n  };\r\n\r\n  private _onOptionMouseEnter(index: number): void {\r\n    if (this._shouldIgnoreMouseEvent()) {\r\n      return;\r\n    }\r\n\r\n    this.setState({\r\n      currentPendingValueValidIndexOnHover: index\r\n    });\r\n  }\r\n\r\n  private _onOptionMouseMove(index: number): void {\r\n    this._gotMouseMove = true;\r\n\r\n    if (!this._isScrollIdle || this.state.currentPendingValueValidIndexOnHover === index) {\r\n      return;\r\n    }\r\n\r\n    this.setState({\r\n      currentPendingValueValidIndexOnHover: index\r\n    });\r\n  }\r\n\r\n  private _onOptionMouseLeave = () => {\r\n    if (this._shouldIgnoreMouseEvent()) {\r\n      return;\r\n    }\r\n\r\n    // Ignore the event in persistMenu mode if the callout has\r\n    // closed. This is to avoid clearing the visuals on item click.\r\n    if (this.props.persistMenu && !this.state.isOpen) {\r\n      return;\r\n    }\r\n\r\n    this.setState({\r\n      currentPendingValueValidIndexOnHover: HoverStatus.clearAll\r\n    });\r\n  };\r\n\r\n  private _shouldIgnoreMouseEvent(): boolean {\r\n    return !this._isScrollIdle || !this._gotMouseMove;\r\n  }\r\n\r\n  /**\r\n   * Handle dismissing the menu and\r\n   * eating the required key event when disabled\r\n   * @param ev - the keyboard event that was fired\r\n   */\r\n  private _handleInputWhenDisabled(ev: React.KeyboardEvent<HTMLElement | Autofill> | null): void {\r\n    // If we are disabled, close the menu (if needed)\r\n    // and eat all keystokes other than TAB or ESC\r\n    if (this.props.disabled) {\r\n      if (this.state.isOpen) {\r\n        this.setState({ isOpen: false });\r\n      }\r\n\r\n      // When disabled stop propagation and prevent default\r\n      // of the event unless we have a tab, escape, or function key\r\n      if (\r\n        ev !== null &&\r\n        ev.which !== KeyCodes.tab &&\r\n        ev.which !== KeyCodes.escape &&\r\n        (ev.which < 112 /* F1 */ || ev.which > 123) /* F12 */\r\n      ) {\r\n        ev.stopPropagation();\r\n        ev.preventDefault();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Click handler for the button of the comboBox\r\n   * and the input when not allowing freeform. This\r\n   * toggles the expand/collapse state of the comboBox (if enbled)\r\n   */\r\n  private _onComboBoxClick = (): void => {\r\n    const { disabled } = this.props;\r\n    const { isOpen } = this.state;\r\n\r\n    if (!disabled) {\r\n      this._setOpenStateAndFocusOnClose(!isOpen, false /* focusInputAfterClose */);\r\n      this.setState({ focused: true });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Click handler for the autofill.\r\n   */\r\n  private _onAutofillClick = (): void => {\r\n    if (this.props.allowFreeform) {\r\n      this.focus(this.state.isOpen || this._processingTouch);\r\n    } else {\r\n      this._onComboBoxClick();\r\n    }\r\n  };\r\n\r\n  private _onTouchStart: () => void = () => {\r\n    if (this._comboBoxWrapper.current && !('onpointerdown' in this._comboBoxWrapper)) {\r\n      this._handleTouchAndPointerEvent();\r\n    }\r\n  };\r\n\r\n  private _onPointerDown = (ev: PointerEvent): void => {\r\n    if (ev.pointerType === 'touch') {\r\n      this._handleTouchAndPointerEvent();\r\n\r\n      ev.preventDefault();\r\n      ev.stopImmediatePropagation();\r\n    }\r\n  };\r\n\r\n  private _handleTouchAndPointerEvent() {\r\n    // If we already have an existing timeeout from a previous touch and pointer event\r\n    // cancel that timeout so we can set a nwe one.\r\n    if (this._lastTouchTimeoutId !== undefined) {\r\n      this._async.clearTimeout(this._lastTouchTimeoutId);\r\n      this._lastTouchTimeoutId = undefined;\r\n    }\r\n    this._processingTouch = true;\r\n\r\n    this._lastTouchTimeoutId = this._async.setTimeout(() => {\r\n      this._processingTouch = false;\r\n      this._lastTouchTimeoutId = undefined;\r\n    }, TouchIdleDelay);\r\n  }\r\n\r\n  /**\r\n   * Get the styles for the current option.\r\n   * @param item - Item props for the current option\r\n   */\r\n  private _getCaretButtonStyles(): IButtonStyles {\r\n    const { caretDownButtonStyles: customCaretDownButtonStyles } = this.props;\r\n    return getCaretDownButtonStyles(this.props.theme!, customCaretDownButtonStyles);\r\n  }\r\n\r\n  /**\r\n   * Get the styles for the current option.\r\n   * @param item - Item props for the current option\r\n   */\r\n  private _getCurrentOptionStyles(item: IComboBoxOption): Partial<IComboBoxOptionStyles> {\r\n    const { comboBoxOptionStyles: customStylesForAllOptions } = this.props;\r\n    const { styles: customStylesForCurrentOption } = item;\r\n\r\n    return getOptionStyles(this.props.theme!, customStylesForAllOptions, customStylesForCurrentOption, this._isPendingOption(item));\r\n  }\r\n\r\n  /**\r\n   * Get the aria-activedescendant value for the comboxbox.\r\n   * @returns the id of the current focused combo item, otherwise the id of the currently selected element, null otherwise\r\n   */\r\n  private _getAriaActiveDescentValue(): string | undefined {\r\n    let descendantText =\r\n      this.state.isOpen && this.state.selectedIndices && this.state.selectedIndices.length >= 0\r\n        ? this._id + '-list' + this.state.selectedIndices[0]\r\n        : undefined;\r\n    if (this.state.isOpen && this.state.focused && this.state.currentPendingValueValidIndex !== -1) {\r\n      descendantText = this._id + '-list' + this.state.currentPendingValueValidIndex;\r\n    }\r\n    return descendantText;\r\n  }\r\n\r\n  /**\r\n   * Get the aria autocomplete value for the Combobox\r\n   * @returns 'inline' if auto-complete automatically dynamic, 'both' if we have a list of possible values to pick from and can\r\n   * dynamically populate input, and 'none' if auto-complete is not enabled as we can't give user inputs.\r\n   */\r\n  private _getAriaAutoCompleteValue(): 'none' | 'inline' | 'list' | 'both' | undefined {\r\n    const autoComplete = !this.props.disabled && this.props.autoComplete === 'on';\r\n    return autoComplete ? (this.props.allowFreeform ? 'inline' : 'both') : 'none';\r\n  }\r\n\r\n  private _isPendingOption(item: IComboBoxOption): boolean {\r\n    return item && item.index === this.state.currentPendingValueValidIndex;\r\n  }\r\n\r\n  /**\r\n   * Given default selected key(s) and selected key(s), return the selected keys(s).\r\n   * When default selected key(s) are available, they take precedence and return them instead of selected key(s).\r\n   *\r\n   * @returns No matter what specific types the input parameters are, always return an array of\r\n   *  either strings or numbers instead of premitive type.  This normlization makes caller's logic easier.\r\n   */\r\n  private _buildDefaultSelectedKeys(\r\n    defaultSelectedKey: string | number | string[] | number[] | null | undefined,\r\n    selectedKey: string | number | string[] | number[] | null | undefined\r\n  ): string[] | number[] {\r\n    const selectedKeys: string[] | number[] = this._buildSelectedKeys(defaultSelectedKey);\r\n    if (selectedKeys.length) {\r\n      return selectedKeys;\r\n    }\r\n    return this._buildSelectedKeys(selectedKey);\r\n  }\r\n\r\n  private _buildSelectedKeys(selectedKey: string | number | string[] | number[] | null | undefined): string[] | number[] {\r\n    if (selectedKey === undefined) {\r\n      return [];\r\n    }\r\n\r\n    // need to cast here so typescript does not complain\r\n    return (selectedKey instanceof Array ? selectedKey : [selectedKey]) as string[] | number[];\r\n  }\r\n\r\n  // For scenarios where the option's text prop contains embedded styles, we use the option's\r\n  // ariaLabel value as the text in the input and for autocomplete matching. We know to use this\r\n  // when the useAriaLabelAsText prop is set to true\r\n  private _getPreviewText(item: IComboBoxOption): string {\r\n    return item.useAriaLabelAsText && item.ariaLabel ? item.ariaLabel : item.text;\r\n  }\r\n\r\n  private _normalizeToString(value?: string): string {\r\n    return value || '';\r\n  }\r\n\r\n  private _removeZeroWidthSpaces(value: string): string {\r\n    // remove any zero width space characters\r\n    return value.replace(RegExp('', 'g'), '');\r\n  }\r\n}\r\n"]}