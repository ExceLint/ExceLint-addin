{"version":3,"file":"inputMask.js","sourceRoot":"../src/","sources":["components/TextField/MaskedTextField/inputMask.ts"],"names":[],"mappings":";;;IAUa,QAAA,yBAAyB,GAA8B;QAClE,GAAG,EAAE,OAAO;QACZ,CAAC,EAAE,UAAU;QACb,GAAG,EAAE,aAAa;KACnB,CAAC;IAEF;;;;;;;;;;;;;OAaG;IACH,mBAA0B,IAAwB,EAAE,WAAkE;QAAlE,4BAAA,EAAA,cAAyC,iCAAyB;QACpH,IAAI,CAAC,IAAI,EAAE;YACT,OAAO,EAAE,CAAC;SACX;QAED,IAAM,YAAY,GAAiB,EAAE,CAAC;QACtC,kDAAkD;QAClD,IAAI,YAAY,GAAG,CAAC,CAAC;QACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACnD,IAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC;YAC/C,IAAI,QAAQ,KAAK,IAAI,EAAE;gBACrB,YAAY,EAAE,CAAC;aAChB;iBAAM;gBACL,+CAA+C;gBAC/C,IAAM,UAAU,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC;gBACzC,IAAI,UAAU,EAAE;oBACd,YAAY,CAAC,IAAI,CAAC;wBAChB;;;;;2BAKG;wBACH,YAAY,EAAE,CAAC;wBACf,MAAM,EAAE,UAAU;qBACnB,CAAC,CAAC;iBACJ;aACF;SACF;QAED,OAAO,YAAY,CAAC;IACtB,CAAC;IA/BD,8BA+BC;IAED;;;;;;;;;;;;;;;;;;;OAmBG;IACH,wBAA+B,IAAwB,EAAE,YAA0B,EAAE,QAAiB;QACpG,IAAI,WAAW,GAAG,IAAI,CAAC;QAEvB,IAAI,CAAC,WAAW,EAAE;YAChB,OAAO,EAAE,CAAC;SACX;QAED,yBAAyB;QACzB,WAAW,GAAG,WAAW,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;QAE7C,mEAAmE;QACnE,IAAI,gBAAgB,GAAG,CAAC,CAAC;QACzB,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;YAC3B,gBAAgB,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,GAAG,CAAC,CAAC;SACrD;QAED;;;WAGG;QACH,KAAuB,UAAY,EAAZ,6BAAY,EAAZ,0BAAY,EAAZ,IAAY;YAA9B,IAAM,QAAQ,qBAAA;YACjB,IAAI,QAAQ,GAAG,GAAG,CAAC;YACnB,IAAI,QAAQ,CAAC,KAAK,EAAE;gBAClB,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC;gBAC1B,IAAI,QAAQ,CAAC,YAAY,GAAG,gBAAgB,EAAE;oBAC5C,gBAAgB,GAAG,QAAQ,CAAC,YAAY,CAAC;iBAC1C;aACF;iBAAM;gBACL,IAAI,QAAQ,EAAE;oBACZ,QAAQ,GAAG,QAAQ,CAAC;iBACrB;aACF;YAED,uEAAuE;YACvE,WAAW,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE,QAAQ,CAAC,YAAY,CAAC,GAAG,QAAQ,GAAG,WAAW,CAAC,KAAK,CAAC,QAAQ,CAAC,YAAY,GAAG,CAAC,CAAC,CAAC;SACrH;QAED,iEAAiE;QACjE,IAAI,CAAC,QAAQ,EAAE;YACb,WAAW,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE,gBAAgB,GAAG,CAAC,CAAC,CAAC;SAC1D;QAED,OAAO,WAAW,CAAC;IACrB,CAAC;IA3CD,wCA2CC;IAED;;;;;OAKG;IACH,6BAAoC,YAA0B,EAAE,KAAa;QAC3E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC5C,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,IAAI,KAAK,EAAE;gBACzC,OAAO,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC;aACrC;SACF;QACD,OAAO,YAAY,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,YAAY,CAAC;IAC5D,CAAC;IAPD,kDAOC;IAED;;;;;OAKG;IACH,4BAAmC,YAA0B,EAAE,KAAa;QAC1E,KAAK,IAAI,CAAC,GAAG,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;YACjD,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,GAAG,KAAK,EAAE;gBACxC,OAAO,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC;aACrC;SACF;QACD,OAAO,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC;IACtC,CAAC;IAPD,gDAOC;IAED;;;;;;OAMG;IACH,oBAA2B,YAA0B,EAAE,cAAsB,EAAE,cAAsB;QACnG,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC5C,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,IAAI,cAAc,EAAE;gBAClD,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,IAAI,cAAc,GAAG,cAAc,EAAE;oBACnE,MAAM;iBACP;gBACD,YAAY,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,SAAS,CAAC;aACnC;SACF;QACD,OAAO,YAAY,CAAC;IACtB,CAAC;IAVD,gCAUC;IAED;;;;;OAKG;IACH,mBAA0B,YAA0B,EAAE,cAAsB;QAC1E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC5C,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,IAAI,cAAc,EAAE;gBAClD,YAAY,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,SAAS,CAAC;gBAClC,MAAM;aACP;SACF;QACD,OAAO,YAAY,CAAC;IACtB,CAAC;IARD,8BAQC;IAED;;;;;OAKG;IACH,mBAA0B,YAA0B,EAAE,cAAsB;QAC1E,KAAK,IAAI,CAAC,GAAG,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;YACjD,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,GAAG,cAAc,EAAE;gBACjD,YAAY,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,SAAS,CAAC;gBAClC,MAAM;aACP;SACF;QACD,OAAO,YAAY,CAAC;IACtB,CAAC;IARD,8BAQC;IAED;;;;;;;;OAQG;IACH,sBAA6B,YAA0B,EAAE,cAAsB,EAAE,SAAiB;QAChG,IAAI,WAAW,GAAG,CAAC,CAAC;QACpB,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,IAAI,gBAAgB,GAAG,KAAK,CAAC;QAE7B,mGAAmG;QACnG,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,IAAI,WAAW,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC9E,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,IAAI,cAAc,EAAE;gBAClD,gBAAgB,GAAG,IAAI,CAAC;gBACxB,SAAS,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC;gBACzC,mEAAmE;gBACnE,OAAO,WAAW,GAAG,SAAS,CAAC,MAAM,EAAE;oBACrC,wFAAwF;oBACxF,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,EAAE;wBAC9D,YAAY,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,SAAS,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,CAAC;wBACxD,4EAA4E;wBAC5E,IAAI,CAAC,GAAG,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE;4BAC/B,SAAS,GAAG,YAAY,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,YAAY,CAAC;yBAC9C;6BAAM;4BACL,SAAS,EAAE,CAAC;yBACb;wBACD,MAAM;qBACP;oBACD,WAAW,EAAE,CAAC;iBACf;aACF;SACF;QAED,OAAO,gBAAgB,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,cAAc,CAAC;IACvD,CAAC;IA7BD,oCA6BC","sourcesContent":["export interface IMaskValue {\r\n  value?: string;\r\n  /**\r\n   * This index refers to the index in the displayMask rather than the inputMask.\r\n   * This means that any escaped characters do not count toward this index.\r\n   */\r\n  displayIndex: number;\r\n  format: RegExp;\r\n}\r\n\r\nexport const DEFAULT_MASK_FORMAT_CHARS: { [key: string]: RegExp } = {\r\n  '9': /[0-9]/,\r\n  a: /[a-zA-Z]/,\r\n  '*': /[a-zA-Z0-9]/\r\n};\r\n\r\n/**\r\n * Takes in the mask string and the formatCharacters and returns an array of MaskValues\r\n * Example:\r\n * mask = 'Phone Number: (999) - 9999'\r\n * return = [\r\n *    { value: undefined, displayIndex: 16, format: /[0-9]/ },\r\n *    { value: undefined, displayIndex: 17, format: /[0-9]/ },\r\n *    { value: undefined, displayIndex: 18, format: /[0-9]/ },\r\n *    { value: undefined, displayIndex: 22, format: /[0-9]/ },\r\n * ]\r\n *\r\n * @param mask The string use to define the format of the displayed maskedValue.\r\n * @param formatChars An object defining how certain characters in the mask should accept input.\r\n */\r\nexport function parseMask(mask: string | undefined, formatChars: { [key: string]: RegExp } = DEFAULT_MASK_FORMAT_CHARS): IMaskValue[] {\r\n  if (!mask) {\r\n    return [];\r\n  }\r\n\r\n  const maskCharData: IMaskValue[] = [];\r\n  // Count the escape characters in the mask string.\r\n  let escapedChars = 0;\r\n  for (let i = 0; i + escapedChars < mask.length; i++) {\r\n    const maskChar = mask.charAt(i + escapedChars);\r\n    if (maskChar === '\\\\') {\r\n      escapedChars++;\r\n    } else {\r\n      // Check if the maskChar is a format character.\r\n      const maskFormat = formatChars[maskChar];\r\n      if (maskFormat) {\r\n        maskCharData.push({\r\n          /**\r\n           * Do not add escapedChars to the displayIndex.\r\n           * The index refers to a position in the mask's displayValue.\r\n           * Since the backslashes don't appear in the displayValue,\r\n           * we do not add them to the charData displayIndex.\r\n           */\r\n          displayIndex: i,\r\n          format: maskFormat\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  return maskCharData;\r\n}\r\n\r\n/**\r\n * Takes in the mask string, an array of MaskValues, and the maskCharacter\r\n * returns the mask string formatted with the input values and maskCharacter.\r\n * If the maskChar is undefined, the maskDisplay is truncated to the last filled format character.\r\n * Example:\r\n * mask = 'Phone Number: (999) 999 - 9999'\r\n * maskCharData = '12345'\r\n * maskChar = '_'\r\n * return = 'Phone Number: (123) 45_ - ___'\r\n *\r\n * Example:\r\n * mask = 'Phone Number: (999) 999 - 9999'\r\n * value = '12345'\r\n * maskChar = undefined\r\n * return = 'Phone Number: (123) 45'\r\n *\r\n * @param mask The string use to define the format of the displayed maskedValue.\r\n * @param maskCharData The input values to insert into the mask string for displaying.\r\n * @param maskChar? A character to display in place of unfilled mask format characters.\r\n */\r\nexport function getMaskDisplay(mask: string | undefined, maskCharData: IMaskValue[], maskChar?: string): string {\r\n  let maskDisplay = mask;\r\n\r\n  if (!maskDisplay) {\r\n    return '';\r\n  }\r\n\r\n  // Remove all backslashes\r\n  maskDisplay = maskDisplay.replace(/\\\\/g, '');\r\n\r\n  // lastDisplayIndex is is used to truncate the string if necessary.\r\n  let lastDisplayIndex = 0;\r\n  if (maskCharData.length > 0) {\r\n    lastDisplayIndex = maskCharData[0].displayIndex - 1;\r\n  }\r\n\r\n  /**\r\n   * For each input value, replace the character in the maskDisplay with the value.\r\n   * If there is no value set for the format character, use the maskChar.\r\n   */\r\n  for (const charData of maskCharData) {\r\n    let nextChar = ' ';\r\n    if (charData.value) {\r\n      nextChar = charData.value;\r\n      if (charData.displayIndex > lastDisplayIndex) {\r\n        lastDisplayIndex = charData.displayIndex;\r\n      }\r\n    } else {\r\n      if (maskChar) {\r\n        nextChar = maskChar;\r\n      }\r\n    }\r\n\r\n    // Insert the character into the maskdisplay at its corresponding index\r\n    maskDisplay = maskDisplay.slice(0, charData.displayIndex) + nextChar + maskDisplay.slice(charData.displayIndex + 1);\r\n  }\r\n\r\n  // Cut off all mask characters after the last filled format value\r\n  if (!maskChar) {\r\n    maskDisplay = maskDisplay.slice(0, lastDisplayIndex + 1);\r\n  }\r\n\r\n  return maskDisplay;\r\n}\r\n\r\n/**\r\n * Get the next format index right of or at a specified index.\r\n * If no index exists, returns the rightmost index.\r\n * @param maskCharData\r\n * @param index\r\n */\r\nexport function getRightFormatIndex(maskCharData: IMaskValue[], index: number): number {\r\n  for (let i = 0; i < maskCharData.length; i++) {\r\n    if (maskCharData[i].displayIndex >= index) {\r\n      return maskCharData[i].displayIndex;\r\n    }\r\n  }\r\n  return maskCharData[maskCharData.length - 1].displayIndex;\r\n}\r\n\r\n/**\r\n * Get the next format index left of a specified index.\r\n * If no index exists, returns the leftmost index.\r\n * @param maskCharData\r\n * @param index\r\n */\r\nexport function getLeftFormatIndex(maskCharData: IMaskValue[], index: number): number {\r\n  for (let i = maskCharData.length - 1; i >= 0; i--) {\r\n    if (maskCharData[i].displayIndex < index) {\r\n      return maskCharData[i].displayIndex;\r\n    }\r\n  }\r\n  return maskCharData[0].displayIndex;\r\n}\r\n\r\n/**\r\n * Deletes all values in maskCharData with a displayIndex that falls inside the specified range.\r\n * maskCharData is modified inline and also returned.\r\n * @param maskCharData\r\n * @param selectionStart\r\n * @param selectionCount\r\n */\r\nexport function clearRange(maskCharData: IMaskValue[], selectionStart: number, selectionCount: number): IMaskValue[] {\r\n  for (let i = 0; i < maskCharData.length; i++) {\r\n    if (maskCharData[i].displayIndex >= selectionStart) {\r\n      if (maskCharData[i].displayIndex >= selectionStart + selectionCount) {\r\n        break;\r\n      }\r\n      maskCharData[i].value = undefined;\r\n    }\r\n  }\r\n  return maskCharData;\r\n}\r\n\r\n/**\r\n * Deletes the input character at or after a specified index and returns the new array of charData\r\n * maskCharData is modified inline and also returned.\r\n * @param maskCharData\r\n * @param selectionStart\r\n */\r\nexport function clearNext(maskCharData: IMaskValue[], selectionStart: number): IMaskValue[] {\r\n  for (let i = 0; i < maskCharData.length; i++) {\r\n    if (maskCharData[i].displayIndex >= selectionStart) {\r\n      maskCharData[i].value = undefined;\r\n      break;\r\n    }\r\n  }\r\n  return maskCharData;\r\n}\r\n\r\n/**\r\n * Deletes the input character before a specified index and returns the new array of charData\r\n * maskCharData is modified inline and also returned.\r\n * @param maskCharData\r\n * @param selectionStart\r\n */\r\nexport function clearPrev(maskCharData: IMaskValue[], selectionStart: number): IMaskValue[] {\r\n  for (let i = maskCharData.length - 1; i >= 0; i--) {\r\n    if (maskCharData[i].displayIndex < selectionStart) {\r\n      maskCharData[i].value = undefined;\r\n      break;\r\n    }\r\n  }\r\n  return maskCharData;\r\n}\r\n\r\n/**\r\n * Deletes all values in maskCharData with a displayIndex that falls inside the specified range.\r\n * Modifies the maskCharData inplace with the passed string and returns the display index of the\r\n * next format character after the inserted string.\r\n * @param maskCharData\r\n * @param selectionStart\r\n * @param selectionCount\r\n * @return The displayIndex of the next format character\r\n */\r\nexport function insertString(maskCharData: IMaskValue[], selectionStart: number, newString: string): number {\r\n  let stringIndex = 0;\r\n  let nextIndex = 0;\r\n  let isStringInserted = false;\r\n\r\n  // Iterate through _maskCharData finding values with a displayIndex after the specified range start\r\n  for (let i = 0; i < maskCharData.length && stringIndex < newString.length; i++) {\r\n    if (maskCharData[i].displayIndex >= selectionStart) {\r\n      isStringInserted = true;\r\n      nextIndex = maskCharData[i].displayIndex;\r\n      // Find the next character in the newString that matches the format\r\n      while (stringIndex < newString.length) {\r\n        // If the character matches the format regexp, set the maskCharData to the new character\r\n        if (maskCharData[i].format.test(newString.charAt(stringIndex))) {\r\n          maskCharData[i].value = newString.charAt(stringIndex++);\r\n          // Set the nextIndex to the display index of the next mask format character.\r\n          if (i + 1 < maskCharData.length) {\r\n            nextIndex = maskCharData[i + 1].displayIndex;\r\n          } else {\r\n            nextIndex++;\r\n          }\r\n          break;\r\n        }\r\n        stringIndex++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return isStringInserted ? nextIndex : selectionStart;\r\n}\r\n"]}