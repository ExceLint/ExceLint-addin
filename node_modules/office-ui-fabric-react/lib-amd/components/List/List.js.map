{"version":3,"file":"List.js","sourceRoot":"../src/","sources":["components/List/List.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\r\nimport {\r\n  BaseComponent,\r\n  IRectangle,\r\n  css,\r\n  findIndex,\r\n  findScrollableParent,\r\n  getParent,\r\n  divProperties,\r\n  getNativeProps,\r\n  IRenderFunction\r\n} from '../../Utilities';\r\nimport { IList, IListProps, IPage, IPageProps, ScrollToMode } from './List.types';\r\n\r\nconst RESIZE_DELAY = 16;\r\nconst MIN_SCROLL_UPDATE_DELAY = 100;\r\nconst MAX_SCROLL_UPDATE_DELAY = 500;\r\nconst IDLE_DEBOUNCE_DELAY = 200;\r\n// The amount of time to wait before declaring that the list isn't scrolling\r\nconst DONE_SCROLLING_WAIT = 500;\r\nconst DEFAULT_ITEMS_PER_PAGE = 10;\r\nconst DEFAULT_PAGE_HEIGHT = 30;\r\nconst DEFAULT_RENDERED_WINDOWS_BEHIND = 2;\r\nconst DEFAULT_RENDERED_WINDOWS_AHEAD = 2;\r\nconst PAGE_KEY_PREFIX = 'page-';\r\nconst SPACER_KEY_PREFIX = 'spacer-';\r\n\r\nexport interface IListState<T = any> {\r\n  pages?: IPage<T>[];\r\n\r\n  /** The last versionstamp for  */\r\n  measureVersion?: number;\r\n  isScrolling?: boolean;\r\n}\r\n\r\ninterface IPageCacheItem<T> {\r\n  page: IPage<T>;\r\n  pageElement?: JSX.Element;\r\n}\r\n\r\ninterface IPageCache<T> {\r\n  [key: string]: IPageCacheItem<T>;\r\n}\r\n\r\nconst EMPTY_RECT = {\r\n  top: -1,\r\n  bottom: -1,\r\n  left: -1,\r\n  right: -1,\r\n  width: 0,\r\n  height: 0\r\n};\r\n\r\n// Naming expensive measures so that they're named in profiles.\r\nconst _measurePageRect = (element: HTMLElement) => element.getBoundingClientRect();\r\nconst _measureSurfaceRect = _measurePageRect;\r\nconst _measureScrollRect = _measurePageRect;\r\n\r\n/**\r\n * The List renders virtualized pages of items. Each page's item count is determined by the getItemCountForPage callback if\r\n * provided by the caller, or 10 as default. Each page's height is determined by the getPageHeight callback if provided by\r\n * the caller, or by cached measurements if available, or by a running average, or a default fallback.\r\n *\r\n * The algorithm for rendering pages works like this:\r\n *\r\n * 1. Predict visible pages based on \"current measure data\" (page heights, surface position, visible window)\r\n * 2. If changes are necessary, apply changes (add/remove pages)\r\n * 3. For pages that are added, measure the page heights if we need to using getBoundingClientRect\r\n * 4. If measurements don't match predictions, update measure data and goto step 1 asynchronously\r\n *\r\n * Measuring too frequently can pull performance down significantly. To compensate, we cache measured values so that\r\n * we can avoid re-measuring during operations that should not alter heights, like scrolling.\r\n *\r\n * To optimize glass rendering performance, onShouldVirtualize can be set. When onShouldVirtualize return false,\r\n * List will run in fast mode (not virtualized) to render all items without any measurements to improve page load time. And we\r\n * start doing measurements and rendering in virtualized mode when items grows larger than this threshold.\r\n *\r\n * However, certain operations can make measure data stale. For example, resizing the list, or passing in new props,\r\n * or forcing an update change cause pages to shrink/grow. When these operations occur, we increment a measureVersion\r\n * number, which we associate with cached measurements and use to determine if a remeasure should occur.\r\n */\r\nexport class List<T = any> extends BaseComponent<IListProps<T>, IListState<T>> implements IList {\r\n  public static defaultProps = {\r\n    startIndex: 0,\r\n    onRenderCell: (item: any, index: number, containsFocus: boolean) => <>{(item && item.name) || ''}</>,\r\n    renderedWindowsAhead: DEFAULT_RENDERED_WINDOWS_AHEAD,\r\n    renderedWindowsBehind: DEFAULT_RENDERED_WINDOWS_BEHIND\r\n  };\r\n\r\n  public refs: {\r\n    [key: string]: React.ReactInstance;\r\n  };\r\n\r\n  private _root = React.createRef<HTMLDivElement>();\r\n  private _surface = React.createRef<HTMLDivElement>();\r\n\r\n  private _estimatedPageHeight: number;\r\n  private _totalEstimates: number;\r\n  private _cachedPageHeights: {\r\n    [key: string]: {\r\n      height: number;\r\n      measureVersion: number;\r\n    };\r\n  };\r\n  private _focusedIndex: number;\r\n  private _scrollElement: HTMLElement;\r\n  private _hasCompletedFirstRender: boolean;\r\n\r\n  // surface rect relative to window\r\n  private _surfaceRect: IRectangle;\r\n\r\n  // The visible rect that we're required to render given the current list state.\r\n  private _requiredRect: IRectangle | null;\r\n\r\n  // The visible rect that we're allowed to keep rendered. Pages outside of this rect will be removed.\r\n  private _allowedRect: IRectangle;\r\n\r\n  // materialized rect around visible items, relative to surface\r\n  private _materializedRect: IRectangle | null;\r\n\r\n  private _requiredWindowsAhead: number;\r\n  private _requiredWindowsBehind: number;\r\n\r\n  private _measureVersion: number;\r\n  private _scrollHeight: number;\r\n  private _scrollTop: number;\r\n  private _pageCache: IPageCache<T>;\r\n\r\n  constructor(props: IListProps<T>) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      pages: [],\r\n      isScrolling: false\r\n    };\r\n\r\n    this._estimatedPageHeight = 0;\r\n    this._totalEstimates = 0;\r\n    this._requiredWindowsAhead = 0;\r\n    this._requiredWindowsBehind = 0;\r\n\r\n    // Track the measure version for everything.\r\n    this._measureVersion = 0;\r\n\r\n    // Ensure that scrolls are lazy updated.\r\n    this._onAsyncScroll = this._async.debounce(this._onAsyncScroll, MIN_SCROLL_UPDATE_DELAY, {\r\n      leading: false,\r\n      maxWait: MAX_SCROLL_UPDATE_DELAY\r\n    });\r\n\r\n    this._onAsyncIdle = this._async.debounce(this._onAsyncIdle, IDLE_DEBOUNCE_DELAY, {\r\n      leading: false\r\n    });\r\n\r\n    this._onAsyncResize = this._async.debounce(this._onAsyncResize, RESIZE_DELAY, {\r\n      leading: false\r\n    });\r\n\r\n    this._onScrollingDone = this._async.debounce(this._onScrollingDone, DONE_SCROLLING_WAIT, {\r\n      leading: false\r\n    });\r\n\r\n    this._cachedPageHeights = {};\r\n    this._estimatedPageHeight = 0;\r\n    this._focusedIndex = -1;\r\n    this._pageCache = {};\r\n  }\r\n\r\n  /**\r\n   * Scroll to the given index. By default will bring the page the specified item is on into the view. If a callback\r\n   * to measure the height of an individual item is specified, will only scroll to bring the specific item into view.\r\n   *\r\n   * Note: with items of variable height and no passed in `getPageHeight` method, the list might jump after scrolling\r\n   * when windows before/ahead are being rendered, and the estimated height is replaced using actual elements.\r\n   *\r\n   * @param index - Index of item to scroll to\r\n   * @param measureItem - Optional callback to measure the height of an individual item\r\n   * @param scrollToMode - Optional defines where in the window the item should be positioned to when scrolling\r\n   */\r\n  public scrollToIndex(index: number, measureItem?: (itemIndex: number) => number, scrollToMode: ScrollToMode = ScrollToMode.auto): void {\r\n    const startIndex = this.props.startIndex as number;\r\n    const renderCount = this._getRenderCount();\r\n    const endIndex = startIndex + renderCount;\r\n\r\n    const allowedRect = this._allowedRect;\r\n\r\n    let scrollTop = 0;\r\n\r\n    let itemsPerPage = 1;\r\n    for (let itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {\r\n      const pageSpecification = this._getPageSpecification(itemIndex, allowedRect);\r\n\r\n      const pageHeight = pageSpecification.height;\r\n      itemsPerPage = pageSpecification.itemCount;\r\n\r\n      const requestedIndexIsInPage = itemIndex <= index && itemIndex + itemsPerPage > index;\r\n      if (requestedIndexIsInPage) {\r\n        // We have found the page. If the user provided a way to measure an individual item, we will try to scroll in just\r\n        // the given item, otherwise we'll only bring the page into view\r\n        if (measureItem) {\r\n          const scrollRect = _measureScrollRect(this._scrollElement);\r\n          const scrollWindow = {\r\n            top: this._scrollElement.scrollTop,\r\n            bottom: this._scrollElement.scrollTop + scrollRect.height\r\n          };\r\n\r\n          // Adjust for actual item position within page\r\n          const itemPositionWithinPage = index - itemIndex;\r\n          for (let itemIndexInPage = 0; itemIndexInPage < itemPositionWithinPage; ++itemIndexInPage) {\r\n            scrollTop += measureItem(itemIndex + itemIndexInPage);\r\n          }\r\n          const scrollBottom = scrollTop + measureItem(index);\r\n\r\n          // If scrollToMode is set to something other than auto, we always want to\r\n          // scroll the item into a specific position on the page.\r\n          switch (scrollToMode) {\r\n            case ScrollToMode.top:\r\n              this._scrollElement.scrollTop = scrollTop;\r\n              return;\r\n            case ScrollToMode.bottom:\r\n              this._scrollElement.scrollTop = scrollBottom - scrollRect.height;\r\n              return;\r\n            case ScrollToMode.center:\r\n              this._scrollElement.scrollTop = (scrollTop + scrollBottom - scrollRect.height) / 2;\r\n              return;\r\n            case ScrollToMode.auto:\r\n            default:\r\n              break;\r\n          }\r\n\r\n          const itemIsFullyVisible = scrollTop >= scrollWindow.top && scrollBottom <= scrollWindow.bottom;\r\n          if (itemIsFullyVisible) {\r\n            // Item is already visible, do nothing.\r\n            return;\r\n          }\r\n\r\n          const itemIsPartiallyAbove = scrollTop < scrollWindow.top;\r\n          const itemIsPartiallyBelow = scrollBottom > scrollWindow.bottom;\r\n\r\n          if (itemIsPartiallyAbove) {\r\n            //  We will just scroll to 'scrollTop'\r\n            //  .------.   - scrollTop\r\n            //  |Item  |\r\n            //  | .----|-. - scrollWindow.top\r\n            //  '------' |\r\n            //    |      |\r\n            //    '------'\r\n          } else if (itemIsPartiallyBelow) {\r\n            //  Adjust scrollTop position to just bring in the element\r\n            // .------.  - scrollTop\r\n            // |      |\r\n            // | .------.\r\n            // '-|----' | - scrollWindow.bottom\r\n            //   | Item |\r\n            //   '------' - scrollBottom\r\n            scrollTop = scrollBottom - scrollRect.height;\r\n          }\r\n        }\r\n\r\n        this._scrollElement.scrollTop = scrollTop;\r\n        return;\r\n      }\r\n\r\n      scrollTop += pageHeight;\r\n    }\r\n  }\r\n\r\n  public getStartItemIndexInView(measureItem?: (itemIndex: number) => number): number {\r\n    const pages = this.state.pages || [];\r\n    for (const page of pages) {\r\n      const isPageVisible = !page.isSpacer && (this._scrollTop || 0) >= page.top && (this._scrollTop || 0) <= page.top + page.height;\r\n      if (isPageVisible) {\r\n        if (!measureItem) {\r\n          const rowHeight = Math.floor(page.height / page.itemCount);\r\n          return page.startIndex + Math.floor((this._scrollTop - page.top) / rowHeight);\r\n        } else {\r\n          let totalRowHeight = 0;\r\n          for (let itemIndex = page.startIndex; itemIndex < page.startIndex + page.itemCount; itemIndex++) {\r\n            const rowHeight = measureItem(itemIndex);\r\n            if (page.top + totalRowHeight <= this._scrollTop && this._scrollTop < page.top + totalRowHeight + rowHeight) {\r\n              return itemIndex;\r\n            } else {\r\n              totalRowHeight += rowHeight;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  public componentDidMount(): void {\r\n    this._updatePages();\r\n    this._measureVersion++;\r\n    this._scrollElement = findScrollableParent(this._root.current) as HTMLElement;\r\n\r\n    this._events.on(window, 'resize', this._onAsyncResize);\r\n    if (this._root.current) {\r\n      this._events.on(this._root.current, 'focus', this._onFocus, true);\r\n    }\r\n    if (this._scrollElement) {\r\n      this._events.on(this._scrollElement, 'scroll', this._onScroll);\r\n      this._events.on(this._scrollElement, 'scroll', this._onAsyncScroll);\r\n    }\r\n  }\r\n\r\n  public componentWillReceiveProps(newProps: IListProps<T>): void {\r\n    if (\r\n      newProps.items !== this.props.items ||\r\n      newProps.renderCount !== this.props.renderCount ||\r\n      newProps.startIndex !== this.props.startIndex\r\n    ) {\r\n      // We have received new items so we want to make sure that initially we only render a single window to\r\n      // fill the currently visible rect, and then later render additional windows.\r\n      this._resetRequiredWindows();\r\n      this._requiredRect = null;\r\n\r\n      this._measureVersion++;\r\n      this._invalidatePageCache();\r\n      this._updatePages(newProps);\r\n    }\r\n  }\r\n\r\n  public shouldComponentUpdate(newProps: IListProps<T>, newState: IListState<T>): boolean {\r\n    const { pages: oldPages } = this.state;\r\n    const { pages: newPages } = newState;\r\n    let shouldComponentUpdate = false;\r\n\r\n    // Update if the page stops scrolling\r\n    if (!newState.isScrolling && this.state.isScrolling) {\r\n      return true;\r\n    }\r\n\r\n    if (newProps.items === this.props.items && oldPages!.length === newPages!.length) {\r\n      for (let i = 0; i < oldPages!.length; i++) {\r\n        const oldPage = oldPages![i];\r\n        const newPage = newPages![i];\r\n\r\n        if (oldPage.key !== newPage.key || oldPage.itemCount !== newPage.itemCount) {\r\n          shouldComponentUpdate = true;\r\n          break;\r\n        }\r\n      }\r\n    } else {\r\n      shouldComponentUpdate = true;\r\n    }\r\n\r\n    return shouldComponentUpdate;\r\n  }\r\n\r\n  public forceUpdate(): void {\r\n    this._invalidatePageCache();\r\n    // Ensure that when the list is force updated we update the pages first before render.\r\n    this._updateRenderRects(this.props, true);\r\n    this._updatePages();\r\n    this._measureVersion++;\r\n\r\n    super.forceUpdate();\r\n  }\r\n\r\n  public render(): JSX.Element {\r\n    const { className, role = 'list' } = this.props;\r\n    const { pages = [] } = this.state;\r\n    const pageElements: JSX.Element[] = [];\r\n    const divProps = getNativeProps(this.props, divProperties);\r\n\r\n    for (const page of pages) {\r\n      pageElements.push(this._renderPage(page));\r\n    }\r\n\r\n    return (\r\n      <div ref={this._root} {...divProps} role={pageElements.length > 0 ? role : undefined} className={css('ms-List', className)}>\r\n        <div ref={this._surface} className={css('ms-List-surface')} role=\"presentation\">\r\n          {pageElements}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  private _shouldVirtualize(props: IListProps<T> = this.props): boolean {\r\n    const { onShouldVirtualize } = props;\r\n    return !onShouldVirtualize || onShouldVirtualize(props);\r\n  }\r\n\r\n  /**\r\n   * when props.items change or forceUpdate called, throw away cached pages\r\n   */\r\n  private _invalidatePageCache(): void {\r\n    this._pageCache = {};\r\n  }\r\n\r\n  private _renderPage(page: IPage<T>): JSX.Element {\r\n    const { usePageCache } = this.props;\r\n    let cachedPage;\r\n    // if usePageCache is set and cached page element can be found, just return cached page\r\n    if (usePageCache) {\r\n      cachedPage = this._pageCache[page.key];\r\n      if (cachedPage && cachedPage.pageElement) {\r\n        return cachedPage.pageElement;\r\n      }\r\n    }\r\n\r\n    const pageStyle = this._getPageStyle(page);\r\n\r\n    const { onRenderPage = this._onRenderPage } = this.props;\r\n\r\n    const pageElement = onRenderPage(\r\n      {\r\n        page: page,\r\n        className: css('ms-List-page'),\r\n        key: page.key,\r\n        ref: page.key,\r\n        style: pageStyle,\r\n        role: 'presentation'\r\n      },\r\n      this._onRenderPage\r\n    );\r\n\r\n    // cache the first page for now since it is re-rendered a lot times unnecessarily.\r\n    // todo: a more aggresive caching mechanism is to cache pages constaining the items not changed.\r\n    // now we re-render pages too frequently, for example, props.items increased from 30 to 60, although the\r\n    // first 30 items did not change, we still re-rendered all of them in this props.items change.\r\n    if (usePageCache && page.startIndex === 0) {\r\n      this._pageCache[page.key] = {\r\n        page: page,\r\n        pageElement: pageElement\r\n      };\r\n    }\r\n    return pageElement;\r\n  }\r\n\r\n  /** Generate the style object for the page. */\r\n  private _getPageStyle(page: IPage<T>): React.StyleHTMLAttributes<HTMLDivElement> {\r\n    const { getPageStyle } = this.props;\r\n\r\n    return {\r\n      ...(getPageStyle ? getPageStyle(page) : {}),\r\n      ...(!page.items\r\n        ? {\r\n            height: page.height\r\n          }\r\n        : {})\r\n    };\r\n  }\r\n\r\n  private _onRenderPage = (pageProps: IPageProps<T>, defaultRender?: IRenderFunction<IPageProps<T>>): any => {\r\n    const { onRenderCell, role } = this.props;\r\n\r\n    const {\r\n      page: { items = [], startIndex },\r\n      ...divProps\r\n    } = pageProps;\r\n\r\n    // only assign list item role if no role is assigned\r\n    const cellRole = role === undefined ? 'listitem' : 'presentation';\r\n    const cells: React.ReactNode[] = [];\r\n\r\n    for (let i = 0; i < items.length; i++) {\r\n      const index = startIndex + i;\r\n      const item = items[i];\r\n\r\n      let itemKey = this.props.getKey ? this.props.getKey(item, index) : item && (item as any).key;\r\n\r\n      if (itemKey === null || itemKey === undefined) {\r\n        itemKey = index;\r\n      }\r\n\r\n      cells.push(\r\n        <div role={cellRole} className={css('ms-List-cell')} key={itemKey} data-list-index={index} data-automationid=\"ListCell\">\r\n          {onRenderCell && onRenderCell(item, index, this.state.isScrolling)}\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return <div {...divProps}>{cells}</div>;\r\n  };\r\n\r\n  /** Track the last item index focused so that we ensure we keep it rendered. */\r\n  private _onFocus(ev: any): void {\r\n    let target = ev.target as HTMLElement;\r\n\r\n    while (target !== this._surface.current) {\r\n      const indexString = target.getAttribute('data-list-index');\r\n\r\n      if (indexString) {\r\n        this._focusedIndex = Number(indexString);\r\n        break;\r\n      }\r\n\r\n      target = getParent(target) as HTMLElement;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called synchronously to reset the required render range to 0 on scrolling. After async scroll has executed,\r\n   * we will call onAsyncIdle which will reset it back to it's correct value.\r\n   */\r\n  private _onScroll(): void {\r\n    if (!this.state.isScrolling) {\r\n      this.setState({ isScrolling: true });\r\n    }\r\n    this._resetRequiredWindows();\r\n    this._onScrollingDone();\r\n  }\r\n\r\n  private _resetRequiredWindows(): void {\r\n    this._requiredWindowsAhead = 0;\r\n    this._requiredWindowsBehind = 0;\r\n  }\r\n\r\n  /**\r\n   * Debounced method to asynchronously update the visible region on a scroll event.\r\n   */\r\n  private _onAsyncScroll(): void {\r\n    this._updateRenderRects();\r\n\r\n    // Only update pages when the visible rect falls outside of the materialized rect.\r\n    if (!this._materializedRect || !_isContainedWithin(this._requiredRect as IRectangle, this._materializedRect)) {\r\n      this._updatePages();\r\n    } else {\r\n      // console.log('requiredRect contained in materialized', this._requiredRect, this._materializedRect);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This is an async debounced method that will try and increment the windows we render. If we can increment\r\n   * either, we increase the amount we render and re-evaluate.\r\n   */\r\n  private _onAsyncIdle(): void {\r\n    const { renderedWindowsAhead, renderedWindowsBehind } = this.props;\r\n    const { _requiredWindowsAhead: requiredWindowsAhead, _requiredWindowsBehind: requiredWindowsBehind } = this;\r\n    const windowsAhead = Math.min(renderedWindowsAhead as number, requiredWindowsAhead + 1);\r\n    const windowsBehind = Math.min(renderedWindowsBehind as number, requiredWindowsBehind + 1);\r\n\r\n    if (windowsAhead !== requiredWindowsAhead || windowsBehind !== requiredWindowsBehind) {\r\n      // console.log('idling', windowsBehind, windowsAhead);\r\n\r\n      this._requiredWindowsAhead = windowsAhead;\r\n      this._requiredWindowsBehind = windowsBehind;\r\n      this._updateRenderRects();\r\n      this._updatePages();\r\n    }\r\n\r\n    if (renderedWindowsAhead! > windowsAhead || renderedWindowsBehind! > windowsBehind) {\r\n      // Async increment on next tick.\r\n      this._onAsyncIdle();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Function to call when the list is done scrolling.\r\n   * This function is debounced.\r\n   */\r\n  private _onScrollingDone(): void {\r\n    this.setState({ isScrolling: false });\r\n  }\r\n\r\n  private _onAsyncResize(): void {\r\n    this.forceUpdate();\r\n  }\r\n\r\n  private _updatePages(props: IListProps<T> = this.props): void {\r\n    // console.log('updating pages');\r\n\r\n    if (!this._requiredRect) {\r\n      this._updateRenderRects(props);\r\n    }\r\n\r\n    const newListState = this._buildPages(props);\r\n    const oldListPages = this.state.pages!;\r\n\r\n    this._notifyPageChanges(oldListPages, newListState.pages!);\r\n\r\n    this.setState(newListState, () => {\r\n      // If we weren't provided with the page height, measure the pages\r\n      if (!props.getPageHeight) {\r\n        // If measured version is invalid since we've updated the DOM\r\n        const heightsChanged = this._updatePageMeasurements(newListState.pages!);\r\n\r\n        // On first render, we should re-measure so that we don't get a visual glitch.\r\n        if (heightsChanged) {\r\n          this._materializedRect = null;\r\n          if (!this._hasCompletedFirstRender) {\r\n            this._hasCompletedFirstRender = true;\r\n            this._updatePages(props);\r\n          } else {\r\n            this._onAsyncScroll();\r\n          }\r\n        } else {\r\n          // Enqueue an idle bump.\r\n          this._onAsyncIdle();\r\n        }\r\n      } else {\r\n        // Enqueue an idle bump\r\n        this._onAsyncIdle();\r\n      }\r\n\r\n      // Notify the caller that rendering the new pages has completed\r\n      if (props.onPagesUpdated) {\r\n        props.onPagesUpdated(this.state.pages as IPage<T>[]);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Notify consumers that the rendered pages have changed\r\n   * @param oldPages - The old pages\r\n   * @param newPages - The new pages\r\n   * @param props - The props to use\r\n   */\r\n  private _notifyPageChanges(oldPages: IPage<T>[], newPages: IPage<T>[], props: IListProps<T> = this.props): void {\r\n    const { onPageAdded, onPageRemoved } = props;\r\n\r\n    if (onPageAdded || onPageRemoved) {\r\n      const renderedIndexes: {\r\n        [index: number]: IPage<T>;\r\n      } = {};\r\n\r\n      for (const page of oldPages) {\r\n        if (page.items) {\r\n          renderedIndexes[page.startIndex] = page;\r\n        }\r\n      }\r\n\r\n      for (const page of newPages) {\r\n        if (page.items) {\r\n          if (!renderedIndexes[page.startIndex]) {\r\n            this._onPageAdded(page);\r\n          } else {\r\n            delete renderedIndexes[page.startIndex];\r\n          }\r\n        }\r\n      }\r\n\r\n      for (const index in renderedIndexes) {\r\n        if (renderedIndexes.hasOwnProperty(index)) {\r\n          this._onPageRemoved(renderedIndexes[index]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private _updatePageMeasurements(pages: IPage<T>[]): boolean {\r\n    let heightChanged = false;\r\n\r\n    // when not in virtualize mode, we render all the items without page measurement\r\n    if (!this._shouldVirtualize()) {\r\n      return heightChanged;\r\n    }\r\n\r\n    for (let i = 0; i < pages.length; i++) {\r\n      const page = pages[i];\r\n\r\n      if (page.items) {\r\n        heightChanged = this._measurePage(page) || heightChanged;\r\n      }\r\n    }\r\n\r\n    return heightChanged;\r\n  }\r\n\r\n  /**\r\n   * Given a page, measure its dimensions, update cache.\r\n   * @returns True if the height has changed.\r\n   */\r\n  private _measurePage(page: IPage<T>): boolean {\r\n    let hasChangedHeight = false;\r\n    const pageElement = this.refs[page.key] as HTMLElement;\r\n    const cachedHeight = this._cachedPageHeights[page.startIndex];\r\n\r\n    // console.log('   * measure attempt', page.startIndex, cachedHeight);\r\n\r\n    if (pageElement && this._shouldVirtualize() && (!cachedHeight || cachedHeight.measureVersion !== this._measureVersion)) {\r\n      const newClientRect = {\r\n        width: pageElement.clientWidth,\r\n        height: pageElement.clientHeight\r\n      };\r\n\r\n      if (newClientRect.height || newClientRect.width) {\r\n        hasChangedHeight = page.height !== newClientRect.height;\r\n\r\n        // console.warn(' *** expensive page measure', page.startIndex, page.height, newClientRect.height);\r\n\r\n        page.height = newClientRect.height;\r\n\r\n        this._cachedPageHeights[page.startIndex] = {\r\n          height: newClientRect.height,\r\n          measureVersion: this._measureVersion\r\n        };\r\n\r\n        this._estimatedPageHeight = Math.round(\r\n          (this._estimatedPageHeight * this._totalEstimates + newClientRect.height) / (this._totalEstimates + 1)\r\n        );\r\n\r\n        this._totalEstimates++;\r\n      }\r\n    }\r\n\r\n    return hasChangedHeight;\r\n  }\r\n\r\n  /** Called when a page has been added to the DOM. */\r\n  private _onPageAdded(page: IPage<T>): void {\r\n    const { onPageAdded } = this.props;\r\n\r\n    // console.log('page added', page.startIndex, this.state.pages.map(page => page.key).join(', '));\r\n\r\n    if (onPageAdded) {\r\n      onPageAdded(page);\r\n    }\r\n  }\r\n\r\n  /** Called when a page has been removed from the DOM. */\r\n  private _onPageRemoved(page: IPage<T>): void {\r\n    const { onPageRemoved } = this.props;\r\n\r\n    // console.log('  --- page removed', page.startIndex, this.state.pages.map(page => page.key).join(', '));\r\n\r\n    if (onPageRemoved) {\r\n      onPageRemoved(page);\r\n    }\r\n  }\r\n\r\n  /** Build up the pages that should be rendered. */\r\n  private _buildPages(props: IListProps<T>): IListState<T> {\r\n    let { renderCount } = props;\r\n    const { items, startIndex, getPageHeight } = props;\r\n\r\n    renderCount = this._getRenderCount(props);\r\n\r\n    const materializedRect = { ...EMPTY_RECT };\r\n    const pages: IPage<T>[] = [];\r\n\r\n    let itemsPerPage = 1;\r\n    let pageTop = 0;\r\n    let currentSpacer = null;\r\n    const focusedIndex = this._focusedIndex;\r\n    const endIndex = startIndex! + renderCount;\r\n    const shouldVirtualize = this._shouldVirtualize(props);\r\n\r\n    // First render is very important to track; when we render cells, we have no idea of estimated page height.\r\n    // So we should default to rendering only the first page so that we can get information.\r\n    // However if the user provides a measure function, let's just assume they know the right heights.\r\n    const isFirstRender = this._estimatedPageHeight === 0 && !getPageHeight;\r\n\r\n    const allowedRect = this._allowedRect;\r\n\r\n    for (let itemIndex = startIndex!; itemIndex < endIndex; itemIndex += itemsPerPage) {\r\n      const pageSpecification = this._getPageSpecification(itemIndex, allowedRect);\r\n      const pageHeight = pageSpecification.height;\r\n      const pageData = pageSpecification.data;\r\n      const key = pageSpecification.key;\r\n\r\n      itemsPerPage = pageSpecification.itemCount;\r\n\r\n      const pageBottom = pageTop + pageHeight - 1;\r\n\r\n      const isPageRendered =\r\n        findIndex(this.state.pages as IPage<T>[], (page: IPage<T>) => !!page.items && page.startIndex === itemIndex) > -1;\r\n      const isPageInAllowedRange = !allowedRect || (pageBottom >= allowedRect.top && pageTop <= allowedRect.bottom!);\r\n      const isPageInRequiredRange = !this._requiredRect || (pageBottom >= this._requiredRect.top && pageTop <= this._requiredRect.bottom!);\r\n      const isPageVisible = (!isFirstRender && (isPageInRequiredRange || (isPageInAllowedRange && isPageRendered))) || !shouldVirtualize;\r\n      const isPageFocused = focusedIndex >= itemIndex && focusedIndex < itemIndex + itemsPerPage;\r\n      const isFirstPage = itemIndex === startIndex;\r\n\r\n      // console.log('building page', itemIndex, 'pageTop: ' + pageTop, 'inAllowed: ' +\r\n      // isPageInAllowedRange, 'inRequired: ' + isPageInRequiredRange);\r\n\r\n      // Only render whats visible, focused, or first page,\r\n      // or when running in fast rendering mode (not in virtualized mode), we render all current items in pages\r\n      if (isPageVisible || isPageFocused || isFirstPage) {\r\n        if (currentSpacer) {\r\n          pages.push(currentSpacer);\r\n          currentSpacer = null;\r\n        }\r\n\r\n        const itemsInPage = Math.min(itemsPerPage, endIndex - itemIndex);\r\n        const newPage = this._createPage(key, items!.slice(itemIndex, itemIndex + itemsInPage), itemIndex, undefined, undefined, pageData);\r\n\r\n        newPage.top = pageTop;\r\n        newPage.height = pageHeight;\r\n\r\n        pages.push(newPage);\r\n\r\n        if (isPageInRequiredRange && this._allowedRect) {\r\n          _mergeRect(materializedRect, {\r\n            top: pageTop,\r\n            bottom: pageBottom,\r\n            height: pageHeight,\r\n            left: allowedRect.left,\r\n            right: allowedRect.right,\r\n            width: allowedRect.width\r\n          });\r\n        }\r\n      } else {\r\n        if (!currentSpacer) {\r\n          currentSpacer = this._createPage(SPACER_KEY_PREFIX + itemIndex, undefined, itemIndex, 0, undefined, pageData, true /*isSpacer*/);\r\n        }\r\n        currentSpacer.height = (currentSpacer.height || 0) + (pageBottom - pageTop) + 1;\r\n        currentSpacer.itemCount += itemsPerPage;\r\n      }\r\n      pageTop += pageBottom - pageTop + 1;\r\n\r\n      // in virtualized mode, we render need to render first page then break and measure,\r\n      // otherwise, we render all items without measurement to make rendering fast\r\n      if (isFirstRender && shouldVirtualize) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (currentSpacer) {\r\n      currentSpacer.key = SPACER_KEY_PREFIX + 'end';\r\n      pages.push(currentSpacer);\r\n    }\r\n\r\n    this._materializedRect = materializedRect;\r\n\r\n    // console.log('materialized: ', materializedRect);\r\n    return {\r\n      pages: pages,\r\n      measureVersion: this._measureVersion\r\n    };\r\n  }\r\n\r\n  private _getPageSpecification(\r\n    itemIndex: number,\r\n    visibleRect: IRectangle\r\n  ): {\r\n    // These return values are now no longer optional.\r\n    itemCount: number;\r\n    height: number;\r\n    data?: any;\r\n    key?: string;\r\n  } {\r\n    const { getPageSpecification } = this.props;\r\n    if (getPageSpecification) {\r\n      const pageData = getPageSpecification(itemIndex, visibleRect);\r\n\r\n      const { itemCount = this._getItemCountForPage(itemIndex, visibleRect) } = pageData;\r\n\r\n      const { height = this._getPageHeight(itemIndex, itemCount, visibleRect) } = pageData;\r\n\r\n      return {\r\n        itemCount: itemCount,\r\n        height: height,\r\n        data: pageData.data,\r\n        key: pageData.key\r\n      };\r\n    } else {\r\n      const itemCount = this._getItemCountForPage(itemIndex, visibleRect);\r\n\r\n      return {\r\n        itemCount: itemCount,\r\n        height: this._getPageHeight(itemIndex, itemCount, visibleRect)\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the pixel height of a give page. Will use the props getPageHeight first, and if not provided, fallback to\r\n   * cached height, or estimated page height, or default page height.\r\n   */\r\n  private _getPageHeight(itemIndex: number, itemsPerPage: number, visibleRect: IRectangle): number {\r\n    if (this.props.getPageHeight) {\r\n      return this.props.getPageHeight(itemIndex, visibleRect);\r\n    } else {\r\n      const cachedHeight = this._cachedPageHeights[itemIndex];\r\n\r\n      return cachedHeight ? cachedHeight.height : this._estimatedPageHeight || DEFAULT_PAGE_HEIGHT;\r\n    }\r\n  }\r\n\r\n  private _getItemCountForPage(itemIndex: number, visibileRect: IRectangle): number {\r\n    const itemsPerPage = this.props.getItemCountForPage ? this.props.getItemCountForPage(itemIndex, visibileRect) : DEFAULT_ITEMS_PER_PAGE;\r\n\r\n    return itemsPerPage ? itemsPerPage : DEFAULT_ITEMS_PER_PAGE;\r\n  }\r\n\r\n  private _createPage(\r\n    pageKey: string | undefined,\r\n    items: any[] | undefined,\r\n    startIndex: number = -1,\r\n    count: number = items ? items.length : 0,\r\n    style: React.CSSProperties = {},\r\n    data?: any,\r\n    isSpacer?: boolean\r\n  ): IPage<T> {\r\n    pageKey = pageKey || PAGE_KEY_PREFIX + startIndex;\r\n    const cachedPage = this._pageCache[pageKey];\r\n    if (cachedPage && cachedPage.page) {\r\n      return cachedPage.page;\r\n    }\r\n\r\n    return {\r\n      key: pageKey,\r\n      startIndex: startIndex,\r\n      itemCount: count,\r\n      items: items,\r\n      style: style,\r\n      top: 0,\r\n      height: 0,\r\n      data: data,\r\n      isSpacer: isSpacer || false\r\n    };\r\n  }\r\n\r\n  private _getRenderCount(props?: IListProps<T>): number {\r\n    const { items, startIndex, renderCount } = props || this.props;\r\n\r\n    return renderCount === undefined ? (items ? items.length - startIndex! : 0) : renderCount;\r\n  }\r\n\r\n  /** Calculate the visible rect within the list where top: 0 and left: 0 is the top/left of the list. */\r\n  private _updateRenderRects(props?: IListProps<T>, forceUpdate?: boolean): void {\r\n    props = props || this.props;\r\n    const { renderedWindowsAhead, renderedWindowsBehind } = props;\r\n    const { pages } = this.state;\r\n    // when not in virtualize mode, we render all items without measurement to optimize page rendering perf\r\n    if (!this._shouldVirtualize(props)) {\r\n      return;\r\n    }\r\n\r\n    let surfaceRect = this._surfaceRect;\r\n    const scrollHeight = this._scrollElement && this._scrollElement.scrollHeight;\r\n    const scrollTop = this._scrollElement ? this._scrollElement.scrollTop : 0;\r\n\r\n    // WARNING: EXPENSIVE CALL! We need to know the surface top relative to the window.\r\n    // This needs to be called to recalculate when new pages should be loaded.\r\n    // We check to see how far we've scrolled and if it's further than a third of a page we run it again.\r\n    if (\r\n      this._surface.current &&\r\n      (forceUpdate ||\r\n        !pages ||\r\n        !this._surfaceRect ||\r\n        !scrollHeight ||\r\n        scrollHeight !== this._scrollHeight ||\r\n        Math.abs(this._scrollTop - scrollTop) > this._estimatedPageHeight / 3)\r\n    ) {\r\n      surfaceRect = this._surfaceRect = _measureSurfaceRect(this._surface.current);\r\n      this._scrollTop = scrollTop;\r\n    }\r\n\r\n    // If the scroll height has changed, something in the container likely resized and\r\n    // we should redo the page heights incase their content resized.\r\n    if (forceUpdate || !scrollHeight || scrollHeight !== this._scrollHeight) {\r\n      this._measureVersion++;\r\n    }\r\n\r\n    this._scrollHeight = scrollHeight;\r\n\r\n    // If the surface is above the container top or below the container bottom, or if this is not the first\r\n    // render return empty rect.\r\n    // The first time the list gets rendered we need to calculate the rectangle. The width of the list is\r\n    // used to calculate the width of the list items.\r\n    const visibleTop = Math.max(0, -surfaceRect.top);\r\n    const visibleRect = {\r\n      top: visibleTop,\r\n      left: surfaceRect.left,\r\n      bottom: visibleTop + window.innerHeight,\r\n      right: surfaceRect.right,\r\n      width: surfaceRect.width,\r\n      height: window.innerHeight\r\n    };\r\n\r\n    // The required/allowed rects are adjusted versions of the visible rect.\r\n    this._requiredRect = _expandRect(visibleRect, this._requiredWindowsBehind, this._requiredWindowsAhead);\r\n    this._allowedRect = _expandRect(visibleRect, renderedWindowsBehind!, renderedWindowsAhead!);\r\n  }\r\n}\r\n\r\nfunction _expandRect(rect: IRectangle, pagesBefore: number, pagesAfter: number): IRectangle {\r\n  const top = rect.top - pagesBefore * rect.height;\r\n  const height = rect.height + (pagesBefore + pagesAfter) * rect.height;\r\n\r\n  return {\r\n    top: top,\r\n    bottom: top + height,\r\n    height: height,\r\n    left: rect.left,\r\n    right: rect.right,\r\n    width: rect.width\r\n  };\r\n}\r\n\r\nfunction _isContainedWithin(innerRect: IRectangle, outerRect: IRectangle): boolean {\r\n  return (\r\n    innerRect.top >= outerRect.top &&\r\n    innerRect.left >= outerRect.left &&\r\n    innerRect.bottom! <= outerRect.bottom! &&\r\n    innerRect.right! <= outerRect.right!\r\n  );\r\n}\r\n\r\nfunction _mergeRect(targetRect: IRectangle, newRect: IRectangle): IRectangle {\r\n  targetRect.top = newRect.top < targetRect.top || targetRect.top === -1 ? newRect.top : targetRect.top;\r\n  targetRect.left = newRect.left < targetRect.left || targetRect.left === -1 ? newRect.left : targetRect.left;\r\n  targetRect.bottom = newRect.bottom! > targetRect.bottom! || targetRect.bottom === -1 ? newRect.bottom : targetRect.bottom;\r\n  targetRect.right = newRect.right! > targetRect.right! || targetRect.right === -1 ? newRect.right : targetRect.right;\r\n  targetRect.width = targetRect.right! - targetRect.left + 1;\r\n  targetRect.height = targetRect.bottom! - targetRect.top + 1;\r\n\r\n  return targetRect;\r\n}\r\n"]}