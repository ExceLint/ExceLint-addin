{"version":3,"file":"TextField.Controlled.Example.js","sourceRoot":"../src/","sources":["components/TextField/examples/TextField.Controlled.Example.tsx"],"names":[],"mappings":";;;AAAA,6BAA+B;AAC/B,kEAAiE;AACjE,0DAAyD;AAOzD;IAAgD,sDAAqD;IAArG;QAAA,qEAwCC;QAvCQ,WAAK,GAAqC,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC;QAsBpE,gBAAU,GAAG,UAAC,EAAqC,EAAE,QAAiB;YAC5E,KAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,QAAQ,IAAI,EAAE,EAAE,CAAC,CAAC;QAC5C,CAAC,CAAC;QAEM,gBAAU,GAAG,UAAC,EAAqC,EAAE,QAAiB;YAC5E,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,MAAM,IAAI,CAAC,EAAE;gBACrC,KAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,QAAQ,IAAI,EAAE,EAAE,CAAC,CAAC;aAC3C;iBAAM;gBACL,6FAA6F;gBAC7F,kFAAkF;gBAClF,4FAA4F;gBAC5F,6FAA6F;gBAC7F,kFAAkF;gBAClF,+DAA+D;gBAC/D,KAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,KAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC;aAC9C;QACH,CAAC,CAAC;;IACJ,CAAC;IArCQ,2CAAM,GAAb;QACE,OAAO,CACL,oBAAC,aAAK,IAAC,MAAM,EAAE,EAAE,WAAW,EAAE,EAAE,EAAE;YAChC,oBAAC,qBAAS,IACR,KAAK,EAAC,4BAA4B,EAClC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,EACxB,QAAQ,EAAE,IAAI,CAAC,UAAU,EACzB,MAAM,EAAE,EAAE,UAAU,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE,EAAE,GACtC;YAEF,oBAAC,qBAAS,IACR,KAAK,EAAC,oDAAoD,EAC1D,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,EACxB,QAAQ,EAAE,IAAI,CAAC,UAAU,EACzB,MAAM,EAAE,EAAE,UAAU,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE,EAAE,GACtC,CACI,CACT,CAAC;IACJ,CAAC;IAmBH,iCAAC;AAAD,CAAC,AAxCD,CAAgD,KAAK,CAAC,SAAS,GAwC9D;AAxCY,gEAA0B","sourcesContent":["import * as React from 'react';\r\nimport { TextField } from 'office-ui-fabric-react/lib/TextField';\r\nimport { Stack } from 'office-ui-fabric-react/lib/Stack';\r\n\r\nexport interface ITextFieldControlledExampleState {\r\n  value1: string;\r\n  value2: string;\r\n}\r\n\r\nexport class TextFieldControlledExample extends React.Component<{}, ITextFieldControlledExampleState> {\r\n  public state: ITextFieldControlledExampleState = { value1: '', value2: '' };\r\n\r\n  public render() {\r\n    return (\r\n      <Stack tokens={{ childrenGap: 15 }}>\r\n        <TextField\r\n          label=\"Basic controlled TextField\"\r\n          value={this.state.value1}\r\n          onChange={this._onChange1}\r\n          styles={{ fieldGroup: { width: 300 } }}\r\n        />\r\n\r\n        <TextField\r\n          label=\"Controlled TextField limiting length of value to 5\"\r\n          value={this.state.value2}\r\n          onChange={this._onChange2}\r\n          styles={{ fieldGroup: { width: 100 } }}\r\n        />\r\n      </Stack>\r\n    );\r\n  }\r\n\r\n  private _onChange1 = (ev: React.FormEvent<HTMLInputElement>, newValue?: string) => {\r\n    this.setState({ value1: newValue || '' });\r\n  };\r\n\r\n  private _onChange2 = (ev: React.FormEvent<HTMLInputElement>, newValue?: string) => {\r\n    if (!newValue || newValue.length <= 5) {\r\n      this.setState({ value2: newValue || '' });\r\n    } else {\r\n      // This block should NOT be necessary, but there's currently a bug (#1350) where a controlled\r\n      // TextField will continue to accept input even if its `value` prop isn't updated.\r\n      // (The correct behavior is that the displayed value should *always* match the `value` prop.\r\n      // If the `value` prop isn't updated in response to user input, the input should be ignored.)\r\n      // Because this is a large behavior change, the bug won't be fixed until Fabric 7.\r\n      // As a workaround, force re-rendering with the existing value.\r\n      this.setState({ value2: this.state.value2 });\r\n    }\r\n  };\r\n}\r\n"]}