{"version":3,"file":"Callout.types.js","sourceRoot":"../src/","sources":["components/Callout/Callout.types.ts"],"names":[],"mappings":"","sourcesContent":["import { IStyle, ITheme } from '../../Styling';\r\nimport { DirectionalHint } from '../../common/DirectionalHint';\r\nimport { IPoint, IRectangle, IStyleFunctionOrObject } from '../../Utilities';\r\nimport { ICalloutPositionedInfo } from '../../utilities/positioning';\r\nimport { ILayerProps } from '../../Layer';\r\n\r\nexport interface ICalloutProps extends React.HTMLAttributes<HTMLDivElement> {\r\n  /**\r\n   * The target that the Callout should try to position itself based on.\r\n   * It can be either an Element a querySelector string of a valid Element\r\n   * or a MouseEvent. If MouseEvent is given then the origin point of the event will be used.\r\n   */\r\n  target?: Element | string | MouseEvent | IPoint | null;\r\n\r\n  /**\r\n   * How the element should be positioned\r\n   * @defaultvalue DirectionalHint.BottomAutoEdge\r\n   */\r\n  directionalHint?: DirectionalHint;\r\n\r\n  /**\r\n   * How the element should be positioned in RTL layouts.\r\n   * If not specified, a mirror of `directionalHint` will be used instead\r\n   */\r\n  directionalHintForRTL?: DirectionalHint;\r\n\r\n  /**\r\n   * The gap between the Callout and the target\r\n   * @defaultvalue 0\r\n   */\r\n  gapSpace?: number;\r\n\r\n  /**\r\n   * The width of the beak.\r\n   * @defaultvalue 16\r\n   */\r\n  beakWidth?: number;\r\n\r\n  /**\r\n   * Custom width for callout including borders. If value is 0, no width is applied.\r\n   * @defaultvalue 0\r\n   */\r\n  calloutWidth?: number;\r\n\r\n  /**\r\n   * Custom width for callout including borders. If value is 0, no width is applied.\r\n   * @defaultvalue 0\r\n   */\r\n  calloutMaxWidth?: number;\r\n\r\n  /**\r\n   * The background color of the Callout in hex format ie. #ffffff.\r\n   * @defaultvalue $ms-color-white\r\n   */\r\n  backgroundColor?: string;\r\n\r\n  /**\r\n   * The bounding rectangle for which  the contextual menu can appear in.\r\n   */\r\n  bounds?: IRectangle;\r\n\r\n  /**\r\n   * The minimum distance the callout will be away from the edge of the screen.\r\n   *  @defaultvalue 8\r\n   */\r\n  minPagePadding?: number;\r\n\r\n  /**\r\n   * If true then the beak is visible. If false it will not be shown.\r\n   * @defaultvalue true\r\n   */\r\n  isBeakVisible?: boolean;\r\n\r\n  /**\r\n   * If true then the callout will not dismiss on scroll\r\n   * @defaultvalue false\r\n   */\r\n  preventDismissOnScroll?: boolean;\r\n\r\n  /**\r\n   * If true then the callout will not dismiss on resize\r\n   * @defaultvalue false\r\n   */\r\n  preventDismissOnResize?: boolean;\r\n\r\n  /**\r\n   * If true then the callout will not dismiss when it loses focus\r\n   * @defaultvalue false\r\n   */\r\n  preventDismissOnLostFocus?: boolean;\r\n\r\n  /**\r\n   * If true the position returned will have the menu element cover the target.\r\n   * If false then it will position next to the target;\r\n   * @defaultvalue false\r\n   */\r\n  coverTarget?: boolean;\r\n\r\n  /**\r\n   * If true the positioning logic will prefer to flip edges rather than to nudge the rectangle to fit within bounds,\r\n   * thus making sure the element aligns perfectly with target's alignment edge\r\n   */\r\n  alignTargetEdge?: boolean;\r\n\r\n  /**\r\n   * Aria role assigned to the callout (Eg. dialog, alertdialog).\r\n   */\r\n  role?: string;\r\n\r\n  /**\r\n   * Accessible label text for callout.\r\n   */\r\n  ariaLabel?: string;\r\n\r\n  /**\r\n   *  Defines the element id referencing the element containing label text for callout.\r\n   */\r\n  ariaLabelledBy?: string;\r\n\r\n  /**\r\n   * Defines the element id referencing the element containing the description for the callout.\r\n   */\r\n  ariaDescribedBy?: string;\r\n\r\n  /**\r\n   * CSS class to apply to the callout.\r\n   * @defaultvalue null\r\n   */\r\n  className?: string;\r\n\r\n  /**\r\n   * CSS style to apply to the callout.\r\n   */\r\n  style?: React.CSSProperties;\r\n\r\n  /**\r\n   * Optional callback when the layer content has mounted.\r\n   */\r\n  onLayerMounted?: () => void;\r\n\r\n  /**\r\n   * Optional props to pass to the Layer component hosting the panel.\r\n   */\r\n  layerProps?: ILayerProps;\r\n\r\n  /**\r\n   * Optional callback that is called once the callout has been correctly positioned.\r\n   * @param positions - Gives the user information about how the callout is positioned such as the\r\n   * final edge of the target that it positioned against, the beak position, and the beaks relationship to the\r\n   * edges of the callout.\r\n   */\r\n  onPositioned?: (positions?: ICalloutPositionedInfo) => void;\r\n\r\n  /**\r\n   * Callback when the Callout tries to close.\r\n   */\r\n  onDismiss?: (ev?: any) => void;\r\n\r\n  /**\r\n   * If true do not render on a new layer. If false render on a new layer.\r\n   */\r\n  doNotLayer?: boolean;\r\n\r\n  /**\r\n   * If true the position will not change sides in an attempt to fit the callout within bounds.\r\n   * It will still attempt to align it to whatever bounds are given.\r\n   * @defaultvalue false\r\n   */\r\n  directionalHintFixed?: boolean;\r\n\r\n  /**\r\n   * Specify the final height of the content.\r\n   * To be used when expanding the content dynamically so that callout can adjust its position.\r\n   */\r\n  finalHeight?: number;\r\n\r\n  /**\r\n   * Manually set OverflowYHidden style prop to true on calloutMain element\r\n   * A variety of callout load animations will need this to hide the scollbar that can appear\r\n   */\r\n  hideOverflow?: boolean;\r\n\r\n  /**\r\n   * If true then the callout will attempt to focus the first focusable element that it contains.\r\n   * If it doesn't find an element, no focus will be set and the method will return false.\r\n   * This means that it's the contents responsibility to either set focus or have\r\n   * focusable items.\r\n   * @returns True if focus was set, false if it was not.\r\n   */\r\n  setInitialFocus?: boolean;\r\n\r\n  /**\r\n   * Set max height of callout\r\n   * When not set the callout will expand with contents up to the bottom of the screen\r\n   */\r\n  calloutMaxHeight?: number;\r\n\r\n  /**\r\n   * Callback when the Callout body is scrolled.\r\n   */\r\n  onScroll?: () => void;\r\n\r\n  /**\r\n   * Optional theme for component\r\n   */\r\n  theme?: ITheme;\r\n\r\n  /**\r\n   * Optional styles for the component.\r\n   */\r\n  styles?: IStyleFunctionOrObject<ICalloutContentStyleProps, ICalloutContentStyles>;\r\n\r\n  /**\r\n   * If specified, renders the Callout in a hidden state.\r\n   * Use this flag, rather than rendering a callout conditionally based on visibility,\r\n   * to improve rendering performance when it becomes visible.\r\n   * Note: When callout is hidden its content will not be rendered. It will only render\r\n   * once the callout is visible.\r\n   */\r\n  hidden?: boolean;\r\n}\r\n\r\nexport interface ICalloutContentStyleProps {\r\n  /**\r\n   * Theme to apply to the calloutContent.\r\n   */\r\n  theme: ITheme;\r\n\r\n  /**\r\n   * Width for callout including borders.\r\n   */\r\n  calloutWidth?: number;\r\n\r\n  /**\r\n   * CSS class to apply to the callout.\r\n   */\r\n  className?: string;\r\n\r\n  /**\r\n   * Callout positioning data\r\n   */\r\n  positions?: ICalloutPositionedInfo;\r\n\r\n  /**\r\n   * Whether or not to clip content of the callout,\r\n   * if it overflows vertically.\r\n   */\r\n  overflowYHidden?: boolean;\r\n\r\n  /**\r\n   * Background color for the beak and callout.\r\n   */\r\n  backgroundColor?: string;\r\n\r\n  /**\r\n   * Width of Callout beak\r\n   */\r\n  beakWidth?: number;\r\n\r\n  /**\r\n   * Max width for callout including borders.\r\n   */\r\n  calloutMaxWidth?: number;\r\n}\r\n\r\nexport interface ICalloutContentStyles {\r\n  /**\r\n   * Style for wrapper of Callout component.\r\n   */\r\n  container: IStyle;\r\n\r\n  /**\r\n   * Style for callout container root element.\r\n   */\r\n  root: IStyle;\r\n\r\n  /**\r\n   * Style for callout beak.\r\n   */\r\n  beak: IStyle;\r\n\r\n  /**\r\n   * Style for callout beak curtain.\r\n   */\r\n  beakCurtain: IStyle;\r\n\r\n  /**\r\n   * Style for content component of the callout.\r\n   */\r\n  calloutMain: IStyle;\r\n}\r\n"]}