{"version":3,"file":"SpanParser.js","sourceRoot":"","sources":["../../../AutoCollection/diagnostic-channel/SpanParser.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\nimport { Span, SpanKind } from \"../AsyncHooksScopeManager\";\nimport * as Contracts from \"../../Declarations/Contracts\";\nimport * as Constants from \"../../Declarations/Constants\";\n\nfunction filterSpanAttributes(attributes: Record<string, string>) {\n    const newAttributes = { ...attributes };\n    Object.keys(Constants.SpanAttribute).forEach(key => {\n        delete newAttributes[key];\n    });\n    return newAttributes\n}\n\nexport function spanToTelemetryContract(span: Span): (Contracts.DependencyTelemetry & Contracts.RequestTelemetry) & Contracts.Identified {\n    const id = `|${span.context().traceId}.${span.context().spanId}.`;\n    const duration = Math.round(span._duration[0] * 1e3 + span._duration[1] / 1e6);\n    const isHttp: boolean = ((span.attributes.component || \"\").toUpperCase() === Constants.DependencyTypeName.Http) || (!!span.attributes[Constants.SpanAttribute.HttpUrl]);\n    const isGrpc: boolean = (span.attributes.component || \"\").toLowerCase() === Constants.DependencyTypeName.Grpc;\n    if (isHttp) {\n        // Read http span attributes\n        const method = span.attributes[Constants.SpanAttribute.HttpMethod] || \"GET\";\n        const url = new URL(span.attributes[Constants.SpanAttribute.HttpUrl]);\n        const host = span.attributes[Constants.SpanAttribute.HttpHost] || url.host;\n        const port = span.attributes[Constants.SpanAttribute.HttpPort] || url.port || null;\n        const pathname = url.pathname || \"/\";\n\n        // Translate to AI Dependency format\n        const name = `${method} ${pathname}`;\n        const dependencyTypeName = Constants.DependencyTypeName.Http;\n        const target = port ? `${host}:${port}` : host;\n        const data = url.toString();\n        const resultCode = span.attributes[Constants.SpanAttribute.HttpStatusCode] || span.status.code || 0;\n        const success = resultCode < 400; // Status.OK\n        return {\n            id, name, dependencyTypeName,\n            target, data,\n            success, duration,\n            url: data,\n            resultCode: String(resultCode),\n            properties: filterSpanAttributes(span.attributes)\n        };\n    } else if (isGrpc) {\n        const method = span.attributes[Constants.SpanAttribute.GrpcMethod] || \"rpc\";\n        const service = span.attributes[Constants.SpanAttribute.GrpcService];\n        const name = service ? `${method} ${service}` : span.name;\n        return {\n            id, duration, name,\n            target: service,\n            data: service || name,\n            url: service || name,\n            dependencyTypeName: Constants.DependencyTypeName.Grpc,\n            resultCode: String(span.status.code || 0),\n            success: span.status.code === 0,\n            properties: filterSpanAttributes(span.attributes),\n        }\n    } else {\n        const name = span.name;\n        const links = span.links && span.links.map(link => {\n            return {\n                operation_Id: link.spanContext.traceId,\n                id: link.spanContext.spanId\n            };\n        });\n        return {\n            id, duration, name,\n            target: span.attributes[\"peer.address\"],\n            data: span.attributes[\"peer.address\"] || name,\n            url: span.attributes[\"peer.address\"] || name,\n            dependencyTypeName: span.kind === SpanKind.INTERNAL ? Constants.DependencyTypeName.InProc : (span.attributes.component || span.name),\n            resultCode: String(span.status.code || 0),\n            success: span.status.code === 0,\n            properties: {\n                ...filterSpanAttributes(span.attributes),\n                \"_MS.links\": links || undefined\n            },\n        };\n    }\n}\n"]}