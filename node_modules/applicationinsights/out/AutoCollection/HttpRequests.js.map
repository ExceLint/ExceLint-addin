{"version":3,"file":"HttpRequests.js","sourceRoot":"","sources":["../../AutoCollection/HttpRequests.ts"],"names":[],"mappings":"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","sourcesContent":["import http = require(\"http\");\nimport https = require(\"https\");\nimport url = require(\"url\");\n\nimport Contracts = require(\"../Declarations/Contracts\");\nimport TelemetryClient = require(\"../Library/TelemetryClient\");\nimport Logging = require(\"../Library/Logging\");\nimport Util = require(\"../Library/Util\");\nimport RequestResponseHeaders = require(\"../Library/RequestResponseHeaders\");\nimport HttpRequestParser = require(\"./HttpRequestParser\");\nimport { CorrelationContextManager, CorrelationContext, PrivateCustomProperties } from \"./CorrelationContextManager\";\nimport AutoCollectPerformance = require(\"./Performance\");\n\nclass AutoCollectHttpRequests {\n\n    public static INSTANCE: AutoCollectHttpRequests;\n\n    private static alreadyAutoCollectedFlag = '_appInsightsAutoCollected';\n\n    private _client: TelemetryClient;\n    private _isEnabled: boolean;\n    private _isInitialized: boolean;\n    private _isAutoCorrelating: boolean;\n\n    constructor(client: TelemetryClient) {\n        if (!!AutoCollectHttpRequests.INSTANCE) {\n            throw new Error(\"Server request tracking should be configured from the applicationInsights object\");\n        }\n\n        AutoCollectHttpRequests.INSTANCE = this;\n        this._client = client;\n    }\n\n    public enable(isEnabled:boolean) {\n        this._isEnabled = isEnabled;\n\n        // Autocorrelation requires automatic monitoring of incoming server requests\n        // Disabling autocollection but enabling autocorrelation will still enable\n        // request monitoring but will not produce request events\n        if ((this._isAutoCorrelating || this._isEnabled || AutoCollectPerformance.isEnabled()) && !this._isInitialized) {\n            this.useAutoCorrelation(this._isAutoCorrelating);\n            this._initialize();\n        }\n    }\n\n    public useAutoCorrelation(isEnabled:boolean, forceClsHooked?:boolean) {\n        if (isEnabled && !this._isAutoCorrelating) {\n            CorrelationContextManager.enable(forceClsHooked);\n        } else if (!isEnabled && this._isAutoCorrelating) {\n            CorrelationContextManager.disable();\n        }\n        this._isAutoCorrelating = isEnabled;\n    }\n\n    public isInitialized() {\n        return this._isInitialized;\n    }\n\n    public isAutoCorrelating() {\n        return this._isAutoCorrelating;\n    }\n\n    private _generateCorrelationContext(requestParser:HttpRequestParser): CorrelationContext {\n        if (!this._isAutoCorrelating) {\n            return;\n        }\n\n        return CorrelationContextManager.generateContextObject(\n            requestParser.getOperationId(this._client.context.tags),\n            requestParser.getRequestId(),\n            requestParser.getOperationName(this._client.context.tags),\n            requestParser.getCorrelationContextHeader(),\n            requestParser.getTraceparent(),\n            requestParser.getTracestate()\n        );\n    }\n\n    private _initialize() {\n        this._isInitialized = true;\n\n        const wrapOnRequestHandler: Function = (onRequest?: Function) => {\n            if (!onRequest) {\n                return undefined;\n            }\n            if (typeof onRequest !== 'function') {\n                throw new Error('onRequest handler must be a function');\n            }\n            return (request:http.ServerRequest, response:http.ServerResponse) => {\n                CorrelationContextManager.wrapEmitter(request);\n                CorrelationContextManager.wrapEmitter(response);\n                const shouldCollect: boolean = request && !(<any>request)[AutoCollectHttpRequests.alreadyAutoCollectedFlag];\n\n                if (request && shouldCollect) {\n                    // Set up correlation context\n                    const requestParser = new HttpRequestParser(request);\n                    const correlationContext = this._generateCorrelationContext(requestParser);\n\n                    // Note: Check for if correlation is enabled happens within this method.\n                    // If not enabled, function will directly call the callback.\n                    CorrelationContextManager.runWithContext(correlationContext, () => {\n                        if (this._isEnabled) {\n                            // Mark as auto collected\n                            (<any>request)[AutoCollectHttpRequests.alreadyAutoCollectedFlag] = true;\n\n                            // Auto collect request\n                            AutoCollectHttpRequests.trackRequest(this._client, {request: request, response: response}, requestParser);\n                        }\n\n                        if (typeof onRequest === \"function\") {\n                            onRequest(request, response);\n                        }\n                    });\n                } else {\n                    if (typeof onRequest === \"function\") {\n                        onRequest(request, response);\n                    }\n                }\n            }\n        }\n\n        // The `http.createServer` function will instantiate a new http.Server object.\n        // Inside the Server's constructor, it is using addListener to register the\n        // onRequest handler. So there are two ways to inject the wrapped onRequest handler:\n        // 1) Overwrite Server.prototype.addListener (and .on()) globally and not patching\n        //    the http.createServer call. Or\n        // 2) Overwrite the http.createServer method and add a patched addListener to the\n        //    fresh server instance. This seems more stable for possible future changes as\n        //    it also covers the case where the Server might not use addListener to manage\n        //    the callback internally.\n        //    And also as long as the constructor uses addListener to add the handle, it is\n        //    ok to patch the addListener after construction only. Because if we would patch\n        //    the prototype one and the createServer method, we would wrap the handler twice\n        //    in case of the constructor call.\n        const wrapServerEventHandler: Function = (server: (http.Server | https.Server)) => {\n            const originalAddListener = server.addListener.bind(server);\n            server.addListener = (eventType: string, eventHandler: Function) => {\n                switch (eventType) {\n                    case 'request':\n                    case 'checkContinue':\n                        return originalAddListener(eventType, wrapOnRequestHandler(eventHandler));\n                    default:\n                        return originalAddListener(eventType, eventHandler);\n                }\n            };\n            // on is an alias to addListener only\n            server.on = server.addListener;\n        }\n\n        const originalHttpServer = http.createServer;\n        http.createServer = (onRequest) => {\n            // todo: get a pointer to the server so the IP address can be read from server.address\n            const server: http.Server = originalHttpServer(wrapOnRequestHandler(onRequest));\n            wrapServerEventHandler(server);\n            return server;\n        }\n\n        const originalHttpsServer = https.createServer;\n        https.createServer = (options: https.ServerOptions, onRequest?: Function) => {\n            const server: https.Server = originalHttpsServer(options, wrapOnRequestHandler(onRequest));\n            wrapServerEventHandler(server);\n            return server;\n        }\n    }\n\n    /**\n     * Tracks a request synchronously (doesn't wait for response 'finish' event)\n     */\n    public static trackRequestSync(client: TelemetryClient, telemetry: Contracts.NodeHttpRequestTelemetry) {\n        if (!telemetry.request || !telemetry.response || !client) {\n            Logging.info(\"AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: \", !telemetry.request, !telemetry.response, !client);\n            return;\n        }\n\n        AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response);\n\n        // store data about the request\n        var correlationContext = CorrelationContextManager.getCurrentContext();\n        var requestParser = new HttpRequestParser(telemetry.request, (correlationContext && correlationContext.operation.parentId));\n\n        // Overwrite correlation context with request parser results\n        if (correlationContext) {\n            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;\n            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;\n            correlationContext.operation.parentId = requestParser.getRequestId() || correlationContext.operation.parentId;\n            (<PrivateCustomProperties>correlationContext.customProperties).addHeaderData(requestParser.getCorrelationContextHeader());\n        }\n\n        AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, telemetry.duration, telemetry.error);\n    }\n\n    /**\n     * Tracks a request by listening to the response 'finish' event\n     */\n    public static trackRequest(client: TelemetryClient, telemetry: Contracts.NodeHttpRequestTelemetry, _requestParser?:HttpRequestParser) {\n        if (!telemetry.request || !telemetry.response || !client) {\n            Logging.info(\"AutoCollectHttpRequests.trackRequest was called with invalid parameters: \", !telemetry.request, !telemetry.response, !client);\n            return;\n        }\n\n        // store data about the request\n        var correlationContext = CorrelationContextManager.getCurrentContext();\n        var requestParser = _requestParser || new HttpRequestParser(telemetry.request, correlationContext && correlationContext.operation.parentId);\n\n        if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl())) {\n            AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response);\n        }\n\n        // Overwrite correlation context with request parser results (if not an automatic track. we've already precalculated the correlation context in that case)\n        if (correlationContext && !_requestParser) {\n            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;\n            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;\n            correlationContext.operation.parentId = requestParser.getOperationParentId(client.context.tags) || correlationContext.operation.parentId;\n            (<PrivateCustomProperties>correlationContext.customProperties).addHeaderData(requestParser.getCorrelationContextHeader());\n        }\n\n        // response listeners\n        if (telemetry.response.once) {\n            telemetry.response.once(\"finish\", () => {\n                AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, null);\n            });\n        }\n\n        // track a failed request if an error is emitted\n        if (telemetry.request.on) {\n            telemetry.request.on(\"error\", (error:any) => {\n                AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, error);\n            });\n        }\n    }\n\n    /**\n     * Add the target correlationId to the response headers, if not already provided.\n     */\n    private static addResponseCorrelationIdHeader(client: TelemetryClient, response:http.ServerResponse) {\n        if (client.config && client.config.correlationId &&\n            response.getHeader && response.setHeader && !(<any>response).headersSent) {\n            const correlationHeader = <any>response.getHeader(RequestResponseHeaders.requestContextHeader);\n            Util.safeIncludeCorrelationHeader(client, response, correlationHeader);\n        }\n    }\n\n    private static endRequest(client: TelemetryClient, requestParser: HttpRequestParser, telemetry: Contracts.NodeHttpRequestTelemetry, ellapsedMilliseconds?: number, error?: any) {\n        if (error) {\n            requestParser.onError(error, ellapsedMilliseconds);\n        } else {\n            requestParser.onResponse(telemetry.response, ellapsedMilliseconds);\n        }\n\n        var requestTelemetry = requestParser.getRequestTelemetry(telemetry);\n\n        requestTelemetry.tagOverrides = requestParser.getRequestTags(client.context.tags);\n        if (telemetry.tagOverrides) {\n            for (let key in telemetry.tagOverrides) {\n                requestTelemetry.tagOverrides[key] = telemetry.tagOverrides[key];\n            }\n        }\n\n        const legacyRootId = requestParser.getLegacyRootId();\n        if (legacyRootId) {\n            requestTelemetry.properties[\"ai_legacyRootId\"] = legacyRootId;\n        }\n\n        requestTelemetry.contextObjects = requestTelemetry.contextObjects || {};\n        requestTelemetry.contextObjects[\"http.ServerRequest\"] = telemetry.request;\n        requestTelemetry.contextObjects[\"http.ServerResponse\"] = telemetry.response;\n\n        client.trackRequest(requestTelemetry);\n    }\n\n    public dispose() {\n         AutoCollectHttpRequests.INSTANCE = null;\n         this.enable(false);\n         this._isInitialized = false;\n         CorrelationContextManager.disable();\n         this._isAutoCorrelating = false;\n    }\n}\n\n\n\nexport = AutoCollectHttpRequests;\n"]}