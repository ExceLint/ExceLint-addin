{"version":3,"file":"SamplingTelemetryProcessor.js","sourceRoot":"","sources":["../../TelemetryProcessors/SamplingTelemetryProcessor.ts"],"names":[],"mappings":";;AAAA,qDAAwD;AAGxD;;GAEG;AACH,oCAA2C,QAA4B,EAAE,cAA0D;IAC/H,IAAI,kBAAkB,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC,mCAAmC;IACjF,IAAI,WAAW,GAAG,KAAK,CAAC;IAExB,EAAE,CAAC,CAAC,kBAAkB,KAAK,IAAI,IAAI,kBAAkB,KAAK,SAAS,IAAI,kBAAkB,IAAI,GAAG,CAAC,CAAC,CAAC;QAC/F,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAAC,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,IAAI,IAAI,SAAS,CAAC,aAAa,CAAC,MAAM,KAAK,SAAS,CAAC,uBAAuB,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAyC,CAAC,CAAC,CAAC,CAAC;QACxJ,6CAA6C;QAC7C,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAAC,IAAI,CAAC,EAAE,CAAC,CAAC,cAAc,CAAC,kBAAkB,IAAI,cAAc,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC,CAAC;QAC1F,mGAAmG;QACnG,WAAW,GAAG,mBAAmB,CAAC,cAAc,CAAC,kBAAkB,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,kBAAkB,CAAC;IAC3G,CAAC;IAAC,IAAI,CAAC,CAAC;QACJ,oGAAoG;QACpG,WAAW,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC,GAAG,kBAAkB,CAAC;IAC7D,CAAC;IAED,MAAM,CAAC,WAAW,CAAC;AACvB,CAAC;AAlBD,gEAkBC;AAED,8BAA8B;AAC9B,6BAAoC,KAAa;IAC7C,IAAI,SAAS,GAAG,CAAC,UAAU,CAAC;IAC5B,IAAI,SAAS,GAAG,UAAU,CAAC;IAC3B,IAAI,IAAI,GAAG,IAAI,CAAC;IAEhB,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;QACT,MAAM,CAAC,CAAC,CAAC;IACb,CAAC;IAED,OAAO,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACtB,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;IAC1B,CAAC;IAED,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QACpC,uGAAuG;QACvG,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAClE,CAAC;IAED,IAAI,GAAG,IAAI,IAAI,SAAS,GAAG,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACtD,MAAM,CAAC,CAAC,IAAI,GAAG,SAAS,CAAC,GAAG,GAAG,CAAC;AACpC,CAAC;AApBD,kDAoBC","sourcesContent":["import Contracts = require(\"../Declarations/Contracts\");\nimport { CorrelationContext } from \"../AutoCollection/CorrelationContextManager\";\n\n/**\n *  A telemetry processor that handles sampling.\n */\nexport function samplingTelemetryProcessor(envelope: Contracts.Envelope, contextObjects: { correlationContext: CorrelationContext }): boolean {\n    var samplingPercentage = envelope.sampleRate; // Set for us in Client.getEnvelope\n    var isSampledIn = false;\n\n    if (samplingPercentage === null || samplingPercentage === undefined || samplingPercentage >= 100) {\n        return true;\n    } else if (envelope.data && Contracts.TelemetryType.Metric === Contracts.baseTypeToTelemetryType(envelope.data.baseType as Contracts.TelemetryTypeValues)) {\n        // Exclude MetricData telemetry from sampling\n        return true;\n    } else if (contextObjects.correlationContext && contextObjects.correlationContext.operation) {\n        // If we're using dependency correlation, sampling should retain all telemetry from a given request\n        isSampledIn = getSamplingHashCode(contextObjects.correlationContext.operation.id) < samplingPercentage;\n    } else {\n        // If we're not using dependency correlation, sampling should use a random distribution on each item\n        isSampledIn = (Math.random() * 100) < samplingPercentage;\n    }\n\n    return isSampledIn;\n}\n\n/** Ported from AI .NET SDK */\nexport function getSamplingHashCode(input: string): number {\n    var csharpMin = -2147483648;\n    var csharpMax = 2147483647;\n    var hash = 5381;\n\n    if (!input) {\n        return 0;\n    }\n\n    while (input.length < 8) {\n        input = input + input;\n    }\n\n    for (var i = 0; i < input.length; i++) {\n        // JS doesn't respond to integer overflow by wrapping around. Simulate it with bitwise operators ( | 0)\n        hash = ((((hash << 5) + hash) | 0) + input.charCodeAt(i) | 0);\n    }\n\n    hash = hash <= csharpMin ? csharpMax : Math.abs(hash);\n    return (hash / csharpMax) * 100;\n}"]}