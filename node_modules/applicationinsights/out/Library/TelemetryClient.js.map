{"version":3,"file":"TelemetryClient.js","sourceRoot":"","sources":["../../Library/TelemetryClient.ts"],"names":[],"mappings":"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","sourcesContent":["import url = require(\"url\");\nimport os = require(\"os\");\n\nimport Config = require(\"./Config\");\nimport Context = require(\"./Context\");\nimport Contracts = require(\"../Declarations/Contracts\");\nimport Channel = require(\"./Channel\");\nimport TelemetryProcessors = require(\"../TelemetryProcessors\");\nimport { CorrelationContextManager } from \"../AutoCollection/CorrelationContextManager\";\nimport Sender = require(\"./Sender\");\nimport Util = require(\"./Util\");\nimport Logging = require(\"./Logging\");\nimport FlushOptions = require(\"./FlushOptions\");\nimport EnvelopeFactory = require(\"./EnvelopeFactory\");\nimport QuickPulseStateManager = require(\"./QuickPulseStateManager\");\n\n/**\n * Application Insights telemetry client provides interface to track telemetry items, register telemetry initializers and\n * and manually trigger immediate sending (flushing)\n */\nclass TelemetryClient {\n    private _telemetryProcessors: { (envelope: Contracts.Envelope, contextObjects: { [name: string]: any; }): boolean; }[] = [];\n\n    public config: Config;\n    public context: Context;\n    public commonProperties: { [key: string]: string; };\n    public channel: Channel;\n    public quickPulseClient: QuickPulseStateManager;\n\n    /**\n     * Constructs a new client of the client\n     * @param setupString the Connection String or Instrumentation Key to use (read from environment variable if not specified)\n     */\n    constructor(setupString?: string) {\n        var config = new Config(setupString);\n        this.config = config;\n        this.context = new Context();\n        this.commonProperties = {};\n\n        var sender = new Sender(this.config);\n        this.channel = new Channel(() => config.disableAppInsights, () => config.maxBatchSize, () => config.maxBatchIntervalMs, sender);\n    }\n\n    /**\n     * Log information about availability of an application\n     * @param telemetry      Object encapsulating tracking options\n     */\n    public trackAvailability(telemetry: Contracts.AvailabilityTelemetry): void {\n        this.track(telemetry, Contracts.TelemetryType.Availability);\n    }\n\n    /**\n     * Log a page view\n     * @param telemetry      Object encapsulating tracking options\n     */\n    public trackPageView(telemetry: Contracts.PageViewTelemetry): void {\n        this.track(telemetry, Contracts.TelemetryType.PageView);\n    }\n\n    /**\n     * Log a trace message\n     * @param telemetry      Object encapsulating tracking options\n     */\n    public trackTrace(telemetry: Contracts.TraceTelemetry): void {\n        this.track(telemetry, Contracts.TelemetryType.Trace);\n    }\n\n    /**\n     * Log a numeric value that is not associated with a specific event. Typically used to send regular reports of performance indicators.\n     * To send a single measurement, use just the first two parameters. If you take measurements very frequently, you can reduce the\n     * telemetry bandwidth by aggregating multiple measurements and sending the resulting average at intervals.\n     * @param telemetry      Object encapsulating tracking options\n     */\n    public trackMetric(telemetry: Contracts.MetricTelemetry): void {\n        this.track(telemetry, Contracts.TelemetryType.Metric);\n    }\n\n    /**\n     * Log an exception\n     * @param telemetry      Object encapsulating tracking options\n     */\n    public trackException(telemetry: Contracts.ExceptionTelemetry): void {\n        if (telemetry && telemetry.exception && !Util.isError(telemetry.exception)) {\n            telemetry.exception = new Error(telemetry.exception.toString());\n        }\n        this.track(telemetry, Contracts.TelemetryType.Exception);\n    }\n\n    /**\n     * Log a user action or other occurrence.\n     * @param telemetry      Object encapsulating tracking options\n     */\n    public trackEvent(telemetry: Contracts.EventTelemetry): void {\n        this.track(telemetry, Contracts.TelemetryType.Event);\n    }\n\n    /**\n     * Log a request. Note that the default client will attempt to collect HTTP requests automatically so only use this for requests\n     * that aren't automatically captured or if you've disabled automatic request collection.\n     *\n     * @param telemetry      Object encapsulating tracking options\n     */\n    public trackRequest(telemetry: Contracts.RequestTelemetry & Contracts.Identified): void {\n        this.track(telemetry, Contracts.TelemetryType.Request);\n    }\n\n    /**\n     * Log a dependency. Note that the default client will attempt to collect dependencies automatically so only use this for dependencies\n     * that aren't automatically captured or if you've disabled automatic dependency collection.\n     *\n     * @param telemetry      Object encapsulating tracking option\n     * */\n    public trackDependency(telemetry: Contracts.DependencyTelemetry & Contracts.Identified) {\n\n        if (telemetry && !telemetry.target && telemetry.data) {\n            // url.parse().host returns null for non-urls,\n            // making this essentially a no-op in those cases\n            // If this logic is moved, update jsdoc in DependencyTelemetry.target\n            telemetry.target = url.parse(telemetry.data).host;\n        }\n        this.track(telemetry, Contracts.TelemetryType.Dependency);\n    }\n\n    /**\n     * Immediately send all queued telemetry.\n     * @param options Flush options, including indicator whether app is crashing and callback\n     */\n    public flush(options?: FlushOptions) {\n        this.channel.triggerSend(\n            options ? !!options.isAppCrashing : false,\n            options ? options.callback : undefined);\n    }\n\n    /**\n     * Generic track method for all telemetry types\n     * @param data the telemetry to send\n     * @param telemetryType specify the type of telemetry you are tracking from the list of Contracts.DataTypes\n     */\n    public track(telemetry: Contracts.Telemetry, telemetryType: Contracts.TelemetryType) {\n        if (telemetry && Contracts.telemetryTypeToBaseType(telemetryType)) {\n            var envelope = EnvelopeFactory.createEnvelope(telemetry, telemetryType, this.commonProperties, this.context, this.config);\n\n            // Set time on the envelope if it was set on the telemetry item\n            if (telemetry.time) {\n                envelope.time = telemetry.time.toISOString();\n            }\n\n            var accepted = this.runTelemetryProcessors(envelope, telemetry.contextObjects);\n\n            // Ideally we would have a central place for \"internal\" telemetry processors and users can configure which ones are in use.\n            // This will do for now. Otherwise clearTelemetryProcessors() would be problematic.\n            accepted = accepted && TelemetryProcessors.samplingTelemetryProcessor(envelope, { correlationContext: CorrelationContextManager.getCurrentContext() });\n\n            if (accepted) {\n                TelemetryProcessors.performanceMetricsTelemetryProcessor(envelope, this.quickPulseClient);\n                this.channel.send(envelope);\n            }\n        }\n        else {\n            Logging.warn(\"track() requires telemetry object and telemetryType to be specified.\")\n        }\n    }\n\n    /**\n     * Adds telemetry processor to the collection. Telemetry processors will be called one by one\n     * before telemetry item is pushed for sending and in the order they were added.\n     *\n     * @param telemetryProcessor function, takes Envelope, and optional context object and returns boolean\n     */\n    public addTelemetryProcessor(telemetryProcessor: (envelope: Contracts.Envelope, contextObjects?: { [name: string]: any; }) => boolean) {\n        this._telemetryProcessors.push(telemetryProcessor);\n    }\n\n    /*\n     * Removes all telemetry processors\n     */\n    public clearTelemetryProcessors() {\n        this._telemetryProcessors = [];\n    }\n\n    private runTelemetryProcessors(envelope: Contracts.Envelope, contextObjects: { [name: string]: any; }): boolean {\n        var accepted = true;\n        var telemetryProcessorsCount = this._telemetryProcessors.length;\n\n        if (telemetryProcessorsCount === 0) {\n            return accepted;\n        }\n\n        contextObjects = contextObjects || {};\n        contextObjects['correlationContext'] = CorrelationContextManager.getCurrentContext();\n\n        for (var i = 0; i < telemetryProcessorsCount; ++i) {\n            try {\n                var processor = this._telemetryProcessors[i];\n                if (processor) {\n                    if (processor.apply(null, [envelope, contextObjects]) === false) {\n                        accepted = false;\n                        break;\n                    }\n                }\n\n            } catch (error) {\n                accepted = true;\n                Logging.warn(\"One of telemetry processors failed, telemetry item will be sent.\", error, envelope);\n            }\n        }\n\n        return accepted;\n    }\n}\n\nexport = TelemetryClient;\n"]}